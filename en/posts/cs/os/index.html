<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Operating System | chx9</title>
<meta name="keywords" content="">
<meta name="description" content="进程和线程区别 1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序 2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。线程启动速度快，轻量级 进程">
<meta name="author" content="chx9">
<link rel="canonical" href="https://chx9.github.io/en/posts/cs/os/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://chx9.github.io/img/svin.webp">
<link rel="icon" type="image/png" sizes="16x16" href="https://chx9.github.io/img/svin.webp">
<link rel="icon" type="image/png" sizes="32x32" href="https://chx9.github.io/img/svin.webp">
<link rel="apple-touch-icon" href="https://chx9.github.io/img/svin.webp">
<link rel="mask-icon" href="https://chx9.github.io/img/svin.webp">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script defer src="https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="Operating System" />
<meta property="og:description" content="进程和线程区别 1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序 2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。线程启动速度快，轻量级 进程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chx9.github.io/en/posts/cs/os/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-29T11:05:53+08:00" />
<meta property="article:modified_time" content="2023-07-29T11:05:53+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Operating System"/>
<meta name="twitter:description" content="进程和线程区别 1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序 2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。线程启动速度快，轻量级 进程"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [

        {
          "@type": "ListItem",
          "position":  1 ,
          "name": "📚Articles",
          "item": "https://chx9.github.io/en/posts/"
        },

        {
          "@type": "ListItem",
          "position":  2 ,
          "name": "💻 Programming Basics",
          "item": "https://chx9.github.io/en/posts/cs/"
        }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Operating System",
      "item": "https://chx9.github.io/en/posts/cs/os/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Operating System",
  "name": "Operating System",
  "description": "进程和线程区别 1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序 2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。线程启动速度快，轻量级 进程",
  "keywords": [
    ""
  ],
  "articleBody": "进程和线程区别 1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序\n2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。线程启动速度快，轻量级\n进程的资源：\n独立的内存空间（虚拟地址空间） 系统资源，如打开的文件、信号处理器等 线程的资源:\n程序计数器：用于指令读取，函数调用，指令跳转 寄存器：用于保存线程的上下文信息。 栈 协程 协程是用户态的轻量级线程，线程内部调度的基本单位，都是运行在用户态，拥有自己的寄存器上下文和栈 c++的协程库: boost coroutine, libco\n线程由操作系统管理，切换需要操作系统内核，耗费时间和资源，协程切换是程序员自己控制 线程之间通信通过共享内存或者传递消息，而协程之间直接通过函数调用或者共享变量 线程可以通过多个cpu实现并行，但是协程只在一个线程中 线程创建、销毁需要操作系统接入，而协程在用户空间内完成 协程适用于 高并的网络编程，异步io操作，高并发网络编程，**短时间的计算密集型，**线程：cpu密集型 多个线程情况下CPU利用率不高 1、同步和通信不高效(死锁，数据竞争)\n2、线程过多：竞争过于激烈； 线程数过少：CPU核心限制\n3、io密集型\nepoll的底层实现 红黑树用来管理所有的文件描述符\n内核中的事件表：存储所有就绪的文件描述符\n内核中的回调函数：内核调用回调函数处理处理所有就绪的文件描述符 同步模型的优点：\n同步io和异步io的优缺点 同步io优点：\n编程简单 可靠性高（阻塞） 同步模型的缺点：\n性能低（阻塞） 异步模型的优点： 高性能 编程复杂 异步模型的缺点：\n可靠性低（可能会出现操作未完成就返回结果，需要判断错误） 互斥锁、读写锁、自旋锁 互斥锁，最基本的同步机制，保护临界区资源访问\n读写锁，允许多个线程同时读共享资源，但是只允许一个锁读取共享资源，读写锁的实现通常是基于互斥锁和条件变量实现的。\n自旋锁是一种轻量级同步机制，当自旋锁被占用时，线程不会进入阻塞状态，而是一直循环等待，适用于锁占用短的场景，锁占用长的\n加锁的方式 阻塞锁，一直等待资源 自旋锁，一直循环等待 乐观锁，假设读取共享资源的时候不会修改它，如果被修改了，就重新尝试 信号量能保证线程同步吗？ 信号量可以用来保证线程同步，但最好与锁一起使用来保证线程互斥。信号量是一种计数器，用来保护共享资源。当一个线程想要访问共享资源时，它必须先获取信号量，然后才能访问共享资源。如果信号量的计数器为0，则线程必须等待，直到有另一个线程释放信号量。这样可以确保多个线程不会同时访问共享资源，从而保证线程同步。\n在使用信号量时，需要注意一些问题。首先，信号量只能保证线程同步，不能保证线程互斥。如果多个线程都可以获得信号量，则它们可以同时访问共享资源。因此，最好与锁一起使用来保证线程互斥。其次，信号量可能会产生死锁问题。当多个线程互相等待对方释放信号量时，就会发生死锁。因此，在使用信号量时，需要仔细考虑并发情况，以确保线程安全和性能。\nlinux下递归删除某个目录下以cpp为结尾的文件 find /path/to/dir -name \"*.cpp\" -type f -delete 如果不加 -type f，find 命令会查找目录中的所有类型的文件，包括普通文件、目录、符号链接等，可能会误删一些非文件类型的内容。加上 -type f 可以限定只查找普通文件，避免误删其他类型的内容。\n死锁的四个条件 互斥条件：一个资源每次只能被一个进程使用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 如果一个系统中存在上述四个条件，就会出现死锁的情况，死锁的解决方法通常需要采用多种方法，如锁机制的优化、资源分配算法的改进等。\n内核态和用户态 用户态和内核态是计算机操作系统中的两种不同的运行模式。\n用户态是指进程在执行普通用户程序时所处的运行模式。在用户态下，进程只能访问有限的资源，\n内核态是指操作系统运行在特权级别最高的运行模式。在内核态下，操作系统可以直接访问所有系统资源，如CPU、内存、硬件设备和其他进程的内存空间等。\n当一个进程需要访问操作系统的核心代码或其他进程的内存空间时，它必须通过系统调用进入内核态。在进入内核态时，系统会将进程的状态保存起来，以便在系统调用完成后能够恢复原有的状态。当操作完成后，进程会被切换回用户态，继续执行普通用户程序。\n用户态和内核态的切换会带来一定的开销，因此操作系统需要尽可能地减少这种切换的次数。\nlinux常用命令 下面列举一些常用的Linux命令：\nls：列出目录下的文件和子目录。 cd：切换当前目录。 pwd：显示当前所在目录的路径。 mkdir：创建一个新目录。 rmdir：删除一个空目录。 rm：删除文件或目录。 cp：复制文件或目录。 mv：移动或重命名文件或目录。 cat：查看文件内容。 grep：在文件或输入流中查找匹配的文本。 tail：查看文件的末尾内容。 head：查看文件的开头内容。 find：在指定目录下查找文件。 chmod：修改文件或目录的权限。 chown：修改文件或目录的所有者。 ps：查看当前系统进程。 top：查看当前系统资源占用情况。 tar：打包和解压缩文件。 ssh：远程登录到另一台计算机。 scp：在本地和远程计算机之间复制文件。 df：查看磁盘空间使用情况。 free：查看系统内存使用情况。 uname：查看系统信息。 ifconfig：查看网络接口信息。 ping：测试网络连接。 traceroute：查看网络路由情况。 netstat：显示网络连接、路由表和网络接口等信息。 iptables：管理系统防火墙规则。 systemctl：管理系统服务。 ps aux：显示所有进程的详细信息。 kill：终止指定进程。 nohup：让进程在后台运行。 screen：在一个终端窗口中打开多个终端会话。 wget：下载文件。 curl：向服务器发送请求并显示响应。 tar：压缩和解压缩文件。 gzip：压缩和解压缩文件。 zip：压缩和解压缩文件。 ssh-keygen：生成SSH密钥对。 linux中查询进程占用cpu的情况 在Linux系统中，可以使用 top 命令来查看系统中占用CPU最多的进程，具体操作如下：\n打开终端并输入 top 命令。 top 命令会实时显示系统资源使用情况，包括CPU、内存、进程等。在进程列表中，可以看到各个进程的CPU使用情况以及其他相关信息。 进程列表默认按照CPU使用率排序，可以通过按下“P”键，然后再按下“Enter”键，将进程列表按照CPU使用率从高到低排序。\n打开终端并输入 ps aux 命令。 ps 命令会列出当前系统中所有的进程，包括进程的PID、CPU占用率、内存使用情况等。 若要按照CPU使用率排序，可以使用 ps aux –sort=-%cpu 命令。\n0拷贝 https://www.cnblogs.com/xiaolincoding/p/13719610.html 普通拷贝 内存映射 mmap sendfile 零拷贝（Zero Copy）是一种提高数据传输效率和性能的技术，其基本思想是在数据传输过程中减少数据拷贝和内存复制操作，从而减少CPU的开销和系统资源的占用，提高数据传输的效率和性能。\n在传统的数据传输方式中，数据通常需要从应用程序的缓冲区复制到内核空间的缓冲区，然后再从内核空间的缓冲区复制到网络设备的缓冲区，最后再从网络设备的缓冲区复制到目标主机的内核空间缓冲区，最后再从目标主机的内核空间缓冲区复制到目标应用程序的缓冲区。这样的数据传输方式需要经过多次数据拷贝和内存复制操作，耗费大量的CPU时间和系统资源，降低了数据传输的效率和性能。\n零拷贝技术可以通过使用DMA（Direct Memory Access）技术和共享内存等技术，将数据从应用程序的缓冲区直接传输到网络设备的缓冲区，从而避免了数据拷贝和内存复制操作。这样就可以大大减少CPU的开销和系统资源的占用，提高数据传输的效率和性能。\n在使用零拷贝技术时，需要注意以下几点：\n零拷贝技术需要硬件和操作系统的支持，不是所有的硬件和操作系统都支持零拷贝技术。 零拷贝技术需要应用程序和网络设备之间的协作，需要对数据传输进行特殊处理。 零拷贝技术可能会增加代码的复杂度和难度，需要谨慎使用。 总之，零拷贝技术可以提高数据传输的效率和性能，但需要硬件和操作系统的支持，并且需要谨慎使用。\n页调度/置换算法 页调度（Page Replacement）是操作系统中的一个重要概念，用于管理内存中的虚拟页（Virtual Page），当内存中的页框（Page Frame）不足时，需要将某些页从内存中换出（Swap Out），并将新的页换入（Swap In），以便为新的进程或线程腾出空间。\n页调度算法的主要目标是最大化内存的利用率，同时尽可能地减少缺页中断（Page Fault）的次数，从而提高系统的性能。常见的页调度算法包括以下几种：\n先进先出（First-In-First-Out，FIFO）：按照进入内存的时间顺序，将最先进入内存的页换出，以腾出空间给新的页。这种算法简单、易于实现，但是容易产生“抖动”（Thrashing）现象，即不断地发生缺页中断和页调度操作，导致系统性能下降。\n最近最少使用（Least Recently Used，LRU）：根据页的访问时间，将最近最久未被使用的页换出，以腾出空间给新的页。这种算法可以有效地减少缺页中断的次数，但是实现较为复杂，需要对每个页的访问时间进行记录。\n最不经常使用（Least Frequently Used，LFU）：根据页的访问次数，将最不经常使用的页换出，以腾出空间给新的页。这种算法可以有效地减少缺页中断的次数，但是容易受到访问模式的影响，如果某个页在短时间内被访问多次，可能会被错误地保留在内存中。\n时钟（Clock）：将页框按照时钟指针的顺序进行循环扫描，找到最早未被使用的页框，将其中的页换出，以腾出空间给新的页。这种算法可以有效地减少缺页中断的次数，但是可能会产生“抖动”现象。\n最优（Optimal）：根据未来的访问情况，找到未来最长时间内不会被访问的页，将其中的页换出，以腾出空间给新的页。这种算法可以最小化缺页中断的次数，但是需要对未来的访问情况进行预测，实现较为困难。\n总之，页调度算法是操作系统中内存管理的重要组成部分，不同的页调度算法具有不同的特点和优缺点，需要根据具体的应用场景进行选择。\n如何优化生产者消费者模型 生产者消费者模型是一种常见的并发编程模型，它包括生产者线程和消费者线程两部分。生产者线程负责生产数据并将数据存储到缓冲区中，消费者线程负责从缓冲区中取数据并进行处理。为了提高生产者消费者模型的效率，可以考虑以下几个方面：\n使用无锁数据结构 在生产者消费者模型中，缓冲区是生产者和消费者之间的关键数据结构。如果使用锁来保护缓冲区，会导致线程间的竞争和等待，从而降低系统的并发性能。因此，可以考虑使用无锁数据结构来实现缓冲区，例如无锁队列、无锁循环缓冲区等。无锁数据结构可以避免线程间的竞争和等待，从而提高系统的并发性能。\n使用多个缓冲区 为了减少线程间的竞争，可以使用多个缓冲区来分散生产者和消费者之间的压力。例如，可以使用多个队列来存储生产者生产的数据，消费者从其中选择一个队列来消费数据。这样可以减少线程间的竞争和等待，从而提高系统的并发性能。\n使用信号量 信号量是一种常见的同步原语，可以用来解决生产者消费者模型中的同步问题。可以使用两个信号量来实现生产者消费者模型：一个信号量表示缓冲区中可用的槽位数量，另一个信号量表示缓冲区中已经存储的数据数量。生产者在生产数据之前需要获取可用槽位数量的信号量，消费者在消费数据之前需要获取已经存储的数据数量的信号量。这样可以保证生产者和消费者之间的同步，避免了线程间的竞争和等待，从而提高系统的并发性能。\n优化线程池 在生产者消费者模型中，线程池是扮演着重要角色的。为了提高生产者消费者模型的效率，可以考虑优化线程池的实现。例如，可以使用线程池来管理生产者和消费者线程，避免线程的频繁创建和销毁。同时，可以考虑使用线程池来实现任务的调度和负载均衡，从而提高系统的并发性能。\n总之，提高生产者消费者模型的效率需要从多个方面入手，包括使用无锁数据结构、使用多个缓冲区、使用信号量、优化线程池等。针对具体的应用场景，需要根据实际情况进行选择和优化。\nDMA技术（page cache） DMA技术（Direct Memory Access，直接内存存取）是一种计算机数据传输技术，可以在不经过CPU的干预下直接将数据从外部设备传输到内存或从内存传输到外部设备。\n在传统的计算机数据传输过程中，CPU需要占用大量时间来处理数据的传输，这就会导致CPU效率低下。而DMA技术的出现，可以允许设备直接访问系统内存，从而避免了CPU在数据传输过程中的干扰，提高了数据传输效率。\nDMA技术通常用于高速数据传输，例如硬盘驱动器、网卡、音频设备和视频设备等。它可以显著提高计算机的数据传输速度，并且降低了CPU的负载。\n分段和分页 分段 程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。 通过段号和偏移量确定物理地址 不足之处：\n内存碎片的问题（外部内存）。 内存交换的效率低。 分页 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小\n页表是存储在内存里的，内存管理单元 （MMU） 就做将虚拟内存地址转换成物理地址的工作。\n提高内存的利用率，没有外部碎片 但会产生内碎片（一个页可能填充不满）。 而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。\n如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。\nTLB,页表缓存\n如何优化读 在多线程编程中，读请求是比较频繁的操作，如果读请求的性能不佳，可能会导致系统的整体性能下降。因此，对读请求的优化非常重要。\n以下是一些优化读请求的常见方法：\n读写分离：读写分离是一种常见的优化读请求的方法，通过将读请求和写请求分别处理，可以避免读请求和写请求之间的竞争和互斥，从而提高系统的整体性能。在读写分离的模式下，读请求可以并行处理，而写请求需要独占资源，因此可以将读写分离的模式应用于高并发读请求的场景。\n缓存：缓存是一种常见的优化读请求的方法，通过将频繁读取的数据缓存到内存中，可以避免每次读取都需要访问磁盘或者网络的开销，从而提高读请求的性能。在应用缓存的时候，需要注意缓存的一致性和更新策略，避免数据不一致的问题。\n预加载：预加载是一种优化读请求的方法，通过在应用启动时预先加载数据到内存中，可以避免后续读请求需要访问磁盘或者网络的开销，从而提高读请求的性能。在预加载的时候，需要根据具体业务场景选择合适的数据量和预加载策略。\n数据分片：数据分片是一种优化读请求的方法，通过将数据分成多个片段，并将每个片段分布到不同的节点或者服务器上，可以并行处理读请求，从而提高读请求的性能。在应用数据分片的时候，需要注意数据的分布均衡和数据分片的策略，避免数据倾斜和数据不一致的问题。\n数据压缩：数据压缩是一种优化读请求的方法，通过将数据压缩后存储到磁盘或者网络中，可以减少读取数据的大小，从而降低读请求的网络和磁盘开销，提高读请求的性能。在应用数据压缩的时候，需要注意压缩算法的选择和压缩效率的平衡，避免压缩和解压缩的开销过大的问题。\n总之，优化读请求的方法有很多种，需要根据具体的业务场景和需求选择合适的方法，从而提高系统的整体性能。\n虚拟内存 虚拟内存是一种计算机内存管理技术，它允许操作系统将一个进程使用的内存分成多个部分，并且不需要把它们全部保存在物理内存中。操作系统会将一部分当前未使用的进程内存数据保存在硬盘上，以便释放出物理内存给其他进程使用。当进程需要访问被保存在硬盘上的数据时，操作系统会将它们再次读取到物理内存中，并且在需要时将其写回硬盘。这个过程是透明的，用户无需了解虚拟内存的存在。虚拟内存可以极大地提高计算机的性能，因为它允许进程使用比物理内存更多的内存，而不会导致系统崩溃或进程崩溃。\nkill -9 和kill -15的区别？ kill命令用于发送信号给一个进程，让进程做出相应的操作，例如结束进程、重启进程等。\nkill命令有很多选项，其中最常用的是kill -9和kill -15。它们的区别在于发送的信号不同，具体如下：\nkill -9：发送SIGKILL信号给进程，该信号是不能被捕获或忽略的，进程会被立即终止，而不会有任何机会去清理和释放资源。因此，使用kill -9命令经常被称为“强制杀死”进程，它可以保证进程一定被杀死，但可能会导致数据丢失或系统崩溃等问题。\nkill -15：发送SIGTERM信号给进程，该信号是可以被捕获和处理的。进程收到SIGTERM信号后，会先尝试清理和释放资源，然后再终止进程。因此，使用kill -15命令可以安全地关闭进程，让进程有机会去清理资源，但并不保证一定能成功终止进程，因为进程可能会忽略或拒绝处理SIGTERM信号。\n综上所述，一般情况下，建议使用kill -15命令来结束进程，这样可以让进程有机会去做一些清理工作，并尽可能地避免数据丢失和系统崩溃等问题。但在某些情况下，如进程无法响应信号或出现死锁等问题时，可能需要使用kill -9命令来强制杀死进程。\n僵尸进程和孤儿进程 僵尸进程和孤儿进程都是进程的一种状态。\n僵尸进程（Zombie Process）是指一个已经完成执行但其父进程尚未调用wait()或waitpid()系统调用来获取其终止状态的进程。在这种情况下，进程的进程控制块（Process Control Block，PCB）仍然存在于系统中，但进程的其他资源（如内存、文件描述符等）已经被释放。僵尸进程不会再消耗系统资源，但如果它们数量过多，可能会影响系统性能。\n孤儿进程（Orphan Process）是指其父进程已经终止或不存在，但该进程仍然在运行。孤儿进程会被init进程接管，init进程会成为孤儿进程的新父进程，通过这种方式来保证孤儿进程能够正常终止。\n杀死僵尸进程的方法如下：\n使用kill命令向僵尸进程的父进程发送SIGCHLD信号，让父进程调用wait()或waitpid()系统调用来获取僵尸进程的终止状态并释放其PCB。\n手动杀死僵尸进程的父进程，这样僵尸进程就会成为孤儿进程，并被init进程接管。\n使用编程方式处理僵尸进程，即在父进程中捕获SIGCHLD信号，并在信号处理函数中调用wait()或waitpid()系统调用来获取僵尸进程的终止状态并释放其PCB。\n总之，为了避免出现僵尸进程和孤儿进程，编写程序时需要注意及时调用wait()或waitpid()系统调用来获取子进程的终止状态，并在必要时向子进程发送信号来终止它们的执行。\n自旋锁和互斥锁 互斥锁是一种基于线程阻塞的同步机制，当一个线程占用了互斥锁时，其他线程必须等待该线程释放锁才能继续执行。互斥锁使用操作系统提供的系统调用实现，需要在用户态和内核态之间进行多次上下文切换，因此效率较低。互斥锁适用于在共享资源访问时需要长时间等待的情况。\n自旋锁的基本思想是在获取锁之前，不断地忙等待直到获取到锁为止。 自旋锁适用于以下情况：\n共享资源的访问时间非常短暂，线程不希望进入睡眠状态造成额外的开销。 线程调度开销较大，上下文切换会带来较高的性能开销。 线程持有锁的时间非常短暂，不会引起太多的竞争。 sed和awk的区别 awk主要用于提取和分析数据,分析需要的列和行,计算列的和等等。它适合用于处理大型文件的分析工作。\nsed主要用于进行行内搜索和替换,删除或插入行等简单的文本转换操作。它更适合用于小型文件的简单修改。\n",
  "wordCount" : "8069",
  "inLanguage": "en",
  "datePublished": "2023-07-29T11:05:53+08:00",
  "dateModified": "2023-07-29T11:05:53+08:00",
  "author":[{
    "@type": "Person",
    "name": "chx9"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://chx9.github.io/en/posts/cs/os/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "chx9",
    "logo": {
      "@type": "ImageObject",
      "url": "https://chx9.github.io/img/svin.webp"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    (function () {
        let  arr,reg = new RegExp("(^| )"+"change-themes"+"=([^;]*)(;|$)");
        if(arr = document.cookie.match(reg)) {
        } else {
            if (new Date().getHours() >= 19 || new Date().getHours() < 6) {
                document.body.classList.add('dark');
                localStorage.setItem("pref-theme", 'dark');
            } else {
                document.body.classList.remove('dark');
                localStorage.setItem("pref-theme", 'light');
            }
        }
    })()

    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://chx9.github.io/en/" accesskey="h" title="chx9 (Alt + H)">chx9</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://chx9.github.io/en/search" title="🔍 search (Alt &#43; /)" accesskey=/>
                <span>🔍 search</span>
                </a>
            </li>
            <li>
                <a href="https://chx9.github.io/en/" title="🏠 home">
                <span>🏠 home</span>
                </a>
            </li>
            <li>
                <a href="https://chx9.github.io/en/posts" title="📚 articles">
                <span>📚 articles</span>
                </a>
            </li>
            <li>
                <a href="https://chx9.github.io/en/tags" title="🧩 tags">
                <span>🧩 tags</span>
                </a>
            </li>
            <li>
                <a href="https://chx9.github.io/en/about" title="🙋🏻‍♂️ about">
                <span>🙋🏻‍♂️ about</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }
</style>

<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://chx9.github.io/en/">🏠 主页</a>&nbsp;»&nbsp;<a href="https://chx9.github.io/en/posts/">📚Articles</a>&nbsp;»&nbsp;<a href="https://chx9.github.io/en/posts/cs/">💻 Programming Basics</a></div>
            <h1 class="post-title">
                Operating System
            </h1>
            <div class="post-meta">

<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2023-07-29
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>8069字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>17分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>chx9
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
            </span>
        </span>
    </span>
</span>
<span style="opacity: 0.8;">
                    <span id="post_meta_style_7">
                        &nbsp;&nbsp;
                        <span class="fa fa-eye" ></span>
                        <span>
                            <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
                            &nbsp;&nbsp;
                        </span>
                    </span>
                    <span id="post_meta_style_8">
                        <span class="fa fa-commenting-o"></span>
                        <span>
                            <script src="https://cdn.staticfile.org/twikoo//twikoo.all.min.js"></script>
                            <script>
                                let url = document.documentURI
                                
                                let dnsUrl = "https://chx9.github.io/"
                                let urlSplit = url.split(dnsUrl)
                                let finalUrl = urlSplit[1]
                                if (finalUrl[0] !== '/') {
                                    finalUrl = '/'+finalUrl
                                }
                                twikoo.getCommentsCount({
                                    envId:  null , 
                                region:  null , 
                                urls: [ 
                                    
                                    finalUrl,
                                ],
                                    includeReply: false 
                                }).then(function (res) {
                                    let count = res[0].count
                                    const obj = document.getElementById("comment_count");
                                    obj.innerText = count
                                    
                                    
                                    
                                }).catch(function (err) {
                                    
                                    console.error(err);
                                });
                            </script>
                            <span id="comment_count"></span>
                        </span>
                    </span>
                </span>

</div>
        </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b%e5%92%8c%e7%ba%bf%e7%a8%8b%e5%8c%ba%e5%88%ab" aria-label="进程和线程区别">进程和线程区别</a></li>
                <li>
                    <a href="#%e5%8d%8f%e7%a8%8b" aria-label="协程">协程</a></li>
                <li>
                    <a href="#%e5%a4%9a%e4%b8%aa%e7%ba%bf%e7%a8%8b%e6%83%85%e5%86%b5%e4%b8%8bcpu%e5%88%a9%e7%94%a8%e7%8e%87%e4%b8%8d%e9%ab%98" aria-label="多个线程情况下CPU利用率不高">多个线程情况下CPU利用率不高</a></li>
                <li>
                    <a href="#epoll%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0" aria-label="epoll的底层实现">epoll的底层实现</a></li>
                <li>
                    <a href="#%e5%90%8c%e6%ad%a5io%e5%92%8c%e5%bc%82%e6%ad%a5io%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9" aria-label="同步io和异步io的优缺点">同步io和异步io的优缺点</a></li>
                <li>
                    <a href="#%e4%ba%92%e6%96%a5%e9%94%81%e8%af%bb%e5%86%99%e9%94%81%e8%87%aa%e6%97%8b%e9%94%81" aria-label="互斥锁、读写锁、自旋锁">互斥锁、读写锁、自旋锁</a></li>
                <li>
                    <a href="#%e5%8a%a0%e9%94%81%e7%9a%84%e6%96%b9%e5%bc%8f" aria-label="加锁的方式">加锁的方式</a></li>
                <li>
                    <a href="#%e4%bf%a1%e5%8f%b7%e9%87%8f%e8%83%bd%e4%bf%9d%e8%af%81%e7%ba%bf%e7%a8%8b%e5%90%8c%e6%ad%a5%e5%90%97" aria-label="信号量能保证线程同步吗？">信号量能保证线程同步吗？</a></li>
                <li>
                    <a href="#linux%e4%b8%8b%e9%80%92%e5%bd%92%e5%88%a0%e9%99%a4%e6%9f%90%e4%b8%aa%e7%9b%ae%e5%bd%95%e4%b8%8b%e4%bb%a5cpp%e4%b8%ba%e7%bb%93%e5%b0%be%e7%9a%84%e6%96%87%e4%bb%b6" aria-label="linux下递归删除某个目录下以cpp为结尾的文件">linux下递归删除某个目录下以cpp为结尾的文件</a></li>
                <li>
                    <a href="#%e6%ad%bb%e9%94%81%e7%9a%84%e5%9b%9b%e4%b8%aa%e6%9d%a1%e4%bb%b6" aria-label="死锁的四个条件">死锁的四个条件</a></li>
                <li>
                    <a href="#%e5%86%85%e6%a0%b8%e6%80%81%e5%92%8c%e7%94%a8%e6%88%b7%e6%80%81" aria-label="内核态和用户态">内核态和用户态</a></li>
                <li>
                    <a href="#linux%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4" aria-label="linux常用命令">linux常用命令</a></li>
                <li>
                    <a href="#linux%e4%b8%ad%e6%9f%a5%e8%af%a2%e8%bf%9b%e7%a8%8b%e5%8d%a0%e7%94%a8cpu%e7%9a%84%e6%83%85%e5%86%b5" aria-label="linux中查询进程占用cpu的情况">linux中查询进程占用cpu的情况</a></li>
                <li>
                    <a href="#0%e6%8b%b7%e8%b4%9d" aria-label="0拷贝">0拷贝</a></li>
                <li>
                    <a href="#%e9%a1%b5%e8%b0%83%e5%ba%a6%e7%bd%ae%e6%8d%a2%e7%ae%97%e6%b3%95" aria-label="页调度/置换算法">页调度/置换算法</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e4%bc%98%e5%8c%96%e7%94%9f%e4%ba%a7%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85%e6%a8%a1%e5%9e%8b" aria-label="如何优化生产者消费者模型">如何优化生产者消费者模型</a></li>
                <li>
                    <a href="#dma%e6%8a%80%e6%9c%afpage-cache" aria-label="DMA技术（page cache）">DMA技术（page cache）</a></li>
                <li>
                    <a href="#%e5%88%86%e6%ae%b5%e5%92%8c%e5%88%86%e9%a1%b5" aria-label="分段和分页">分段和分页</a><ul>
                        
                <li>
                    <a href="#%e5%88%86%e6%ae%b5" aria-label="分段">分段</a></li>
                <li>
                    <a href="#%e5%88%86%e9%a1%b5" aria-label="分页">分页</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e4%bc%98%e5%8c%96%e8%af%bb" aria-label="如何优化读">如何优化读</a></li>
                <li>
                    <a href="#%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98" aria-label="虚拟内存">虚拟内存</a></li>
                <li>
                    <a href="#kill--9-%e5%92%8ckill--15%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="kill -9 和kill -15的区别？">kill -9 和kill -15的区别？</a></li>
                <li>
                    <a href="#%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b%e5%92%8c%e5%ad%a4%e5%84%bf%e8%bf%9b%e7%a8%8b" aria-label="僵尸进程和孤儿进程">僵尸进程和孤儿进程</a></li>
                <li>
                    <a href="#%e8%87%aa%e6%97%8b%e9%94%81%e5%92%8c%e4%ba%92%e6%96%a5%e9%94%81" aria-label="自旋锁和互斥锁">自旋锁和互斥锁</a></li>
                <li>
                    <a href="#sed%e5%92%8cawk%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="sed和awk的区别">sed和awk的区别</a>
                </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        if (elements) {
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                    (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                    return element;
                }
            }) || activeElement

            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                if (element === activeElement){
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
                } else {
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
                }
            })
        }
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        <div class="post-content"><h1 id="进程和线程区别">进程和线程区别<a hidden class="anchor" aria-hidden="true" href="#进程和线程区别">#</a></h1>
<p>1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序</p>
<p>2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。线程启动速度快，轻量级</p>
<p>进程的资源：</p>
<ul>
<li>独立的内存空间（虚拟地址空间）</li>
<li>系统资源，如打开的文件、信号处理器等</li>
</ul>
<p>线程的资源:</p>
<ul>
<li>程序计数器：用于指令读取，函数调用，指令跳转</li>
<li>寄存器：用于保存线程的上下文信息。</li>
<li>栈</li>
</ul>
<h1 id="协程">协程<a hidden class="anchor" aria-hidden="true" href="#协程">#</a></h1>
<p>协程是用户态的轻量级线程，线程内部调度的基本单位，都是运行在用户态，拥有自己的寄存器上下文和栈
c++的协程库: boost coroutine, libco</p>
<ul>
<li>线程由操作系统管理，切换需要操作系统内核，耗费时间和资源，协程切换是程序员自己控制</li>
<li>线程之间通信通过共享内存或者传递消息，而协程之间直接通过函数调用或者共享变量</li>
<li>线程可以通过多个cpu实现并行，但是协程只在一个线程中</li>
<li>线程创建、销毁需要操作系统接入，而协程在用户空间内完成</li>
<li>协程适用于 高并的网络编程，异步io操作，高并发网络编程，**短时间的计算密集型，**线程：cpu密集型</li>
</ul>
<h1 id="多个线程情况下cpu利用率不高">多个线程情况下CPU利用率不高<a hidden class="anchor" aria-hidden="true" href="#多个线程情况下cpu利用率不高">#</a></h1>
<p>1、同步和通信不高效(死锁，数据竞争)</p>
<p>2、线程过多：竞争过于激烈； 线程数过少：CPU核心限制</p>
<p>3、io密集型</p>
<h1 id="epoll的底层实现">epoll的底层实现<a hidden class="anchor" aria-hidden="true" href="#epoll的底层实现">#</a></h1>
<p>红黑树用来管理所有的文件描述符</p>
<p>内核中的事件表：存储所有就绪的文件描述符</p>
<p>内核中的回调函数：内核调用回调函数处理处理所有就绪的文件描述符
同步模型的优点：</p>
<h1 id="同步io和异步io的优缺点">同步io和异步io的优缺点<a hidden class="anchor" aria-hidden="true" href="#同步io和异步io的优缺点">#</a></h1>
<p>同步io优点：</p>
<ul>
<li>编程简单</li>
<li>可靠性高（阻塞）</li>
</ul>
<p>同步模型的缺点：</p>
<ul>
<li>性能低（阻塞）
异步模型的优点：</li>
<li>高性能</li>
<li>编程复杂</li>
</ul>
<p>异步模型的缺点：</p>
<ul>
<li>可靠性低（可能会出现操作未完成就返回结果，需要判断错误）</li>
</ul>
<h1 id="互斥锁读写锁自旋锁">互斥锁、读写锁、自旋锁<a hidden class="anchor" aria-hidden="true" href="#互斥锁读写锁自旋锁">#</a></h1>
<p>互斥锁，最基本的同步机制，保护临界区资源访问</p>
<p>读写锁，允许多个线程同时读共享资源，但是只允许一个锁读取共享资源，读写锁的实现通常是基于互斥锁和条件变量实现的。</p>
<p>自旋锁是一种轻量级同步机制，当自旋锁被占用时，线程不会进入阻塞状态，而是一直循环等待，适用于锁占用短的场景，锁占用长的</p>
<h1 id="加锁的方式">加锁的方式<a hidden class="anchor" aria-hidden="true" href="#加锁的方式">#</a></h1>
<ul>
<li>阻塞锁，一直等待资源</li>
<li>自旋锁，一直循环等待</li>
<li>乐观锁，假设读取共享资源的时候不会修改它，如果被修改了，就重新尝试</li>
</ul>
<h1 id="信号量能保证线程同步吗">信号量能保证线程同步吗？<a hidden class="anchor" aria-hidden="true" href="#信号量能保证线程同步吗">#</a></h1>
<p>信号量可以用来保证线程同步，但最好与锁一起使用来保证线程互斥。信号量是一种计数器，用来保护共享资源。当一个线程想要访问共享资源时，它必须先获取信号量，然后才能访问共享资源。如果信号量的计数器为0，则线程必须等待，直到有另一个线程释放信号量。这样可以确保多个线程不会同时访问共享资源，从而保证线程同步。</p>
<p>在使用信号量时，需要注意一些问题。首先，<strong>信号量只能保证线程同步，不能保证线程互斥</strong>。如果多个线程都可以获得信号量，则它们可以同时访问共享资源。因此，最好与锁一起使用来保证线程互斥。其次，信号量可能会产生死锁问题。当多个线程互相等待对方释放信号量时，就会发生死锁。因此，在使用信号量时，需要仔细考虑并发情况，以确保线程安全和性能。</p>
<h1 id="linux下递归删除某个目录下以cpp为结尾的文件">linux下递归删除某个目录下以cpp为结尾的文件<a hidden class="anchor" aria-hidden="true" href="#linux下递归删除某个目录下以cpp为结尾的文件">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>find /path/to/dir -name <span style="color:#e6db74">&#34;*.cpp&#34;</span> -type f -delete
</span></span></code></pre></div><p>如果不加 -type f，find 命令会查找目录中的所有类型的文件，包括普通文件、目录、符号链接等，可能会误删一些非文件类型的内容。加上 -type f 可以限定只查找普通文件，避免误删其他类型的内容。</p>
<h1 id="死锁的四个条件">死锁的四个条件<a hidden class="anchor" aria-hidden="true" href="#死锁的四个条件">#</a></h1>
<ol>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p>如果一个系统中存在上述四个条件，就会出现死锁的情况，死锁的解决方法通常需要采用多种方法，如锁机制的优化、资源分配算法的改进等。</p>
<h1 id="内核态和用户态">内核态和用户态<a hidden class="anchor" aria-hidden="true" href="#内核态和用户态">#</a></h1>
<p>用户态和内核态是计算机操作系统中的两种不同的运行模式。</p>
<p>用户态是指进程在执行普通用户程序时所处的运行模式。在用户态下，进程只能访问有限的资源，</p>
<p>内核态是指操作系统运行在特权级别最高的运行模式。在内核态下，操作系统可以直接访问所有系统资源，如CPU、内存、硬件设备和其他进程的内存空间等。</p>
<p>当一个进程需要访问操作系统的核心代码或其他进程的内存空间时，它必须通过系统调用进入内核态。在进入内核态时，系统会将进程的状态保存起来，以便在系统调用完成后能够恢复原有的状态。当操作完成后，进程会被切换回用户态，继续执行普通用户程序。</p>
<p>用户态和内核态的切换会带来一定的开销，因此操作系统需要尽可能地减少这种切换的次数。</p>
<h1 id="linux常用命令">linux常用命令<a hidden class="anchor" aria-hidden="true" href="#linux常用命令">#</a></h1>
<p>下面列举一些常用的Linux命令：</p>
<ol>
<li>ls：列出目录下的文件和子目录。</li>
<li>cd：切换当前目录。</li>
<li>pwd：显示当前所在目录的路径。</li>
<li>mkdir：创建一个新目录。</li>
<li>rmdir：删除一个空目录。</li>
<li>rm：删除文件或目录。</li>
<li>cp：复制文件或目录。</li>
<li>mv：移动或重命名文件或目录。</li>
<li>cat：查看文件内容。</li>
<li>grep：在文件或输入流中查找匹配的文本。</li>
<li>tail：查看文件的末尾内容。</li>
<li>head：查看文件的开头内容。</li>
<li>find：在指定目录下查找文件。</li>
<li>chmod：修改文件或目录的权限。</li>
<li>chown：修改文件或目录的所有者。</li>
<li>ps：查看当前系统进程。</li>
<li>top：查看当前系统资源占用情况。</li>
<li>tar：打包和解压缩文件。</li>
<li>ssh：远程登录到另一台计算机。</li>
<li>scp：在本地和远程计算机之间复制文件。</li>
<li>df：查看磁盘空间使用情况。</li>
<li>free：查看系统内存使用情况。</li>
<li>uname：查看系统信息。</li>
<li>ifconfig：查看网络接口信息。</li>
<li>ping：测试网络连接。</li>
<li>traceroute：查看网络路由情况。</li>
<li>netstat：显示网络连接、路由表和网络接口等信息。</li>
<li>iptables：管理系统防火墙规则。</li>
<li>systemctl：管理系统服务。</li>
<li>ps aux：显示所有进程的详细信息。</li>
<li>kill：终止指定进程。</li>
<li>nohup：让进程在后台运行。</li>
<li>screen：在一个终端窗口中打开多个终端会话。</li>
<li>wget：下载文件。</li>
<li>curl：向服务器发送请求并显示响应。</li>
<li>tar：压缩和解压缩文件。</li>
<li>gzip：压缩和解压缩文件。</li>
<li>zip：压缩和解压缩文件。</li>
<li>ssh-keygen：生成SSH密钥对。</li>
</ol>
<h1 id="linux中查询进程占用cpu的情况">linux中查询进程占用cpu的情况<a hidden class="anchor" aria-hidden="true" href="#linux中查询进程占用cpu的情况">#</a></h1>
<p>在Linux系统中，可以使用 top 命令来查看系统中占用CPU最多的进程，具体操作如下：</p>
<p>打开终端并输入 top 命令。
top 命令会实时显示系统资源使用情况，包括CPU、内存、进程等。在进程列表中，可以看到各个进程的CPU使用情况以及其他相关信息。
进程列表默认按照CPU使用率排序，可以通过按下“P”键，然后再按下“Enter”键，将进程列表按照CPU使用率从高到低排序。</p>
<p>打开终端并输入 ps aux 命令。
ps 命令会列出当前系统中所有的进程，包括进程的PID、CPU占用率、内存使用情况等。
若要按照CPU使用率排序，可以使用 ps aux &ndash;sort=-%cpu 命令。</p>
<h1 id="0拷贝">0拷贝<a hidden class="anchor" aria-hidden="true" href="#0拷贝">#</a></h1>
<p><a href="https://www.cnblogs.com/xiaolincoding/p/13719610.html">https://www.cnblogs.com/xiaolincoding/p/13719610.html</a>
普通拷贝
<img loading="lazy" src="/upload/2023/04/image-1680768304849.png" alt="image-1680768304849"  />

内存映射 mmap
<img loading="lazy" src="/upload/2023/04/image-1680768349477.png" alt="image-1680768349477"  />

sendfile
<img loading="lazy" src="/upload/2023/04/image-1680768397638.png" alt="image-1680768397638"  />
</p>
<p>零拷贝（Zero Copy）是一种提高数据传输效率和性能的技术，其基本思想是在数据传输过程中减少数据拷贝和内存复制操作，从而减少CPU的开销和系统资源的占用，提高数据传输的效率和性能。</p>
<p>在传统的数据传输方式中，数据通常需要从应用程序的缓冲区复制到内核空间的缓冲区，然后再从内核空间的缓冲区复制到网络设备的缓冲区，最后再从网络设备的缓冲区复制到目标主机的内核空间缓冲区，最后再从目标主机的内核空间缓冲区复制到目标应用程序的缓冲区。这样的数据传输方式需要经过多次数据拷贝和内存复制操作，耗费大量的CPU时间和系统资源，降低了数据传输的效率和性能。</p>
<p>零拷贝技术可以通过使用DMA（Direct Memory Access）技术和共享内存等技术，将数据从应用程序的缓冲区直接传输到网络设备的缓冲区，从而避免了数据拷贝和内存复制操作。这样就可以大大减少CPU的开销和系统资源的占用，提高数据传输的效率和性能。</p>
<p>在使用零拷贝技术时，需要注意以下几点：</p>
<ol>
<li>零拷贝技术需要硬件和操作系统的支持，不是所有的硬件和操作系统都支持零拷贝技术。</li>
<li>零拷贝技术需要应用程序和网络设备之间的协作，需要对数据传输进行特殊处理。</li>
<li>零拷贝技术可能会增加代码的复杂度和难度，需要谨慎使用。</li>
</ol>
<p>总之，零拷贝技术可以提高数据传输的效率和性能，但需要硬件和操作系统的支持，并且需要谨慎使用。</p>
<h1 id="页调度置换算法">页调度/置换算法<a hidden class="anchor" aria-hidden="true" href="#页调度置换算法">#</a></h1>
<p>页调度（Page Replacement）是操作系统中的一个重要概念，用于管理内存中的虚拟页（Virtual Page），当内存中的页框（Page Frame）不足时，需要将某些页从内存中换出（Swap Out），并将新的页换入（Swap In），以便为新的进程或线程腾出空间。</p>
<p>页调度算法的主要目标是最大化内存的利用率，同时尽可能地减少缺页中断（Page Fault）的次数，从而提高系统的性能。常见的页调度算法包括以下几种：</p>
<ol>
<li>
<p>先进先出（First-In-First-Out，FIFO）：按照进入内存的时间顺序，将最先进入内存的页换出，以腾出空间给新的页。这种算法简单、易于实现，但是容易产生“抖动”（Thrashing）现象，即不断地发生缺页中断和页调度操作，导致系统性能下降。</p>
</li>
<li>
<p>最近最少使用（Least Recently Used，LRU）：根据页的访问时间，将最近最久未被使用的页换出，以腾出空间给新的页。这种算法可以有效地减少缺页中断的次数，但是实现较为复杂，需要对每个页的访问时间进行记录。</p>
</li>
<li>
<p>最不经常使用（Least Frequently Used，LFU）：根据页的访问次数，将最不经常使用的页换出，以腾出空间给新的页。这种算法可以有效地减少缺页中断的次数，但是容易受到访问模式的影响，如果某个页在短时间内被访问多次，可能会被错误地保留在内存中。</p>
</li>
<li>
<p>时钟（Clock）：将页框按照时钟指针的顺序进行循环扫描，找到最早未被使用的页框，将其中的页换出，以腾出空间给新的页。这种算法可以有效地减少缺页中断的次数，但是可能会产生“抖动”现象。</p>
</li>
<li>
<p>最优（Optimal）：根据未来的访问情况，找到未来最长时间内不会被访问的页，将其中的页换出，以腾出空间给新的页。这种算法可以最小化缺页中断的次数，但是需要对未来的访问情况进行预测，实现较为困难。</p>
</li>
</ol>
<p>总之，页调度算法是操作系统中内存管理的重要组成部分，不同的页调度算法具有不同的特点和优缺点，需要根据具体的应用场景进行选择。</p>
<h1 id="如何优化生产者消费者模型">如何优化生产者消费者模型<a hidden class="anchor" aria-hidden="true" href="#如何优化生产者消费者模型">#</a></h1>
<p>生产者消费者模型是一种常见的并发编程模型，它包括生产者线程和消费者线程两部分。生产者线程负责生产数据并将数据存储到缓冲区中，消费者线程负责从缓冲区中取数据并进行处理。为了提高生产者消费者模型的效率，可以考虑以下几个方面：</p>
<ol>
<li>使用无锁数据结构</li>
</ol>
<p>在生产者消费者模型中，缓冲区是生产者和消费者之间的关键数据结构。如果使用锁来保护缓冲区，会导致线程间的竞争和等待，从而降低系统的并发性能。因此，可以考虑使用无锁数据结构来实现缓冲区，例如无锁队列、无锁循环缓冲区等。无锁数据结构可以避免线程间的竞争和等待，从而提高系统的并发性能。</p>
<ol start="2">
<li>使用多个缓冲区</li>
</ol>
<p>为了减少线程间的竞争，可以使用多个缓冲区来分散生产者和消费者之间的压力。例如，可以使用多个队列来存储生产者生产的数据，消费者从其中选择一个队列来消费数据。这样可以减少线程间的竞争和等待，从而提高系统的并发性能。</p>
<ol start="3">
<li>使用信号量</li>
</ol>
<p>信号量是一种常见的同步原语，可以用来解决生产者消费者模型中的同步问题。可以使用两个信号量来实现生产者消费者模型：一个信号量表示缓冲区中可用的槽位数量，另一个信号量表示缓冲区中已经存储的数据数量。生产者在生产数据之前需要获取可用槽位数量的信号量，消费者在消费数据之前需要获取已经存储的数据数量的信号量。这样可以保证生产者和消费者之间的同步，避免了线程间的竞争和等待，从而提高系统的并发性能。</p>
<ol start="4">
<li>优化线程池</li>
</ol>
<p>在生产者消费者模型中，线程池是扮演着重要角色的。为了提高生产者消费者模型的效率，可以考虑优化线程池的实现。例如，可以使用线程池来管理生产者和消费者线程，避免线程的频繁创建和销毁。同时，可以考虑使用线程池来实现任务的调度和负载均衡，从而提高系统的并发性能。</p>
<p>总之，提高生产者消费者模型的效率需要从多个方面入手，包括使用无锁数据结构、使用多个缓冲区、使用信号量、优化线程池等。针对具体的应用场景，需要根据实际情况进行选择和优化。</p>
<h1 id="dma技术page-cache">DMA技术（page cache）<a hidden class="anchor" aria-hidden="true" href="#dma技术page-cache">#</a></h1>
<p>DMA技术（Direct Memory Access，直接内存存取）是一种计算机数据传输技术，可以在不经过CPU的干预下直接将数据从外部设备传输到内存或从内存传输到外部设备。</p>
<p>在传统的计算机数据传输过程中，CPU需要占用大量时间来处理数据的传输，这就会导致CPU效率低下。而DMA技术的出现，可以允许设备直接访问系统内存，从而避免了CPU在数据传输过程中的干扰，提高了数据传输效率。</p>
<p>DMA技术通常用于高速数据传输，例如硬盘驱动器、网卡、音频设备和视频设备等。它可以显著提高计算机的数据传输速度，并且降低了CPU的负载。</p>
<h1 id="分段和分页">分段和分页<a hidden class="anchor" aria-hidden="true" href="#分段和分页">#</a></h1>
<h2 id="分段">分段<a hidden class="anchor" aria-hidden="true" href="#分段">#</a></h2>
<p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。
通过段号和偏移量确定物理地址
不足之处：</p>
<ul>
<li>内存碎片的问题（外部内存）。</li>
<li>内存交换的效率低。</li>
</ul>
<h2 id="分页">分页<a hidden class="anchor" aria-hidden="true" href="#分页">#</a></h2>
<p>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</p>
<p>页表是存储在内存里的，<strong>内存管理单元 （MMU）</strong> 就做将虚拟内存地址转换成物理地址的工作。</p>
<ul>
<li>提高内存的利用率，没有外部碎片</li>
<li>但会产生内碎片（一个页可能填充不满）。</li>
</ul>
<p>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p>
<p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。</p>
<p>TLB,页表缓存</p>
<p><img loading="lazy" src="/upload/2023/04/image-1680939640665.png" alt="image-1680939640665"  />
</p>
<h1 id="如何优化读">如何优化读<a hidden class="anchor" aria-hidden="true" href="#如何优化读">#</a></h1>
<p>在多线程编程中，读请求是比较频繁的操作，如果读请求的性能不佳，可能会导致系统的整体性能下降。因此，对读请求的优化非常重要。</p>
<p>以下是一些优化读请求的常见方法：</p>
<ol>
<li>
<p>读写分离：读写分离是一种常见的优化读请求的方法，通过将读请求和写请求分别处理，可以避免读请求和写请求之间的竞争和互斥，从而提高系统的整体性能。在读写分离的模式下，读请求可以并行处理，而写请求需要独占资源，因此可以将读写分离的模式应用于高并发读请求的场景。</p>
</li>
<li>
<p>缓存：缓存是一种常见的优化读请求的方法，通过将频繁读取的数据缓存到内存中，可以避免每次读取都需要访问磁盘或者网络的开销，从而提高读请求的性能。在应用缓存的时候，需要注意缓存的一致性和更新策略，避免数据不一致的问题。</p>
</li>
</ol>
<ul>
<li></li>
</ul>
<ol start="3">
<li>
<p>预加载：预加载是一种优化读请求的方法，通过在应用启动时预先加载数据到内存中，可以避免后续读请求需要访问磁盘或者网络的开销，从而提高读请求的性能。在预加载的时候，需要根据具体业务场景选择合适的数据量和预加载策略。</p>
</li>
<li>
<p>数据分片：数据分片是一种优化读请求的方法，通过将数据分成多个片段，并将每个片段分布到不同的节点或者服务器上，可以并行处理读请求，从而提高读请求的性能。在应用数据分片的时候，需要注意数据的分布均衡和数据分片的策略，避免数据倾斜和数据不一致的问题。</p>
</li>
<li>
<p>数据压缩：数据压缩是一种优化读请求的方法，通过将数据压缩后存储到磁盘或者网络中，可以减少读取数据的大小，从而降低读请求的网络和磁盘开销，提高读请求的性能。在应用数据压缩的时候，需要注意压缩算法的选择和压缩效率的平衡，避免压缩和解压缩的开销过大的问题。</p>
</li>
</ol>
<p>总之，优化读请求的方法有很多种，需要根据具体的业务场景和需求选择合适的方法，从而提高系统的整体性能。</p>
<h1 id="虚拟内存">虚拟内存<a hidden class="anchor" aria-hidden="true" href="#虚拟内存">#</a></h1>
<p>虚拟内存是一种计算机内存管理技术，它允许操作系统将一个进程使用的内存分成多个部分，并且不需要把它们全部保存在物理内存中。操作系统会将一部分当前未使用的进程内存数据保存在硬盘上，以便释放出物理内存给其他进程使用。当进程需要访问被保存在硬盘上的数据时，操作系统会将它们再次读取到物理内存中，并且在需要时将其写回硬盘。这个过程是透明的，用户无需了解虚拟内存的存在。虚拟内存可以极大地提高计算机的性能，因为它允许进程使用比物理内存更多的内存，而不会导致系统崩溃或进程崩溃。</p>
<h1 id="kill--9-和kill--15的区别">kill -9 和kill -15的区别？<a hidden class="anchor" aria-hidden="true" href="#kill--9-和kill--15的区别">#</a></h1>
<p>kill命令用于发送信号给一个进程，让进程做出相应的操作，例如结束进程、重启进程等。</p>
<p>kill命令有很多选项，其中最常用的是kill -9和kill -15。它们的区别在于发送的信号不同，具体如下：</p>
<ul>
<li>
<p>kill -9：发送SIGKILL信号给进程，该信号是不能被捕获或忽略的，进程会被立即终止，而不会有任何机会去清理和释放资源。因此，使用kill -9命令经常被称为“强制杀死”进程，它可以保证进程一定被杀死，但可能会导致数据丢失或系统崩溃等问题。</p>
</li>
<li>
<p>kill -15：发送SIGTERM信号给进程，该信号是可以被捕获和处理的。进程收到SIGTERM信号后，会先尝试清理和释放资源，然后再终止进程。因此，使用kill -15命令可以安全地关闭进程，让进程有机会去清理资源，但并不保证一定能成功终止进程，因为进程可能会忽略或拒绝处理SIGTERM信号。</p>
</li>
</ul>
<p>综上所述，一般情况下，建议使用kill -15命令来结束进程，这样可以让进程有机会去做一些清理工作，并尽可能地避免数据丢失和系统崩溃等问题。但在某些情况下，如进程无法响应信号或出现死锁等问题时，可能需要使用kill -9命令来强制杀死进程。</p>
<h1 id="僵尸进程和孤儿进程">僵尸进程和孤儿进程<a hidden class="anchor" aria-hidden="true" href="#僵尸进程和孤儿进程">#</a></h1>
<p>僵尸进程和孤儿进程都是进程的一种状态。</p>
<p>僵尸进程（Zombie Process）是指一个已经完成执行但其父进程尚未调用wait()或waitpid()系统调用来获取其终止状态的进程。在这种情况下，进程的进程控制块（Process Control Block，PCB）仍然存在于系统中，但进程的其他资源（如内存、文件描述符等）已经被释放。僵尸进程不会再消耗系统资源，但如果它们数量过多，可能会影响系统性能。</p>
<p>孤儿进程（Orphan Process）是指其父进程已经终止或不存在，但该进程仍然在运行。孤儿进程会被init进程接管，init进程会成为孤儿进程的新父进程，通过这种方式来保证孤儿进程能够正常终止。</p>
<p>杀死僵尸进程的方法如下：</p>
<p>使用kill命令向僵尸进程的父进程发送SIGCHLD信号，让父进程调用wait()或waitpid()系统调用来获取僵尸进程的终止状态并释放其PCB。</p>
<p>手动杀死僵尸进程的父进程，这样僵尸进程就会成为孤儿进程，并被init进程接管。</p>
<p>使用编程方式处理僵尸进程，即在父进程中捕获SIGCHLD信号，并在信号处理函数中调用wait()或waitpid()系统调用来获取僵尸进程的终止状态并释放其PCB。</p>
<p>总之，为了避免出现僵尸进程和孤儿进程，编写程序时需要注意及时调用wait()或waitpid()系统调用来获取子进程的终止状态，并在必要时向子进程发送信号来终止它们的执行。</p>
<h1 id="自旋锁和互斥锁">自旋锁和互斥锁<a hidden class="anchor" aria-hidden="true" href="#自旋锁和互斥锁">#</a></h1>
<p>互斥锁是一种基于线程阻塞的同步机制，当一个线程占用了互斥锁时，其他线程必须等待该线程释放锁才能继续执行。互斥锁使用操作系统提供的系统调用实现，需要在用户态和内核态之间进行多次上下文切换，因此效率较低。互斥锁适用于在共享资源访问时需要长时间等待的情况。</p>
<p>自旋锁的基本思想是在获取锁之前，不断地<strong>忙等待</strong>直到获取到锁为止。
自旋锁适用于以下情况：</p>
<ul>
<li>共享资源的访问时间非常短暂，线程不希望进入睡眠状态造成额外的开销。</li>
<li>线程调度开销较大，上下文切换会带来较高的性能开销。</li>
<li>线程持有锁的时间非常短暂，不会引起太多的竞争。</li>
</ul>
<h1 id="sed和awk的区别">sed和awk的区别<a hidden class="anchor" aria-hidden="true" href="#sed和awk的区别">#</a></h1>
<p>awk主要用于提取和分析数据,分析需要的列和行,计算列的和等等。它适合用于处理大型文件的分析工作。</p>
<p>sed主要用于进行行内搜索和替换,删除或插入行等简单的文本转换操作。它更适合用于小型文件的简单修改。</p>


        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://chx9.github.io/en/posts/cs/mysql/">
    <span class="title">« 上一页</span>
    <br>
    <span>Mysql</span>
  </a>
  <a class="next" href="https://chx9.github.io/en/posts/cs/leetcode/">
    <span class="title">下一页 »</span>
    <br>
    <span>Leetcode</span>
  </a>
</nav>

        </footer>
    </div>

<style>
    .comments_details summary::marker {
        font-size: 20px;
        content: '👉展开评论';
        color: var(--content);
    }
    .comments_details[open] summary::marker{
        font-size: 20px;
        content: '👇关闭评论';
        color: var(--content);
    }
</style>


<div>
    <details class="comments_details">
        <summary style="cursor: pointer; margin: 50px 0 20px 0;width: 130px;">
            <span style="font-size: 20px;color: var(--content);">...</span>
        </summary>
        <div id="tcomment"></div>
    </details>
    <script src="https://cdn.staticfile.org/twikoo//twikoo.all.min.js">
    </script>
    <script>
        twikoo.init({
            envId:  null ,
        el: "#tcomment",
            lang: 'zh-CN',
            region:  null ,
        path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
        })
    </script>
</div>
</article>
</main>

<footer class="footer">
    <span>
        Copyright
        &copy;
        -2023
        <a href="https://chx9.github.io/en/" style="color:#939393;">chx9</a>
        All Rights Reserved
    </span>
    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;"></a>&nbsp;
    <span>
        <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null"
           style="display:inline-block;text-decoration:none;height:20px;color:#939393;">
            <img src="" style="float:left;margin: 0px 5px 0px 0px;"/>
            
        </a>
    </span>
    <span id="busuanzi_container">
        <span class="fa fa-user"></span> <span id="busuanzi_value_site_uv"></span>
        <span class="fa fa-eye"></span> <span id="busuanzi_value_site_pv"></span>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
</script>
<script>
    let mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        (function() {
            document.cookie = "change-themes" + "="+ escape ("false");
        })()

        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    });
</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() 
                let textData = window.getSelection().toString() 
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
                
                
                
                
                
                
                
                
                
                
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;
        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '📄复制';

        function copyingDone() {
            copybutton.innerText = '👌🏻已复制!';
            setTimeout(() => {
                copybutton.innerText = '📄复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent 
                
                
                
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {}
            selection.removeRange(range);
        });

        let language = codeblock.className.replaceAll("language-", "")
        let macTool = document.createElement("div")
        let macTool1 = document.createElement("div")
        let macTool2 = document.createElement("div")
        let macTool3 = document.createElement("div")
        let languageType = document.createElement("div")
        languageType.innerText = language
        
        
        
        
        languageType.setAttribute('class', 'language-type')
        macTool.appendChild(macTool1)
        macTool.appendChild(macTool2)
        macTool.appendChild(macTool3)
        macTool.appendChild(languageType)

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
            container.appendChild(macTool)
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        }
    });
</script>
</body>

</html>
