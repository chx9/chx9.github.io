<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Network | chx9</title>
<meta name="keywords" content="">
<meta name="description" content="三次握手过程 四次挥手过程 为什么 TCP 要三次握手？ 最主要原因就是防止「历史连接」初始化了连接。 三次握手才可以同步双方的初始序列号 为什么 TCP 要四次挥手 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可">
<meta name="author" content="chx9">
<link rel="canonical" href="https://chx9.github.io/en/posts/cs/network/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://chx9.github.io/img/svin.webp">
<link rel="icon" type="image/png" sizes="16x16" href="https://chx9.github.io/img/svin.webp">
<link rel="icon" type="image/png" sizes="32x32" href="https://chx9.github.io/img/svin.webp">
<link rel="apple-touch-icon" href="https://chx9.github.io/img/svin.webp">
<link rel="mask-icon" href="https://chx9.github.io/img/svin.webp">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script defer src="https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="Network" />
<meta property="og:description" content="三次握手过程 四次挥手过程 为什么 TCP 要三次握手？ 最主要原因就是防止「历史连接」初始化了连接。 三次握手才可以同步双方的初始序列号 为什么 TCP 要四次挥手 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chx9.github.io/en/posts/cs/network/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-29T11:04:35+08:00" />
<meta property="article:modified_time" content="2023-07-29T11:04:35+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Network"/>
<meta name="twitter:description" content="三次握手过程 四次挥手过程 为什么 TCP 要三次握手？ 最主要原因就是防止「历史连接」初始化了连接。 三次握手才可以同步双方的初始序列号 为什么 TCP 要四次挥手 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [

        {
          "@type": "ListItem",
          "position":  1 ,
          "name": "📚Articles",
          "item": "https://chx9.github.io/en/posts/"
        },

        {
          "@type": "ListItem",
          "position":  2 ,
          "name": "💻 Programming Basics",
          "item": "https://chx9.github.io/en/posts/cs/"
        }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Network",
      "item": "https://chx9.github.io/en/posts/cs/network/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Network",
  "name": "Network",
  "description": "三次握手过程 四次挥手过程 为什么 TCP 要三次握手？ 最主要原因就是防止「历史连接」初始化了连接。 三次握手才可以同步双方的初始序列号 为什么 TCP 要四次挥手 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可",
  "keywords": [
    ""
  ],
  "articleBody": "三次握手过程 四次挥手过程 为什么 TCP 要三次握手？ 最主要原因就是防止「历史连接」初始化了连接。 三次握手才可以同步双方的初始序列号 为什么 TCP 要四次挥手 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。 TCP 三次握手失败会发生什么 第一次握手失败 客户端重传 SYN 包，直到连接成功或者超时（每次等待两倍时间） 如果服务器无法响应，那么会发送 RST 包，表示拒绝连接 第二次握手失败 客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是客户端就会触发超时重传机制，重传 SYN 报文。 服务端这边会触发超时重传机制，重传 SYN-ACK 报文。 第三次握手失败 因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。 注意，ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文\n列举常用的 HTTP 状态码 HTTP 状态码是指在 HTTP 协议中，服务器向客户端返回的响应状态码。HTTP 状态码由三位数字组成，第一位数字表示响应类型，后两位数字没有具体分类作用。常见的 HTTP 状态码如下：\n1xx：信息响应类，表示服务器已接收到客户端的请求，需要进一步处理。 2xx：成功响应类，表示服务器已成功地接收到客户端的请求并返回响应结果。 3xx：重定向响应类，表示客户端需要进一步操作才能完成请求，如重定向到其他 URL。 4xx：客户端错误响应类，表示客户端请求存在错误或无法被服务器处理。 5xx：服务器错误响应类，表示服务器在处理请求时出现了错误或异常。 以下是常见的 HTTP 状态码及其含义：\n200 OK：表示请求被成功处理，并返回响应结果。 301 Moved Permanently：表示请求的资源已经被永久移动到新的位置，客户端需要使用新的 URL。 302 Found：表示请求的资源已经被暂时移动到新的位置，客户端需要使用新的 URL，但是之后可能会恢复原来的位置。 304 Not Modified：表示客户端发送了一个条件请求，并且服务器认为客户端请求的资源没有被修改，因此不需要返回资源的实体内容，只需要返回响应头信息即可。 404 Not Found：表示请求的资源不存在或无法被找到。 500 Internal Server Error：表示服务器在处理请求时出现了未知的错误或异常。 除了上述常见的 HTTP 状态码，HTTP 协议中还有很多其他状态码，每个状态码都有其特定的含义和用途。在编写 Web 应用程序时，了解 HTTP 状态码的含义和使用方法，可以帮助我们更好地处理 HTTP 请求，提高程序的可靠性和稳定性。\nGET 和 POST 请求 GET 和 POST 是 HTTP 协议中最常用的两种请求方法，它们有以下区别：\n参数传递方式：GET 请求将参数以 URL 参数的形式传递，而 POST 请求将参数包含在请求体中传递。\n安全性：GET 请求的参数会被包含在 URL 中，因此可能会被浏览器缓存、历史记录、代理服务器等记录下来，并且容易被攻击者截取、篡改或者伪造。POST 请求的参数则不会被包含在 URL 中，相对来说更加安全。\n请求体大小限制：GET 请求对请求体大小没有限制，但是浏览器对 URL 长度有限制；POST 请求对请求体大小有限制，一般情况下不会超过 2MB。\n应用场景：GET 请求适合请求数据，如获取页面、搜索等操作；POST 请求适合提交数据，如提交表单、上传文件等操作。\nHTTP 和 HTTPS HTTP（Hypertext Transfer Protocol）和 HTTPS（Hypertext Transfer Protocol Secure）都是用于在 Web 上进行数据传输的协议，它们的主要区别在于安全性：\n安全性：HTTP 是明文传输协议，数据在传输过程中没有加密，容易被窃听和篡改；HTTPS 利用 SSL/TLS 协议进行数据加密和身份认证，可以保证数据传输的安全性。\n端口号：HTTP 使用的端口号为 80，而 HTTPS 使用的端口号为 443。\n证书：HTTPS 需要使用数字证书对网站进行身份验证，证书由受信任的第三方机构颁发，可以保证网站的真实性和安全性；而 HTTP 没有身份验证机制，无法保证网站的真实性和安全性。\n性能：HTTPS 比 HTTP 的性能要差一些，因为 HTTPS 需要进行加密和解密操作，会增加服务器和客户端的处理负担，导致响应速度变慢。\nhttp 加密过程 HTTPS（Hypertext Transfer Protocol Secure）是一个用于安全传输数据的协议，它使用 SSL（Secure Sockets Layer）或 TLS（Transport Layer Security）协议来加密 Web 通信。以下是 HTTPS 的加密过程：\n客户端发起 HTTPS 请求，请求连接到服务器。\n服务器向客户端发送一个证书，证书中包含了服务器的公钥、证书的有效期、证书颁发机构等信息。\n客户端收到证书后，会验证证书的有效性，包括证书是否过期、证书颁发机构是否可信等。如果证书有效，客户端会生成一个随机数，用于后续的加密通信。\n客户端使用服务器的公钥加密随机数，并将加密后的随机数发送给服务器。\n服务器使用自己的私钥解密客户端发来的随机数，并使用该随机数作为对称加密算法的密钥，用于后续的数据加密。\n服务器使用对称加密算法对数据进行加密，并将加密后的数据发送给客户端。\n客户端使用之前生成的随机数作为对称加密算法的密钥，解密服务器发来的数据，从而得到原始数据。\n以上就是 HTTPS 的加密过程，通过使用 SSL 或 TLS 协议，可以确保数据在传输过程中的机密性、完整性和真实性。\n输入网址到出现网页的全过程 输入网址到浏览器中，到收到网页的整个过程大致可以分为以下步骤：\nDNS 解析：浏览器首先会解析输入的网址中的域名，将其转换为对应的 IP 地址。浏览器会先查找本地 DNS 缓存，如果没有找到匹配的 IP 地址，则会向 DNS 服务器发送请求，获取对应域名的 IP 地址。\n建立 TCP 连接：浏览器向服务器发送 TCP 连接请求，建立 TCP 连接。在这个过程中，浏览器和服务器会通过三次握手协议建立连接。\n发送 HTTP 请求：浏览器向服务器发送 HTTP 请求，请求获取特定资源，比如 HTML、CSS、JavaScript、图片等。\n服务器响应：服务器接收到浏览器的 HTTP 请求后，会返回相应的资源内容以及 HTTP 状态码。\n浏览器渲染：当浏览器接收到服务器返回的资源内容后，会根据 HTML、CSS 和 JavaScript 等文件进行解析，生成 DOM 和 CSSOM 树，并将其合并成渲染树。然后浏览器会根据渲染树进行布局和绘制，最终将网页内容显示在用户界面上。\n在这个过程中，涉及到的协议主要有：\nDNS 协议：用于域名解析，将域名转换为对应的 IP 地址。\nTCP 协议：用于在浏览器和服务器之间建立可靠的连接，确保数据的可靠传输。\nHTTP 协议：用于在浏览器和服务器之间传输资源内容，包括 HTML、CSS、JavaScript、图片等。\nHTTPS 协议：用于在 HTTP 协议的基础上添加 SSL/TLS 协议进行加密通信，提高数据传输的安全性。\nTCP 拥塞控制 b 站视频\n小林 coding\n拥塞控制是一种网络流量控制机制，它通过限制数据流的速度来防止网络拥塞和保持网络的稳定性。拥塞控制的几个常见机制包括：\n慢启动：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。相当于 2 的指数倍增长 。\n拥塞避免：每当收到一个 ACK 时，cwnd 增加 1/cwnd，变成了线性增长。\n快速重传：当发送方发现某个数据包没有收到确认时，它会重传该数据包。然而，如果发送方连续发送了多个数据包而没有收到确认，它会认为网络出现了拥塞，并立即减慢发送速率。幸运的是，由于 TCP 采用的是累计确认机制，即当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余 ACK（duplicate ACK）。\n如图所示，报文段1成功接收并被确认ACK 2，接收端的期待序号为2，当报文段2丢失，报文段3失序到来，与接收端的期望不匹配，接收端重复发送冗余ACK 2。 这样，如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK（其实是收到4个同样的ACK，第一个是正常的，后三个才是冗余的），发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出，大大提高了效率。这便是快速重传机制。 4. 快速恢复：当发送方减慢发送速率时，接收方会通知发送方可以增加发送速率。这种机制称为快速恢复，它可以帮助发送方更快地恢复正常的发送速率，而不是像慢启动一样重新开始。\n正如前面所说，进入快速恢复之前，cwnd 和 ssthresh 已被更新了： cwnd = cwnd/2 ，也就是设置为原来的一半; ssthresh = cwnd; 然后，进入快速恢复算法如下： 拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）； 重传丢失的数据包； 如果再收到重复的 ACK，那么 cwnd 增加 1； 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态； 流量控制和拥塞控制分别解决了什么问题 流量控制是防止接收端被发送端的数据包淹没，确保接收端处理得过来。\n拥塞控制是避免网络中的数据包太多，导致网络资源如路由器、链路等过载\nhttp 长连接和短连接区别 长连接（Long Connection）\n长连接在数据的传输结束后，仍然保持连接状态，可重复使用，直到客户端或服务器主动关闭。\n场景：实时应用（如在线聊天、即时通讯）、数据库连接、HTTP/2 中的服务。 短连接（Short Connection）\n短连接发送请求后，得到服务器响应就立刻断开。\n场景：HTTP/1.0 协议、邮件发送/接收、FTP 文件传输。\n哪些用 UDP 哪些用 TCP 应用层协议可以使用 TCP 或 UDP 进行数据传输，具体使用哪种传输协议，需要根据协议的特性和应用场景进行选择。下面是一些常见的应用层协议及其使用的传输协议：\n使用 TCP 传输的应用层协议：\nHTTP 协议：用于 Web 应用程序的数据传输。\nFTP 协议：用于文件传输，支持文件上传和下载等操作。\nSMTP 协议：用于电子邮件的传输。\nSSH 协议：用于安全远程登录和文件传输。\nTelnet 协议：用于远程登录主机进行命令行操作。\n使用 UDP 传输的应用层协议：\nDNS 协议：用于域名解析，将域名转换为 IP 地址。\nDHCP 协议：用于动态 IP 地址分配，自动分配和管理 IP 地址。\nTFTP 协议：用于简单文件传输，支持无连接传输方式。\nSNMP 协议：用于网络管理和监控，实现对网络设备的远程管理。\nRTP 协议：用于音视频数据的传输，支持实时传输和流媒体播放。\n需要注意的是，有些应用层协议同时支持 TCP 和 UDP 传输，如 DNS 协议和 FTP 协议等，可以根据实际情况进行选择。\nhttps ssl 连接的过程 HTTPS 加密过程简略如下：\n客户端发送 HTTPS 请求，请求头中的https字段设置为on。\n服务器返回数字证书，包含服务器的公钥、证书颁发机构的信息、证书有效期等。\n客户端验证证书合法性，确认无误后生成随机的会话密钥，并使用服务器的公钥将其加密后发送给服务器。\n服务器使用自己的私钥解密会话密钥，得到原始的会话密钥。\n双方使用会话密钥进行对称加密，保证通信过程中的数据安全性，并进行数字签名和身份认证，确保通信的可信性和完整性。\nhttp1.0 和 http1.1 和 http2.0 的差别，分别做了哪几点优化 HTTP 是一种应用层协议，常用于 Web 应用中，目前主要有 HTTP/1.0、HTTP/1.1 和 HTTP/2.0 三个版本。它们之间的主要差别及优化如下：\nHTTP/1.0 和 HTTP/1.1 的主要差别 HTTP 1.0\n单一请求响应模型，每个请求/响应都会断开连接。 HTTP 1.1\n持久连接：默认情况下，所有的连接都被认为是持久的，除非有明确的关闭。 管道化技术：在同一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了网络延迟。 增加更多的缓存控制策略。 支持内容协商，包括语言、编码等。 提供对资源的范围请求，方便实现文件的部分下载。 HTTP 2.0\n多路复用：单一 TCP 连接中可并行交换多个 HTTP 请求/响应。 首部压缩：对头信息进行压缩，减少数据传输量。 服务器推送：允许服务器未经客户端明确请求就发送数据到客户端，提高性能。\ntcp 粘包现象 TCP 粘包是因为 TCP 基于字节流，不保证消息边界\n解决 TCP 粘包现象的方法主要有以下几种：\n增加消息边界：在消息头部添加消息长度字段，接收方根据消息长度进行数据的切割。\n使用固定长度的消息：发送方将消息按照固定长度进行分割，接收方根据固定长度进行数据的切割。\n使用特殊字符作为消息分隔符：发送方在消息尾部添加特殊字符作为消息分隔符，接收方根据特殊字符进行数据的切割。\n使用应用层协议：在应用层协议中规定消息的格式和边界，从而避免粘包现象的发生。\nPOST 和 GET 请求 GET 和 POST 是 HTTP 协议中常用的两种请求方法，它们在数据传输、安全性、请求体大小等方面有所不同。\nGET 请求方法是用于从服务器获取数据的方法，该方法将请求参数附加在 URL 的末尾，以问号(?)的形式分隔 URL 和请求参数，多个请求参数之间以\u0026符号分隔。因此，GET 请求方法的请求体大小有限制，通常不超过 2KB。\nPOST 请求方法是用于向服务器提交数据的方法，该方法将请求参数放在请求体中，请求体的格式由 Content-Type 头部指定。因为 POST 请求方法将请求参数放在请求体中，所以请求体的大小没有限制，可以传输较大的数据。\nGET 和 POST 请求方法在安全性方面也有所不同。由于 GET 请求方法将请求参数附加在 URL 的末尾，所以请求参数会暴露在 URL 中，容易被中间人攻击截获和篡改。而 POST 请求方法将请求参数放在请求体中，相对安全一些。\n幂等性：GET 请求方法具有幂等性，即多次请求返回的结果相同，不会对服务器产生影响。而 POST 请求方法不具有幂等性，多次请求可能会产生不同的结果，对服务器产生影响。\n总之，GET 和 POST 请求方法在数据传输、安全性、请求体大小等方面有所不同。一般来说，GET 请求方法用于从服务器获取数据，POST 请求方法用于向服务器提交数据。当需要传输大量数据或者涉及到敏感数据时，建议使用 POST 请求方法。\ntcp 如何保证可靠 TCP（Transmission Control Protocol）是一种面向连接的、可靠的传输协议，它通过以下机制来保证数据传输的可靠性：\n序列号与确认应答机制：每个 TCP 报文段都有一个唯一的序列号和确认应答号，用于保证数据的顺序性和完整性。发送端将数据分成若干个报文段发送，每个报文段都有一个序列号，接收端收到报文段后需向发送端发送确认应答，确认应答号为接收到的数据的下一个期望的序列号。如果发送端接收到确认应答，就认为该报文段已经成功传输，可以将该报文段从发送缓冲区中删除。\n超时重传机制：发送端在发送数据时会启动一个定时器，如果在指定时间内没有收到接收端的确认应答，发送端会判断该报文段丢失了，需要重新发送。接收端收到重复的报文段时，会丢弃该报文段，同时向发送端发送确认应答。\n滑动窗口机制：TCP 使用滑动窗口机制来实现流量控制和拥塞控制。发送端和接收端都有一个窗口大小，用于限制发送和接收数据的速率。发送端发送数据时，需要等待接收端发送的确认应答，确认应答中包含接收端当前窗口的大小，发送端根据窗口大小来调整发送数据的速率。\n拥塞控制\n校验和：校验和（checksum）是一种用于检测数据传输过程中是否发生错误的技术。在数据传输过程中，可能会出现各种各样的错误，比如说数据损坏、数据重复、数据丢失等，这些错误都可能导致数据传输失败或者数据被篡改。校验和技术可以通过计算数据的校验和值来检测这些错误，从而保证数据传输的可靠性。\n通过以上机制，TCP 可以保证数据传输的可靠性，并且在网络出现拥塞时可以进行拥塞控制，避免网络拥塞导致数据丢失或传输延迟增加。\n滑动窗口 小林 coding\nping 的过程 主要是 icmp Ping 是一种常用的网络诊断工具，用于测试主机之间的连通性。当我们使用 Ping 命令时，Ping 程序会执行以下步骤：\n发送 ICMP Echo Request 消息：Ping 程序向目标主机发送一个 ICMP Echo Request 消息，该消息包含一个随机的标识符和序列号。\n接收 ICMP Echo Reply 消息：目标主机收到 ICMP Echo Request 消息后，会向发送方返回一个 ICMP Echo Reply 消息，该消息包含与 Echo Request 消息相同的标识符和序列号。\n计算往返时间（RTT）：Ping 程序在接收到 Echo Reply 消息后，会计算从发送 Echo Request 消息到接收 Echo Reply 消息所需的时间，即往返时间（RTT）。\n显示结果：Ping 程序将计算得到的 RTT 值和其他一些统计信息显示在屏幕上。如果目标主机无法到达，Ping 程序会返回一个错误消息。\n需要注意的是，Ping 命令使用的是 ICMP 协议，而不是 TCP 或 UDP 协议。因此，Ping 命令可以用于测试主机之间的连通性，但不能用于测试 TCP 或 UDP 服务的可用性。此外，由于 ICMP 消息可以被防火墙和路由器过滤，因此在某些情况下，Ping 命令可能无法正常工作。\nmac 寻址和 ip 寻址的差异 mac 寻址在数据链路层，ip 寻址在网络层\n数据链路层的作用 1、封装成帧 2、流量控制 3、差错控制 4、mac 寻址 5、透明传输\n网络层的作用 管理数据包的传输和路由选择，将数据包从源节点传输到目的节点。 实现IP（Internet Protocol）协议，负责数据包的分组、传输和路由选择。\n提供差错控制和流量控制功能，确保数据包传输的可靠性和效率。\n实现路由选择算法，根据网络拓扑结构和路由策略选择最佳的路径将数据包传输到目的节点。\n实现地址转换（NAT，Network Address Translation）等功能，将内部私有地址转换为公网可用的地址，以实现网络连接与安全性的需求。\n子网掩码 子网掩码（subnet mask）是用于划分网络地址和主机地址的一个 32 位数值，用于告诉网络设备哪些位是网络地址，哪些位是主机地址。子网掩码通常与 IP 地址配合使用，用于指示网络中哪些位是网络地址，哪些位是主机地址。\n子网掩码的作用是将一个 IP 地址分成两部分：网络地址和主机地址。网络地址用于标识网络，而主机地址用于标识特定的主机。\n子网掩码的格式通常是四个 8 位二进制数，例如 255.255.255.0。这个子网掩码表示前 24 位是网络地址，后 8 位是主机地址。这意味着，对于该子网掩码的网络，可以有 256 个主机地址（2 的 8 次方），因为最后 8 位可以有 256 种不同的组合。\n在计算机网络中，子网掩码有助于划分网络和管理 IP 地址。通过使用子网掩码，网络管理员可以将一个大的 IP 地址空间分成多个子网，以便更有效地管理网络。例如，一个大的 IP 地址空间可以划分为多个小的子网，每个子网可以被分配给不同的部门或办公室，以便更好地管理网络流量和安全。\nUDP 和 TCP 的区别，适用场景 TCP 适用于对数据传输的可靠性要求较高的场景，如文件传输（ftp）、电子邮件（stmp）、网页浏览（http）等；UDP 适用于对数据传输的可靠性要求较低、数据传输速度要求较高的场景，如在线游戏、实时音视频、DNS 等。\n为什么会出现大量的 close_wait 状态，如何解决 TIME_WAIT 状态是因为频繁地建立和关闭连接，或者连接关闭不规范等。\n解决办法：\n调整 TCP 参数如 TIME_WAIT 时间。 优化程序设计，比如使用连接池。 使用 SO_REUSEADDR 共用端口。 使用负载均衡器分摊连接负载。少 time_wait 状态的出现。 交换机位于哪一层 交换机位于数据链层，负责在同一网络下中转发数据帧。它能够根据目标 MAC 地址来决定数据帧的转发路径，以实现同一网络内的通信。 路由器是一种网络设备，主要用于在不同的网络之间转发数据包。\n五层网络中的各层协议有啥 DNS 过程 以下是 DNS 解析 www.example 的过程：\n当用户在浏览器中输入 www.example 时，浏览器会向本地 DNS 服务器发送 DNS 解析请求。\n如果本地 DNS 服务器缓存了该域名的解析信息，它将直接返回该域名的 IP 地址。否则，它将向根域名服务器发送请求。\n根域名服务器将返回.com 顶级域名服务器的地址。\n本地 DNS 服务器随后向.com 顶级域名服务器发送请求，并返回该域名的权威域名服务器地址。\n本地 DNS 服务器向该权威域名服务器发送请求，并返回该域名的 IP 地址。\n本地 DNS 服务器将该 IP 地址缓存起来，并将其返回给用户的计算机或设备。\n用户的计算机或设备使用该 IP 地址与该域名的服务器进行通信，以获取网站的内容。\n",
  "wordCount" : "7757",
  "inLanguage": "en",
  "datePublished": "2023-07-29T11:04:35+08:00",
  "dateModified": "2023-07-29T11:04:35+08:00",
  "author":[{
    "@type": "Person",
    "name": "chx9"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://chx9.github.io/en/posts/cs/network/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "chx9",
    "logo": {
      "@type": "ImageObject",
      "url": "https://chx9.github.io/img/svin.webp"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    (function () {
        let  arr,reg = new RegExp("(^| )"+"change-themes"+"=([^;]*)(;|$)");
        if(arr = document.cookie.match(reg)) {
        } else {
            if (new Date().getHours() >= 19 || new Date().getHours() < 6) {
                document.body.classList.add('dark');
                localStorage.setItem("pref-theme", 'dark');
            } else {
                document.body.classList.remove('dark');
                localStorage.setItem("pref-theme", 'light');
            }
        }
    })()

    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://chx9.github.io/en/" accesskey="h" title="chx9 (Alt + H)">chx9</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://chx9.github.io/en/search" title="🔍 search (Alt &#43; /)" accesskey=/>
                <span>🔍 search</span>
                </a>
            </li>
            <li>
                <a href="https://chx9.github.io/en/" title="🏠 home">
                <span>🏠 home</span>
                </a>
            </li>
            <li>
                <a href="https://chx9.github.io/en/posts" title="📚 articles">
                <span>📚 articles</span>
                </a>
            </li>
            <li>
                <a href="https://chx9.github.io/en/tags" title="🧩 tags">
                <span>🧩 tags</span>
                </a>
            </li>
            <li>
                <a href="https://chx9.github.io/en/about" title="🙋🏻‍♂️ about">
                <span>🙋🏻‍♂️ about</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }
</style>

<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://chx9.github.io/en/">🏠 主页</a>&nbsp;»&nbsp;<a href="https://chx9.github.io/en/posts/">📚Articles</a>&nbsp;»&nbsp;<a href="https://chx9.github.io/en/posts/cs/">💻 Programming Basics</a></div>
            <h1 class="post-title">
                Network
            </h1>
            <div class="post-meta">

<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2023-07-29
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>7757字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>16分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>chx9
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
            </span>
        </span>
    </span>
</span>
<span style="opacity: 0.8;">
                    <span id="post_meta_style_7">
                        &nbsp;&nbsp;
                        <span class="fa fa-eye" ></span>
                        <span>
                            <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
                            &nbsp;&nbsp;
                        </span>
                    </span>
                    <span id="post_meta_style_8">
                        <span class="fa fa-commenting-o"></span>
                        <span>
                            <script src="https://cdn.staticfile.org/twikoo//twikoo.all.min.js"></script>
                            <script>
                                let url = document.documentURI
                                
                                let dnsUrl = "https://chx9.github.io/"
                                let urlSplit = url.split(dnsUrl)
                                let finalUrl = urlSplit[1]
                                if (finalUrl[0] !== '/') {
                                    finalUrl = '/'+finalUrl
                                }
                                twikoo.getCommentsCount({
                                    envId:  null , 
                                region:  null , 
                                urls: [ 
                                    
                                    finalUrl,
                                ],
                                    includeReply: false 
                                }).then(function (res) {
                                    let count = res[0].count
                                    const obj = document.getElementById("comment_count");
                                    obj.innerText = count
                                    
                                    
                                    
                                }).catch(function (err) {
                                    
                                    console.error(err);
                                });
                            </script>
                            <span id="comment_count"></span>
                        </span>
                    </span>
                </span>

</div>
        </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e8%bf%87%e7%a8%8b" aria-label="三次握手过程">三次握手过程</a></li>
                <li>
                    <a href="#%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b%e8%bf%87%e7%a8%8b" aria-label="四次挥手过程">四次挥手过程</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88-tcp-%e8%a6%81%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b" aria-label="为什么 TCP 要三次握手？">为什么 TCP 要三次握手？</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88-tcp-%e8%a6%81%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b" aria-label="为什么 TCP 要四次挥手">为什么 TCP 要四次挥手</a></li>
                <li>
                    <a href="#tcp-%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%a4%b1%e8%b4%a5%e4%bc%9a%e5%8f%91%e7%94%9f%e4%bb%80%e4%b9%88" aria-label="TCP 三次握手失败会发生什么">TCP 三次握手失败会发生什么</a><ul>
                        
                <li>
                    <a href="#%e7%ac%ac%e4%b8%80%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%a4%b1%e8%b4%a5" aria-label="第一次握手失败">第一次握手失败</a></li>
                <li>
                    <a href="#%e7%ac%ac%e4%ba%8c%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%a4%b1%e8%b4%a5" aria-label="第二次握手失败">第二次握手失败</a></li>
                <li>
                    <a href="#%e7%ac%ac%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%a4%b1%e8%b4%a5" aria-label="第三次握手失败">第三次握手失败</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%88%97%e4%b8%be%e5%b8%b8%e7%94%a8%e7%9a%84-http-%e7%8a%b6%e6%80%81%e7%a0%81" aria-label="列举常用的 HTTP 状态码">列举常用的 HTTP 状态码</a></li>
                <li>
                    <a href="#get-%e5%92%8c-post-%e8%af%b7%e6%b1%82" aria-label="GET 和 POST 请求">GET 和 POST 请求</a></li>
                <li>
                    <a href="#http-%e5%92%8c-https" aria-label="HTTP 和 HTTPS">HTTP 和 HTTPS</a></li>
                <li>
                    <a href="#http-%e5%8a%a0%e5%af%86%e8%bf%87%e7%a8%8b" aria-label="http 加密过程">http 加密过程</a></li>
                <li>
                    <a href="#%e8%be%93%e5%85%a5%e7%bd%91%e5%9d%80%e5%88%b0%e5%87%ba%e7%8e%b0%e7%bd%91%e9%a1%b5%e7%9a%84%e5%85%a8%e8%bf%87%e7%a8%8b" aria-label="输入网址到出现网页的全过程">输入网址到出现网页的全过程</a></li>
                <li>
                    <a href="#tcp-%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6" aria-label="TCP 拥塞控制">TCP 拥塞控制</a></li>
                <li>
                    <a href="#%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6%e5%92%8c%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6%e5%88%86%e5%88%ab%e8%a7%a3%e5%86%b3%e4%ba%86%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98" aria-label="流量控制和拥塞控制分别解决了什么问题">流量控制和拥塞控制分别解决了什么问题</a></li>
                <li>
                    <a href="#http-%e9%95%bf%e8%bf%9e%e6%8e%a5%e5%92%8c%e7%9f%ad%e8%bf%9e%e6%8e%a5%e5%8c%ba%e5%88%ab" aria-label="http 长连接和短连接区别">http 长连接和短连接区别</a></li>
                <li>
                    <a href="#%e5%93%aa%e4%ba%9b%e7%94%a8-udp-%e5%93%aa%e4%ba%9b%e7%94%a8-tcp" aria-label="哪些用 UDP 哪些用 TCP">哪些用 UDP 哪些用 TCP</a></li>
                <li>
                    <a href="#https-ssl-%e8%bf%9e%e6%8e%a5%e7%9a%84%e8%bf%87%e7%a8%8b" aria-label="https ssl 连接的过程">https ssl 连接的过程</a></li>
                <li>
                    <a href="#http10-%e5%92%8c-http11-%e5%92%8c-http20-%e7%9a%84%e5%b7%ae%e5%88%ab%e5%88%86%e5%88%ab%e5%81%9a%e4%ba%86%e5%93%aa%e5%87%a0%e7%82%b9%e4%bc%98%e5%8c%96" aria-label="http1.0 和 http1.1 和 http2.0 的差别，分别做了哪几点优化">http1.0 和 http1.1 和 http2.0 的差别，分别做了哪几点优化</a></li>
                <li>
                    <a href="#tcp-%e7%b2%98%e5%8c%85%e7%8e%b0%e8%b1%a1" aria-label="tcp 粘包现象">tcp 粘包现象</a></li>
                <li>
                    <a href="#post-%e5%92%8c-get-%e8%af%b7%e6%b1%82" aria-label="POST 和 GET 请求">POST 和 GET 请求</a></li>
                <li>
                    <a href="#tcp-%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e5%8f%af%e9%9d%a0" aria-label="tcp 如何保证可靠">tcp 如何保证可靠</a></li>
                <li>
                    <a href="#%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3" aria-label="滑动窗口">滑动窗口</a></li>
                <li>
                    <a href="#ping-%e7%9a%84%e8%bf%87%e7%a8%8b" aria-label="ping 的过程">ping 的过程</a></li>
                <li>
                    <a href="#mac-%e5%af%bb%e5%9d%80%e5%92%8c-ip-%e5%af%bb%e5%9d%80%e7%9a%84%e5%b7%ae%e5%bc%82" aria-label="mac 寻址和 ip 寻址的差异">mac 寻址和 ip 寻址的差异</a></li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e5%b1%82%e7%9a%84%e4%bd%9c%e7%94%a8" aria-label="数据链路层的作用">数据链路层的作用</a></li>
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c%e5%b1%82%e7%9a%84%e4%bd%9c%e7%94%a8" aria-label="网络层的作用">网络层的作用</a></li>
                <li>
                    <a href="#%e5%ad%90%e7%bd%91%e6%8e%a9%e7%a0%81" aria-label="子网掩码">子网掩码</a></li>
                <li>
                    <a href="#udp-%e5%92%8c-tcp-%e7%9a%84%e5%8c%ba%e5%88%ab%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="UDP 和 TCP 的区别，适用场景">UDP 和 TCP 的区别，适用场景</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e5%87%ba%e7%8e%b0%e5%a4%a7%e9%87%8f%e7%9a%84-close_wait-%e7%8a%b6%e6%80%81%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3" aria-label="为什么会出现大量的 close_wait 状态，如何解决">为什么会出现大量的 close_wait 状态，如何解决</a></li>
                <li>
                    <a href="#%e4%ba%a4%e6%8d%a2%e6%9c%ba%e4%bd%8d%e4%ba%8e%e5%93%aa%e4%b8%80%e5%b1%82" aria-label="交换机位于哪一层">交换机位于哪一层</a></li>
                <li>
                    <a href="#%e4%ba%94%e5%b1%82%e7%bd%91%e7%bb%9c%e4%b8%ad%e7%9a%84%e5%90%84%e5%b1%82%e5%8d%8f%e8%ae%ae%e6%9c%89%e5%95%a5" aria-label="五层网络中的各层协议有啥">五层网络中的各层协议有啥</a></li>
                <li>
                    <a href="#dns-%e8%bf%87%e7%a8%8b" aria-label="DNS 过程">DNS 过程</a>
                </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        if (elements) {
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                    (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                    return element;
                }
            }) || activeElement

            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                if (element === activeElement){
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
                } else {
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
                }
            })
        }
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        <div class="post-content"><h1 id="三次握手过程">三次握手过程<a hidden class="anchor" aria-hidden="true" href="#三次握手过程">#</a></h1>
<p><img loading="lazy" src="handshake.awebp" alt="handshake"  />
</p>
<h1 id="四次挥手过程">四次挥手过程<a hidden class="anchor" aria-hidden="true" href="#四次挥手过程">#</a></h1>
<p><img loading="lazy" src="fairwell.awebp" alt="fairwell"  />
</p>
<h1 id="为什么-tcp-要三次握手">为什么 TCP 要三次握手？<a hidden class="anchor" aria-hidden="true" href="#为什么-tcp-要三次握手">#</a></h1>
<ul>
<li>最主要原因就是防止「历史连接」初始化了连接。</li>
<li>三次握手才可以同步双方的初始序列号
<!-- ![image](why3_1.png) -->
<img src="why3_1.png" alt="alt text" height="700"/>
<img src="why3_2.png" alt="alt text" height="600"/>
</li>
</ul>
<h1 id="为什么-tcp-要四次挥手">为什么 TCP 要四次挥手<a hidden class="anchor" aria-hidden="true" href="#为什么-tcp-要四次挥手">#</a></h1>
<ul>
<li>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<h1 id="tcp-三次握手失败会发生什么">TCP 三次握手失败会发生什么<a hidden class="anchor" aria-hidden="true" href="#tcp-三次握手失败会发生什么">#</a></h1>
<h2 id="第一次握手失败">第一次握手失败<a hidden class="anchor" aria-hidden="true" href="#第一次握手失败">#</a></h2>
<ul>
<li>客户端重传 SYN 包，直到连接成功或者超时（每次等待两倍时间）</li>
<li>如果服务器无法响应，那么会发送 RST 包，表示拒绝连接</li>
</ul>
<h2 id="第二次握手失败">第二次握手失败<a hidden class="anchor" aria-hidden="true" href="#第二次握手失败">#</a></h2>
<ul>
<li>客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是客户端就会触发超时重传机制，重传 SYN 报文。</li>
<li>服务端这边会触发超时重传机制，重传 SYN-ACK 报文。</li>
</ul>
<h2 id="第三次握手失败">第三次握手失败<a hidden class="anchor" aria-hidden="true" href="#第三次握手失败">#</a></h2>
<p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。
注意，ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</p>
<h1 id="列举常用的-http-状态码">列举常用的 HTTP 状态码<a hidden class="anchor" aria-hidden="true" href="#列举常用的-http-状态码">#</a></h1>
<p>HTTP 状态码是指在 HTTP 协议中，服务器向客户端返回的响应状态码。HTTP 状态码由三位数字组成，第一位数字表示响应类型，后两位数字没有具体分类作用。常见的 HTTP 状态码如下：</p>
<ul>
<li>1xx：信息响应类，表示服务器已接收到客户端的请求，需要进一步处理。</li>
<li>2xx：成功响应类，表示服务器已成功地接收到客户端的请求并返回响应结果。</li>
<li>3xx：重定向响应类，表示客户端需要进一步操作才能完成请求，如重定向到其他 URL。</li>
<li>4xx：客户端错误响应类，表示客户端请求存在错误或无法被服务器处理。</li>
<li>5xx：服务器错误响应类，表示服务器在处理请求时出现了错误或异常。</li>
</ul>
<p>以下是常见的 HTTP 状态码及其含义：</p>
<ul>
<li>200 OK：表示请求被成功处理，并返回响应结果。</li>
<li>301 Moved Permanently：表示请求的资源已经被永久移动到新的位置，客户端需要使用新的 URL。</li>
<li>302 Found：表示请求的资源已经被暂时移动到新的位置，客户端需要使用新的 URL，但是之后可能会恢复原来的位置。</li>
<li>304 Not Modified：表示客户端发送了一个条件请求，并且服务器认为客户端请求的资源没有被修改，因此不需要返回资源的实体内容，只需要返回响应头信息即可。</li>
<li>404 Not Found：表示请求的资源不存在或无法被找到。</li>
<li>500 Internal Server Error：表示服务器在处理请求时出现了未知的错误或异常。</li>
</ul>
<p>除了上述常见的 HTTP 状态码，HTTP 协议中还有很多其他状态码，每个状态码都有其特定的含义和用途。在编写 Web 应用程序时，了解 HTTP 状态码的含义和使用方法，可以帮助我们更好地处理 HTTP 请求，提高程序的可靠性和稳定性。</p>
<h1 id="get-和-post-请求">GET 和 POST 请求<a hidden class="anchor" aria-hidden="true" href="#get-和-post-请求">#</a></h1>
<p>GET 和 POST 是 HTTP 协议中最常用的两种请求方法，它们有以下区别：</p>
<ol>
<li>
<p>参数传递方式：GET 请求将参数以 URL 参数的形式传递，而 POST 请求将参数包含在请求体中传递。</p>
</li>
<li>
<p>安全性：GET 请求的参数会被包含在 URL 中，因此可能会被浏览器缓存、历史记录、代理服务器等记录下来，并且容易被攻击者截取、篡改或者伪造。POST 请求的参数则不会被包含在 URL 中，相对来说更加安全。</p>
</li>
<li>
<p>请求体大小限制：GET 请求对请求体大小没有限制，但是浏览器对 URL 长度有限制；POST 请求对请求体大小有限制，一般情况下不会超过 2MB。</p>
</li>
<li>
<p>应用场景：GET 请求适合请求数据，如获取页面、搜索等操作；POST 请求适合提交数据，如提交表单、上传文件等操作。</p>
</li>
</ol>
<h1 id="http-和-https">HTTP 和 HTTPS<a hidden class="anchor" aria-hidden="true" href="#http-和-https">#</a></h1>
<p>HTTP（Hypertext Transfer Protocol）和 HTTPS（Hypertext Transfer Protocol Secure）都是用于在 Web 上进行数据传输的协议，它们的主要区别在于安全性：</p>
<ol>
<li>
<p>安全性：HTTP 是明文传输协议，数据在传输过程中没有加密，容易被窃听和篡改；HTTPS 利用 SSL/TLS 协议进行数据加密和身份认证，可以保证数据传输的安全性。</p>
</li>
<li>
<p>端口号：HTTP 使用的端口号为 80，而 HTTPS 使用的端口号为 443。</p>
</li>
<li>
<p>证书：HTTPS 需要使用数字证书对网站进行身份验证，证书由受信任的第三方机构颁发，可以保证网站的真实性和安全性；而 HTTP 没有身份验证机制，无法保证网站的真实性和安全性。</p>
</li>
<li>
<p>性能：HTTPS 比 HTTP 的性能要差一些，因为 HTTPS 需要进行加密和解密操作，会增加服务器和客户端的处理负担，导致响应速度变慢。</p>
</li>
</ol>
<h1 id="http-加密过程">http 加密过程<a hidden class="anchor" aria-hidden="true" href="#http-加密过程">#</a></h1>
<p>HTTPS（Hypertext Transfer Protocol Secure）是一个用于安全传输数据的协议，它使用 SSL（Secure Sockets Layer）或 TLS（Transport Layer Security）协议来加密 Web 通信。以下是 HTTPS 的加密过程：</p>
<ol>
<li>
<p>客户端发起 HTTPS 请求，请求连接到服务器。</p>
</li>
<li>
<p>服务器向客户端发送一个证书，证书中包含了服务器的公钥、证书的有效期、证书颁发机构等信息。</p>
</li>
<li>
<p>客户端收到证书后，会验证证书的有效性，包括证书是否过期、证书颁发机构是否可信等。如果证书有效，客户端会生成一个随机数，用于后续的加密通信。</p>
</li>
<li>
<p>客户端使用服务器的公钥加密随机数，并将加密后的随机数发送给服务器。</p>
</li>
<li>
<p>服务器使用自己的私钥解密客户端发来的随机数，并使用该随机数作为对称加密算法的密钥，用于后续的数据加密。</p>
</li>
<li>
<p>服务器使用对称加密算法对数据进行加密，并将加密后的数据发送给客户端。</p>
</li>
<li>
<p>客户端使用之前生成的随机数作为对称加密算法的密钥，解密服务器发来的数据，从而得到原始数据。</p>
</li>
</ol>
<p>以上就是 HTTPS 的加密过程，通过使用 SSL 或 TLS 协议，可以确保数据在传输过程中的机密性、完整性和真实性。</p>
<h1 id="输入网址到出现网页的全过程">输入网址到出现网页的全过程<a hidden class="anchor" aria-hidden="true" href="#输入网址到出现网页的全过程">#</a></h1>
<p>输入网址到浏览器中，到收到网页的整个过程大致可以分为以下步骤：</p>
<ol>
<li>
<p>DNS 解析：浏览器首先会解析输入的网址中的域名，将其转换为对应的 IP 地址。浏览器会先查找本地 DNS 缓存，如果没有找到匹配的 IP 地址，则会向 DNS 服务器发送请求，获取对应域名的 IP 地址。</p>
</li>
<li>
<p>建立 TCP 连接：浏览器向服务器发送 TCP 连接请求，建立 TCP 连接。在这个过程中，浏览器和服务器会通过三次握手协议建立连接。</p>
</li>
<li>
<p>发送 HTTP 请求：浏览器向服务器发送 HTTP 请求，请求获取特定资源，比如 HTML、CSS、JavaScript、图片等。</p>
</li>
<li>
<p>服务器响应：服务器接收到浏览器的 HTTP 请求后，会返回相应的资源内容以及 HTTP 状态码。</p>
</li>
<li>
<p>浏览器渲染：当浏览器接收到服务器返回的资源内容后，会根据 HTML、CSS 和 JavaScript 等文件进行解析，生成 DOM 和 CSSOM 树，并将其合并成渲染树。然后浏览器会根据渲染树进行布局和绘制，最终将网页内容显示在用户界面上。</p>
</li>
</ol>
<p>在这个过程中，涉及到的协议主要有：</p>
<ol>
<li>
<p>DNS 协议：用于域名解析，将域名转换为对应的 IP 地址。</p>
</li>
<li>
<p>TCP 协议：用于在浏览器和服务器之间建立可靠的连接，确保数据的可靠传输。</p>
</li>
<li>
<p>HTTP 协议：用于在浏览器和服务器之间传输资源内容，包括 HTML、CSS、JavaScript、图片等。</p>
</li>
<li>
<p>HTTPS 协议：用于在 HTTP 协议的基础上添加 SSL/TLS 协议进行加密通信，提高数据传输的安全性。</p>
</li>
</ol>
<h1 id="tcp-拥塞控制">TCP 拥塞控制<a hidden class="anchor" aria-hidden="true" href="#tcp-拥塞控制">#</a></h1>
<p><a href="https://www.bilibili.com/video/BV1L4411a7RN/?spm_id_from=333.337.search-card.all.click&amp;vd_source=88a9ec90f0dcb5eb62f1a86d6d8d0ad4">b 站视频</a></p>
<p><a href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">小林 coding</a></p>
<p>拥塞控制是一种网络流量控制机制，它通过限制数据流的速度来防止网络拥塞和保持网络的稳定性。拥塞控制的几个常见机制包括：</p>
<ol>
<li>
<p>慢启动：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。相当于 2 的指数倍增长 。</p>
</li>
<li>
<p>拥塞避免：每当收到一个 ACK 时，cwnd 增加 1/cwnd，变成了线性增长。</p>
</li>
<li>
<p>快速重传：当发送方发现某个数据包没有收到确认时，它会重传该数据包。然而，如果发送方连续发送了多个数据包而没有收到确认，它会认为网络出现了拥塞，并立即减慢发送速率。幸运的是，由于 TCP 采用的是累计确认机制，即当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余 ACK（duplicate ACK）。</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>如图所示，报文段1成功接收并被确认ACK 2，接收端的期待序号为2，当报文段2丢失，报文段3失序到来，与接收端的期望不匹配，接收端重复发送冗余ACK 2。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>这样，如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK（其实是收到4个同样的ACK，第一个是正常的，后三个才是冗余的），发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出，大大提高了效率。这便是快速重传机制。
</span></span></code></pre></div><p><img loading="lazy" src="kuaichongchuan.png" alt="快速重传"  />
 4. 快速恢复：当发送方减慢发送速率时，接收方会通知发送方可以增加发送速率。这种机制称为快速恢复，它可以帮助发送方更快地恢复正常的发送速率，而不是像慢启动一样重新开始。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>正如前面所说，进入快速恢复之前，cwnd 和 ssthresh 已被更新了：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cwnd = cwnd/2 ，也就是设置为原来的一半;
</span></span><span style="display:flex;"><span>ssthresh = cwnd;
</span></span><span style="display:flex;"><span>然后，进入快速恢复算法如下：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；
</span></span><span style="display:flex;"><span>重传丢失的数据包；
</span></span><span style="display:flex;"><span>如果再收到重复的 ACK，那么 cwnd 增加 1；
</span></span><span style="display:flex;"><span>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；
</span></span></code></pre></div><p><img loading="lazy" src="yongse.png" alt="拥塞控制"  />
</p>
<h1 id="流量控制和拥塞控制分别解决了什么问题">流量控制和拥塞控制分别解决了什么问题<a hidden class="anchor" aria-hidden="true" href="#流量控制和拥塞控制分别解决了什么问题">#</a></h1>
<p>流量控制是防止接收端被发送端的数据包淹没，确保接收端处理得过来。</p>
<p>拥塞控制是避免网络中的数据包太多，导致网络资源如路由器、链路等过载</p>
<h1 id="http-长连接和短连接区别">http 长连接和短连接区别<a hidden class="anchor" aria-hidden="true" href="#http-长连接和短连接区别">#</a></h1>
<p>长连接（Long Connection）</p>
<ul>
<li>
<p>长连接在数据的传输结束后，仍然保持连接状态，可重复使用，直到客户端或服务器主动关闭。</p>
</li>
<li>
<p>场景：实时应用（如在线聊天、即时通讯）、数据库连接、HTTP/2 中的服务。
短连接（Short Connection）</p>
</li>
<li>
<p>短连接发送请求后，得到服务器响应就立刻断开。</p>
</li>
<li>
<p>场景：HTTP/1.0 协议、邮件发送/接收、FTP 文件传输。</p>
</li>
</ul>
<h1 id="哪些用-udp-哪些用-tcp">哪些用 UDP 哪些用 TCP<a hidden class="anchor" aria-hidden="true" href="#哪些用-udp-哪些用-tcp">#</a></h1>
<p>应用层协议可以使用 TCP 或 UDP 进行数据传输，具体使用哪种传输协议，需要根据协议的特性和应用场景进行选择。下面是一些常见的应用层协议及其使用的传输协议：</p>
<p>使用 TCP 传输的应用层协议：</p>
<ol>
<li>
<p>HTTP 协议：用于 Web 应用程序的数据传输。</p>
</li>
<li>
<p>FTP 协议：用于文件传输，支持文件上传和下载等操作。</p>
</li>
<li>
<p>SMTP 协议：用于电子邮件的传输。</p>
</li>
<li>
<p>SSH 协议：用于安全远程登录和文件传输。</p>
</li>
<li>
<p>Telnet 协议：用于远程登录主机进行命令行操作。</p>
</li>
</ol>
<p>使用 UDP 传输的应用层协议：</p>
<ol>
<li>
<p>DNS 协议：用于域名解析，将域名转换为 IP 地址。</p>
</li>
<li>
<p>DHCP 协议：用于动态 IP 地址分配，自动分配和管理 IP 地址。</p>
</li>
<li>
<p>TFTP 协议：用于简单文件传输，支持无连接传输方式。</p>
</li>
<li>
<p>SNMP 协议：用于网络管理和监控，实现对网络设备的远程管理。</p>
</li>
<li>
<p>RTP 协议：用于音视频数据的传输，支持实时传输和流媒体播放。</p>
</li>
</ol>
<p>需要注意的是，有些应用层协议同时支持 TCP 和 UDP 传输，如 DNS 协议和 FTP 协议等，可以根据实际情况进行选择。</p>
<h1 id="https-ssl-连接的过程">https ssl 连接的过程<a hidden class="anchor" aria-hidden="true" href="#https-ssl-连接的过程">#</a></h1>
<p>HTTPS 加密过程简略如下：</p>
<ol>
<li>
<p>客户端发送 HTTPS 请求，请求头中的<code>https</code>字段设置为<code>on</code>。</p>
</li>
<li>
<p>服务器返回数字证书，包含服务器的公钥、证书颁发机构的信息、证书有效期等。</p>
</li>
<li>
<p>客户端验证证书合法性，确认无误后生成随机的会话密钥，并使用服务器的公钥将其加密后发送给服务器。</p>
</li>
<li>
<p>服务器使用自己的私钥解密会话密钥，得到原始的会话密钥。</p>
</li>
<li>
<p>双方使用会话密钥进行对称加密，保证通信过程中的数据安全性，并进行数字签名和身份认证，确保通信的可信性和完整性。</p>
</li>
</ol>
<h1 id="http10-和-http11-和-http20-的差别分别做了哪几点优化">http1.0 和 http1.1 和 http2.0 的差别，分别做了哪几点优化<a hidden class="anchor" aria-hidden="true" href="#http10-和-http11-和-http20-的差别分别做了哪几点优化">#</a></h1>
<p>HTTP 是一种应用层协议，常用于 Web 应用中，目前主要有 HTTP/1.0、HTTP/1.1 和 HTTP/2.0 三个版本。它们之间的主要差别及优化如下：</p>
<ol>
<li>HTTP/1.0 和 HTTP/1.1 的主要差别</li>
</ol>
<p>HTTP 1.0</p>
<p>单一请求响应模型，每个请求/响应都会断开连接。
HTTP 1.1</p>
<p>持久连接：默认情况下，所有的连接都被认为是持久的，除非有明确的关闭。
管道化技术：在同一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了网络延迟。
增加更多的缓存控制策略。
支持内容协商，包括语言、编码等。
提供对资源的范围请求，方便实现文件的部分下载。
HTTP 2.0</p>
<p>多路复用：单一 TCP 连接中可并行交换多个 HTTP 请求/响应。
首部压缩：对头信息进行压缩，减少数据传输量。
服务器推送：允许服务器未经客户端明确请求就发送数据到客户端，提高性能。</p>
<h1 id="tcp-粘包现象">tcp 粘包现象<a hidden class="anchor" aria-hidden="true" href="#tcp-粘包现象">#</a></h1>
<p>TCP 粘包是因为 TCP 基于字节流，不保证消息边界</p>
<p>解决 TCP 粘包现象的方法主要有以下几种：</p>
<ol>
<li>
<p>增加消息边界：在消息头部添加消息长度字段，接收方根据消息长度进行数据的切割。</p>
</li>
<li>
<p>使用固定长度的消息：发送方将消息按照固定长度进行分割，接收方根据固定长度进行数据的切割。</p>
</li>
<li>
<p>使用特殊字符作为消息分隔符：发送方在消息尾部添加特殊字符作为消息分隔符，接收方根据特殊字符进行数据的切割。</p>
</li>
<li>
<p>使用应用层协议：在应用层协议中规定消息的格式和边界，从而避免粘包现象的发生。</p>
</li>
</ol>
<h1 id="post-和-get-请求">POST 和 GET 请求<a hidden class="anchor" aria-hidden="true" href="#post-和-get-请求">#</a></h1>
<p>GET 和 POST 是 HTTP 协议中常用的两种请求方法，它们在数据传输、安全性、请求体大小等方面有所不同。</p>
<p>GET 请求方法是用于从服务器获取数据的方法，该方法将请求参数附加在 URL 的末尾，以问号(?)的形式分隔 URL 和请求参数，多个请求参数之间以&amp;符号分隔。因此，GET 请求方法的请求体大小有限制，通常不超过 2KB。</p>
<p>POST 请求方法是用于向服务器提交数据的方法，该方法将请求参数放在请求体中，请求体的格式由 Content-Type 头部指定。因为 POST 请求方法将请求参数放在请求体中，所以请求体的大小没有限制，可以传输较大的数据。</p>
<p>GET 和 POST 请求方法在安全性方面也有所不同。由于 GET 请求方法将请求参数附加在 URL 的末尾，所以请求参数会暴露在 URL 中，容易被中间人攻击截获和篡改。而 POST 请求方法将请求参数放在请求体中，相对安全一些。</p>
<p>幂等性：GET 请求方法具有幂等性，即多次请求返回的结果相同，不会对服务器产生影响。而 POST 请求方法不具有幂等性，多次请求可能会产生不同的结果，对服务器产生影响。</p>
<p>总之，GET 和 POST 请求方法在数据传输、安全性、请求体大小等方面有所不同。一般来说，GET 请求方法用于从服务器获取数据，POST 请求方法用于向服务器提交数据。当需要传输大量数据或者涉及到敏感数据时，建议使用 POST 请求方法。</p>
<h1 id="tcp-如何保证可靠">tcp 如何保证可靠<a hidden class="anchor" aria-hidden="true" href="#tcp-如何保证可靠">#</a></h1>
<p>TCP（Transmission Control Protocol）是一种面向连接的、可靠的传输协议，它通过以下机制来保证数据传输的可靠性：</p>
<ol>
<li>
<p>序列号与确认应答机制：每个 TCP 报文段都有一个唯一的序列号和确认应答号，用于保证数据的顺序性和完整性。发送端将数据分成若干个报文段发送，每个报文段都有一个序列号，接收端收到报文段后需向发送端发送确认应答，确认应答号为接收到的数据的下一个期望的序列号。如果发送端接收到确认应答，就认为该报文段已经成功传输，可以将该报文段从发送缓冲区中删除。</p>
</li>
<li>
<p>超时重传机制：发送端在发送数据时会启动一个定时器，如果在指定时间内没有收到接收端的确认应答，发送端会判断该报文段丢失了，需要重新发送。接收端收到重复的报文段时，会丢弃该报文段，同时向发送端发送确认应答。</p>
</li>
<li>
<p>滑动窗口机制：TCP 使用滑动窗口机制来实现流量控制和拥塞控制。发送端和接收端都有一个窗口大小，用于限制发送和接收数据的速率。发送端发送数据时，需要等待接收端发送的确认应答，确认应答中包含接收端当前窗口的大小，发送端根据窗口大小来调整发送数据的速率。</p>
</li>
<li>
<p>拥塞控制</p>
</li>
<li>
<p>校验和：校验和（checksum）是一种用于检测数据传输过程中是否发生错误的技术。在数据传输过程中，可能会出现各种各样的错误，比如说数据损坏、数据重复、数据丢失等，这些错误都可能导致数据传输失败或者数据被篡改。校验和技术可以通过计算数据的校验和值来检测这些错误，从而保证数据传输的可靠性。</p>
</li>
</ol>
<p>通过以上机制，TCP 可以保证数据传输的可靠性，并且在网络出现拥塞时可以进行拥塞控制，避免网络拥塞导致数据丢失或传输延迟增加。</p>
<h1 id="滑动窗口">滑动窗口<a hidden class="anchor" aria-hidden="true" href="#滑动窗口">#</a></h1>
<p><a href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">小林 coding</a></p>
<h1 id="ping-的过程">ping 的过程<a hidden class="anchor" aria-hidden="true" href="#ping-的过程">#</a></h1>
<p>主要是 icmp
Ping 是一种常用的网络诊断工具，用于测试主机之间的连通性。当我们使用 Ping 命令时，Ping 程序会执行以下步骤：</p>
<ol>
<li>
<p>发送 ICMP Echo Request 消息：Ping 程序向目标主机发送一个 ICMP Echo Request 消息，该消息包含一个随机的标识符和序列号。</p>
</li>
<li>
<p>接收 ICMP Echo Reply 消息：目标主机收到 ICMP Echo Request 消息后，会向发送方返回一个 ICMP Echo Reply 消息，该消息包含与 Echo Request 消息相同的标识符和序列号。</p>
</li>
<li>
<p>计算往返时间（RTT）：Ping 程序在接收到 Echo Reply 消息后，会计算从发送 Echo Request 消息到接收 Echo Reply 消息所需的时间，即往返时间（RTT）。</p>
</li>
<li>
<p>显示结果：Ping 程序将计算得到的 RTT 值和其他一些统计信息显示在屏幕上。如果目标主机无法到达，Ping 程序会返回一个错误消息。</p>
</li>
</ol>
<p>需要注意的是，Ping 命令使用的是 ICMP 协议，而不是 TCP 或 UDP 协议。因此，Ping 命令可以用于测试主机之间的连通性，但不能用于测试 TCP 或 UDP 服务的可用性。此外，由于 ICMP 消息可以被防火墙和路由器过滤，因此在某些情况下，Ping 命令可能无法正常工作。</p>
<h1 id="mac-寻址和-ip-寻址的差异">mac 寻址和 ip 寻址的差异<a hidden class="anchor" aria-hidden="true" href="#mac-寻址和-ip-寻址的差异">#</a></h1>
<p>mac 寻址在数据链路层，ip 寻址在网络层</p>
<h1 id="数据链路层的作用">数据链路层的作用<a hidden class="anchor" aria-hidden="true" href="#数据链路层的作用">#</a></h1>
<p>1、封装成帧
2、流量控制
3、差错控制
4、mac 寻址
5、透明传输</p>
<h1 id="网络层的作用">网络层的作用<a hidden class="anchor" aria-hidden="true" href="#网络层的作用">#</a></h1>
<p><strong>管理数据包的传输和路由选择</strong>，将数据包从源节点传输到目的节点。
实现<strong>IP（Internet Protocol）协议，负责数据包的分组、传输和路由选择</strong>。</p>
<p>提供差错控制和流量控制功能，确保数据包传输的可靠性和效率。</p>
<p>实现路由选择算法，根据网络拓扑结构和路由策略选择最佳的路径将数据包传输到目的节点。</p>
<p>实现地址转换（NAT，Network Address Translation）等功能，将内部私有地址转换为公网可用的地址，以实现网络连接与安全性的需求。</p>
<h1 id="子网掩码">子网掩码<a hidden class="anchor" aria-hidden="true" href="#子网掩码">#</a></h1>
<p>子网掩码（subnet mask）是用于划分<strong>网络地址和主机地址</strong>的一个 32 位数值，用于告诉网络设备哪些位是网络地址，哪些位是主机地址。子网掩码通常与 IP 地址配合使用，用于指示网络中哪些位是网络地址，哪些位是主机地址。</p>
<p>子网掩码的作用是将一个 IP 地址分成两部分：网络地址和主机地址。网络地址用于标识网络，而主机地址用于标识特定的主机。</p>
<p>子网掩码的格式通常是四个 8 位二进制数，例如 255.255.255.0。这个子网掩码表示前 24 位是网络地址，后 8 位是主机地址。这意味着，对于该子网掩码的网络，可以有 256 个主机地址（2 的 8 次方），因为最后 8 位可以有 256 种不同的组合。</p>
<p>在计算机网络中，子网掩码有助于划分网络和管理 IP 地址。通过使用子网掩码，网络管理员可以将一个大的 IP 地址空间分成多个子网，以便更有效地管理网络。例如，一个大的 IP 地址空间可以划分为多个小的子网，每个子网可以被分配给不同的部门或办公室，以便更好地管理网络流量和安全。</p>
<h1 id="udp-和-tcp-的区别适用场景">UDP 和 TCP 的区别，适用场景<a hidden class="anchor" aria-hidden="true" href="#udp-和-tcp-的区别适用场景">#</a></h1>
<p>TCP 适用于对数据传输的可靠性要求较高的场景，如文件传输（ftp）、电子邮件（stmp）、网页浏览（http）等；UDP 适用于对数据传输的可靠性要求较低、数据传输速度要求较高的场景，如在线游戏、实时音视频、DNS 等。</p>
<h1 id="为什么会出现大量的-close_wait-状态如何解决">为什么会出现大量的 close_wait 状态，如何解决<a hidden class="anchor" aria-hidden="true" href="#为什么会出现大量的-close_wait-状态如何解决">#</a></h1>
<p>TIME_WAIT 状态是因为频繁地建立和关闭连接，或者连接关闭不规范等。</p>
<p>解决办法：</p>
<ol>
<li>调整 TCP 参数如 TIME_WAIT 时间。</li>
<li>优化程序设计，比如使用连接池。</li>
<li>使用 SO_REUSEADDR 共用端口。</li>
<li>使用负载均衡器分摊连接负载。少 time_wait 状态的出现。</li>
</ol>
<h1 id="交换机位于哪一层">交换机位于哪一层<a hidden class="anchor" aria-hidden="true" href="#交换机位于哪一层">#</a></h1>
<p>交换机位于数据链层，负责在同一网络下中转发数据帧。它能够根据目标 MAC 地址来决定数据帧的转发路径，以实现同一网络内的通信。
路由器是一种网络设备，主要用于在不同的网络之间转发数据包。</p>
<h1 id="五层网络中的各层协议有啥">五层网络中的各层协议有啥<a hidden class="anchor" aria-hidden="true" href="#五层网络中的各层协议有啥">#</a></h1>
<p><img loading="lazy" src="protocols.png" alt="协议"  />
</p>
<h1 id="dns-过程">DNS 过程<a hidden class="anchor" aria-hidden="true" href="#dns-过程">#</a></h1>
<p>以下是 DNS 解析 www.example 的过程：</p>
<ol>
<li>
<p>当用户在浏览器中输入 www.example 时，浏览器会向本地 DNS 服务器发送 DNS 解析请求。</p>
</li>
<li>
<p>如果本地 DNS 服务器缓存了该域名的解析信息，它将直接返回该域名的 IP 地址。否则，它将向根域名服务器发送请求。</p>
</li>
<li>
<p>根域名服务器将返回.com 顶级域名服务器的地址。</p>
</li>
<li>
<p>本地 DNS 服务器随后向.com 顶级域名服务器发送请求，并返回该域名的权威域名服务器地址。</p>
</li>
<li>
<p>本地 DNS 服务器向该权威域名服务器发送请求，并返回该域名的 IP 地址。</p>
</li>
<li>
<p>本地 DNS 服务器将该 IP 地址缓存起来，并将其返回给用户的计算机或设备。</p>
</li>
<li>
<p>用户的计算机或设备使用该 IP 地址与该域名的服务器进行通信，以获取网站的内容。</p>
</li>
</ol>


        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://chx9.github.io/en/posts/cs/leetcode/">
    <span class="title">« 上一页</span>
    <br>
    <span>Leetcode</span>
  </a>
  <a class="next" href="https://chx9.github.io/en/posts/read/read/">
    <span class="title">下一页 »</span>
    <br>
    <span>My Reading List</span>
  </a>
</nav>

        </footer>
    </div>

<style>
    .comments_details summary::marker {
        font-size: 20px;
        content: '👉展开评论';
        color: var(--content);
    }
    .comments_details[open] summary::marker{
        font-size: 20px;
        content: '👇关闭评论';
        color: var(--content);
    }
</style>


<div>
    <details class="comments_details">
        <summary style="cursor: pointer; margin: 50px 0 20px 0;width: 130px;">
            <span style="font-size: 20px;color: var(--content);">...</span>
        </summary>
        <div id="tcomment"></div>
    </details>
    <script src="https://cdn.staticfile.org/twikoo//twikoo.all.min.js">
    </script>
    <script>
        twikoo.init({
            envId:  null ,
        el: "#tcomment",
            lang: 'zh-CN',
            region:  null ,
        path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
        })
    </script>
</div>
</article>
</main>

<footer class="footer">
    <span>
        Copyright
        &copy;
        -2023
        <a href="https://chx9.github.io/en/" style="color:#939393;">chx9</a>
        All Rights Reserved
    </span>
    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;"></a>&nbsp;
    <span>
        <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null"
           style="display:inline-block;text-decoration:none;height:20px;color:#939393;">
            <img src="" style="float:left;margin: 0px 5px 0px 0px;"/>
            
        </a>
    </span>
    <span id="busuanzi_container">
        <span class="fa fa-user"></span> <span id="busuanzi_value_site_uv"></span>
        <span class="fa fa-eye"></span> <span id="busuanzi_value_site_pv"></span>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
</script>
<script>
    let mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        (function() {
            document.cookie = "change-themes" + "="+ escape ("false");
        })()

        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    });
</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() 
                let textData = window.getSelection().toString() 
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
                
                
                
                
                
                
                
                
                
                
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;
        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '📄复制';

        function copyingDone() {
            copybutton.innerText = '👌🏻已复制!';
            setTimeout(() => {
                copybutton.innerText = '📄复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent 
                
                
                
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {}
            selection.removeRange(range);
        });

        let language = codeblock.className.replaceAll("language-", "")
        let macTool = document.createElement("div")
        let macTool1 = document.createElement("div")
        let macTool2 = document.createElement("div")
        let macTool3 = document.createElement("div")
        let languageType = document.createElement("div")
        languageType.innerText = language
        
        
        
        
        languageType.setAttribute('class', 'language-type')
        macTool.appendChild(macTool1)
        macTool.appendChild(macTool2)
        macTool.appendChild(macTool3)
        macTool.appendChild(languageType)

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
            container.appendChild(macTool)
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        }
    });
</script>
</body>

</html>
