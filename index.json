[{"content":"docker 面对对象 容器 :对象\n镜像 :类\n常用命令 docker run 每次都会新建一个 docker container，可以添加-it命令\ndocker run -d image: 在后台运行容器。\ndocker run -it image sh: 交互式地在前台运行容器（常用于调试）。\nt: 在新容器内指定一个伪终端或终端。 i: 允许你对容器内的标准输入 (STDIN) 进行交互。 image后面的sh选项可以不填，默认会启动镜像内的CMD或ENTRYPOINT指定的程序。但是如果这些程序不是交互式Shell，那么你将无法得到一个终端 docker run -p 80:80 image: 映射80端口到主机上的80端口。docker run --rm image: 容器结束后自动删除。\ndocker run -v /host/dir:/container/dir image: 挂载主机目录到容器中。\ndocker run --rm -it prakhar1989/static-site 如果已经存在，直接把旧的删除\ndocker run -d -P --name static-site prakhar1989/static-site -\n-d选项会使你的终端脱离，此命令将在后台运行容器。 -P选项将发布所有暴露的端口到随机端口。 --name对应我们想要给定的名称。 可以通过运行docker port [CONTAINER]命令来查看端口 docker rm 删除一个或者多个 container\ndocker rm 305297d7a235 ff0a5c3750b9\n删除所有状态为已退出(status=exited)的 Docker容器\ndocker rm $(docker ps -a -q -f status=exited)\n删除所有停止的容器:\ndocker container prune\n删除所有容器(无论是否运行):\ndocker rm $(docker ps -a -q)\n删除创建状态的容器:\ndocker rm $(docker ps -a -q -f status=created)\n删除所有未使用的数据(不只是容器):\ndocker system prune\n强制删除正在运行的容器:\ndocker rm -f $(docker ps -a -q)\ndocker ps 列出所有容器:\ndocker ps -a\n列出正在运行的容器:\ndocker ps\n列出最近创建的容器:\ndocker ps -l\n列出特定状态的容器, 如已退出(exited):\ndocker ps -a -f status=exited\n列出最近停止的n个容器:\ndocker ps -n\n以特定格式显示容器信息:\ndocker ps --format \u0026quot;{{.ID}}: {{.Status}}\u0026quot;\ndocker start docker start变种：\ndocker start container_id: 启动一个已经停止的容器。 docker start -a container_id: 启动容器并附着到其stdout/stderr和可选地stdin（与正在运行的容器一起使用）。 只显示输出 docker start -i container_id: 启动容器并附加（attach）TTY。 docker attach变种：\ndocker attach container_id: 附着到运行中的容器以查看其输出或与其交互。 docker attach --sig-proxy=true container_id: 代理所有接收的信号到进程 (默认为true)。 docker attach --no-stdin container_id: 不附加STDIN。 ","permalink":"https://chx9.github.io/posts/cs/docker/","summary":"docker 面对对象 容器 :对象 镜像 :类 常用命令 docker run 每次都会新建一个 docker container，可以添加-it命令 docker run -d image: 在后台运行容器。 docker run -it image sh: 交互式地在前台运行容器（常用于调试）。 t: 在新容器内指定一个伪终端或终端。 i: 允许你对容器内的标准输入 (STDIN) 进行交互。 image后面的sh选项可以不填，默认会","title":"Docker"},{"content":"apple\n多态介绍 定义：首先，可以解释一下什么是多态。多态（Polymorphism）是面向对象编程的一个重要特性，它允许我们使用父类的指针或引用来操作子类对象。这样，同一个函数或者操作符可以对不同类型的对象产生不同的行为。\n两种形式：C++中的多态主要有两种形式：静态多态（或编译时多态）和动态多态（或运行时多态）。静态多态通过模板和函数重载实现；动态多态则需要使用虚函数和继承。\n虚函数可能带来的运行时开销、虚函数应该提供默认实现或声明为纯虚函数等。\n静态多态 静态多态，也称为编译时多态，是指在编译时就能确定函数调用的具体版本。C++中主要通过两种方式来实现静态多态：函数重载和模板。\n函数重载：你可以定义多个名称相同但参数列表不同的函数，这些函数就构成了一组重载函数。当你调用一个重载函数时，编译器会根据传入的参数类型和数量在编译时选择合适的函数版本。例如：\nvoid print(int i) { std::cout \u0026lt;\u0026lt; \u0026#34;Printing int: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; } void print(double d) { std::cout \u0026lt;\u0026lt; \u0026#34;Printing double: \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; std::endl; } 在这个例子中，print 函数就有两个版本：一个接受 int 参数，另一个接受 double 参数。具体调用哪个版本取决于你传入的参数类型。\n模板：模板是一种让函数或类能够处理多种数据类型的机制。对于模板函数或模板类，你只需编写一份代码，然后编译器会在需要的时候为你生成针对特定类型的代码。例如：\ntemplate \u0026lt;typename T\u0026gt; void print(const T\u0026amp; t) { std::cout \u0026lt;\u0026lt; \u0026#34;Printing: \u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; std::endl; } 这里的 print 函数是一个模板函数，它可以接受任何数据类型的参数。具体处理哪种数据类型的版本由你传入的参数类型在编译时决定。\n静态多态的优点是效率高，因为函数调用版本的选择发生在编译时，所以没有运行时开销。缺点是所有可能的版本必须在编译时都已知，这限制了代码的灵活性。\n除了多态和继承，面向对象的其他核心概念有： 封装：隐藏内部实现，仅暴露必要接口。 抽象：简化复杂系统，展示关键信息。 组合：使用已有对象构建新对象。 关联/聚合：表达类之间的关系。 接口：定义行为规范。\nsize_of 是在编译期还是在运行期确定 sizeof 是在编译期确定的。编译器知道每种数据类型的大小，因此能够在编译时计算出 sizeof 表达式的值。这也意味着 sizeof 可以用于数组的长度等编译期常量。对于动态分配的内存（如使用 malloc 或 new 创建的），sizeof 只能返回指针本身的大小，而不是它所指向的内存块的大小。\n写一个生产者消费者模型 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;condition_variable\u0026gt; std::queue\u0026lt;int\u0026gt; produced_nums; std::mutex mtx; std::condition_variable cv; // 生产者函数 void producer(int id) { for (int i = 0; ; i++) { { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); std::cout \u0026lt;\u0026lt; \u0026#34;producing \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; produced_nums.push(i); } cv.notify_all(); std::this_thread::sleep_for(std::chrono::milliseconds(100)); # 这句代码使当前线程暂停执行指定的时间，这里是100毫秒。用于模拟生产者生产数据所需的时间，防止过快地生产数据。 } } // 消费者函数 void consumer(int id) { while (true) { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); while (produced_nums.empty()) { cv.wait(lock); } std::cout \u0026lt;\u0026lt; \u0026#34;consuming \u0026#34; \u0026lt;\u0026lt; produced_nums.front() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; produced_nums.pop(); } } int main() { std::thread p1(producer, 0); std::thread c1(consumer, 0); p1.join(); c1.join(); return 0; } 单继承和菱形继承时候的虚函数表内存分布情况 在单继承和菱形继承中，虚函数表的内存分布情况略有不同。\n单继承 在单继承中，在子类没有覆盖父类的方法的情况下派生类会继承基类的虚函数表指针（vptr），该指针指向基类的虚函数表。基类的虚函数表中包含了基类的虚函数和派生类覆盖的虚函数。派生类中新增的虚函数会加入到基类虚函数表的末尾。\n具体来说，假设单继承的类为 Derived，其中包含一个基类 Base，Base 中有一个虚函数 Func。那么 Derived 类的对象内存布局如下：\n+------------------------+ | Base::vptr | +------------------------+ | Derived\u0026#39;s members | | ... | +------------------------+ 其中，Base::vptr 指向虚函数表的起始地址，虚函数表中包含了 Base 和 Derived 类的虚函数。如果 Derived 类覆盖了 Func 虚函数，那么覆盖后的 Func 实现会替代原有的 Base::Func 实现。\n菱形继承 如果不使用虚继承，那么在菱形继承中，每个派生类都会包含两个基类的虚函数表指针，因此该类的对象将包含两个虚指针。具体来说，假设一个类 Diamond 继承了两个基类 Base1 和 Base2，不使用虚继承，那么 Diamond 类的对象内存布局如下：\n+------------------------+ | Diamond::Base1::vptr | +------------------------+ | Base1\u0026#39;s members | | ... | +------------------------+ | Diamond::Base2::vptr | +------------------------+ | Base2\u0026#39;s members | | ... | +------------------------+ | Diamond\u0026#39;s members | | ... | +------------------------+ 在这个例子中，Diamond 类包含了两个虚指针 Diamond::Base1::vptr 和 Diamond::Base2::vptr，它们分别指向了 Base1 和 Base2 的虚函数表。由于派生类同时继承了两个基类的虚函数表指针，因此会浪费一部分内存空间。此外，如果这两个基类中有相同的虚函数，那么在调用这个虚函数时会出现二义性错误。\n因此，为了避免内存浪费和虚函数调用二义性的问题，应该使用虚继承来进行菱形继承。 3. 虚继承 如果使用虚继承，那么在菱形继承中，派生类会继承基类的虚函数表指针，并且合并基类的虚函数表，从而避免内存浪费和虚函数调用二义性的问题。因此，该类的对象只会包含一个虚指针（vptr），指向合并后的虚函数表。\n具体来说，假设一个类 Diamond 继承了两个基类 Base1 和 Base2，使用虚继承，那么 Diamond 类的对象内存布局如下：\n+------------------------+ | Diamond::vptr | +------------------------+ | Base1\u0026#39;s members | | ... | +------------------------+ | Base2\u0026#39;s members | | ... | +------------------------+ | Diamond\u0026#39;s members | | ... | +------------------------+ 在这个例子中，Diamond 类继承了 Base1 和 Base2 两个虚基类，因此它的对象只会包含一个虚指针 Diamond::vptr，指向合并后的虚函数表。由于虚指针是从虚基类继承而来的，因此派生类不需要自己再创建一个指向自己的虚指针。\n使用虚继承可以有效避免内存浪费和虚函数调用二义性的问题，因此在菱形继承中应该尽可能使用虚继承。\n菱形继承会造成什么问题 菱形继承可能会造成以下两个问题：\n内存浪费 在菱形继承中，由于派生类同时继承了两个虚基类，这两个虚基类中包含了相同的成员变量，因此会造成内存浪费。具体来说，如果派生类中直接访问这个成员变量，那么实际上访问的是两个虚基类中的其中一个，另一个成员变量则被浪费掉了。这种情况下，可以使用虚继承来解决内存浪费的问题。\n虚函数调用二义性 在菱形继承中，派生类会继承两个虚基类的虚函数表指针（vptr），这两个虚函数表指针指向同一个虚函数表。如果这两个虚基类中有一个共同的虚函数，在派生类中调用这个虚函数时，就会出现二义性错误。这种情况下，需要明确指定调用的虚基类中的虚函数，避免出现二义性错误。\n需要注意的是，菱形继承的问题并不是绝对的，具体是否会出现问题取决于具体的代码实现和设计。在使用菱形继承时，需要仔细考虑内存布局和虚函数的调用问题，确保程序的正确性和可维护性。\n讲下 cpp 的多态 多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。 C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。\ncpp 多态是怎么实现的 C++中的虚函数是实现多态的重要机制。在 C++中，当一个类中声明了虚函数时，编译器会为该类生成一个虚函数表（vtable），并将该类的每个对象中都存储一个指向虚函数表的指针（vptr）。虚函数表是一个包含了所有虚函数地址的表格，每个虚函数在表格中的位置是固定的。\n当程序通过一个基类指针或引用调用虚函数时，实际执行的是该对象的实际类型对应的虚函数。具体实现过程如下：\n在程序运行时，当对象被创建时，会在对象中存储一个指向虚函数表的指针（vptr）。\n当程序通过一个基类指针或引用调用虚函数时，编译器会将该调用转化为一个间接调用，即通过对象中存储的虚函数表指针找到对应的虚函数地址，然后调用该地址对应的函数。\n如果对象是基类类型，则调用基类中的虚函数；如果对象是派生类类型，则调用派生类中的虚函数。这个过程中，实际调用的函数是由对象的实际类型来决定的，而不是由引用或指针的类型来决定的，因此实现了多态。\n如果派生类没有重写基类的虚函数，则调用基类中的虚函数；如果派生类重写了基类的虚函数，则调用派生类中的虚函数。\n虚函数的实现过程中，由于需要查找虚函数表，因此会带来一定的性能开销。为了减少这种开销，编译器通常会对虚函数进行优化，如使用内联函数、缓存虚函数表等技术来提高性能。\nmalloc/free 和 new/delete？ malloc 和 free 是 C 库函数，也可以在 c++中使用。而 new 和 delete 仅适用于 c++； malloc 和 new 都是在堆中动态分配内存，但是 new 会调用类的构造函数，而 malloc 不会； free() 释放内存但不调用类的析构函数，delete 释放内存并调用类的析构函数。 Placement new:\nPlacement new 是 C++ 中的一个变体 new 运算符。 普通的 new 操作符做两件事：（1）分配内存（2）在分配的内存中构造一个对象。 在 placement new 中，我们可以传递一个预先分配的内存并在传递的内存中构造一个对象。 正常 new 在堆中分配内存并在那里构造对象，而使用 placement new，对象构造可以在已知地址完成。 对于普通的 new，它不知道它指向的地址或内存位置，而它指向的地址或内存位置在使用 placement new 时是已知的。 // buffer on stack unsigned char buf[sizeof(int)*2] ; // placement new in buf int *pInt = new (buf) int(3); inline 和 define 的区别？ 内联函数是由 inline 关键字定义的普通函数。内联函数是由编译器扩展的短函数。并且它的参数只被评估一次。内联函数是在类中不使用 inline 关键字的情况下自动成为内联函数的短长度函数。 它也称为预处理器指令。宏由#define 关键字定义。在程序编译之前，只要预处理器检测到宏，预处理器就会检查程序，然后预处理器用宏定义替换宏。 内联函数由 inline 关键字定义。 而宏是由#define 关键字定义的。 通过内联函数，可以访问类的数据成员。 而宏不能访问类的数据成员。 内联函数的情况下，可以方便的调试程序。 而在宏的情况下，程序不容易调试。 在 inline 的情况下，参数只计算一次。 而在宏的情况下，每次在程序中使用宏时都会评估参数。 在 C++ 中，内联可以定义在类内或类外。 而宏始终是在程序开始时定义的。 在 C++ 中，在类内部，短长度函数自动成为内联函数。 而宏是专门定义的。 内联不像宏那样广泛使用。 而宏被广泛使用。 内联不用于竞争性编程。 虽然宏在竞争性编程中非常有用。 内联函数以大括号结尾。 虽然宏没有由任何符号终止，但它由新行终止。 重载、隐藏、重写（覆盖）三者的区别 重载（overload），函数名相同，但是参数的类型、顺序、个数不同（只要可以分辨），重载不关心函数返回类型\n隐藏：是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。下图会报错，原因是子类隐藏了父类的函数\n什么是内存对齐？为什么进行内存对齐？ 现代计算机中内存都是按照 byte 划分的，从理论上讲对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它会要求这些数据的首地址的值是某个数 k（通常为 4 或 8）的倍数，这就是所谓的内存对齐； #include \u0026lt;iostream\u0026gt; struct { char y; int x; } s; int main() { std::cout \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; sizeof(char) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; sizeof(s) \u0026lt;\u0026lt; std::endl; return 0; } // 输出 // 4 // 1 // 8 内存对齐能够提高 cpu 读取数据的速度，减少访问数据的出错性。 堆和栈区别 堆和栈是两种重要的用于内存管理的数据结构，在编程中有着不同的用途。以下是它们的主要区别：\n管理方式： 堆（Heap）：在运行时动态分配和释放的内存空间。程序员负责申请和释放堆上的空间，如果忘记释放已使用的空间，可能会导致内存泄漏。\n栈（Stack）：由操作系统自动分配和释放，通常用于存储函数调用时的局部变量、返回地址等信息。当函数返回时，其在栈上的空间被自动回收。\n生命周期： 堆：堆上的内存生命周期由程序员控制，从手动申请开始，到手动释放结束。\n栈：栈上的内存生命周期与函数执行周期相同，函数每次调用时，相关的局部变量都会创建新的存储空间，函数结束时这些空间将被自动回收。\n分配大小： 堆：堆的大小受可用系统内存的限制，可以动态分配大块内存。\n栈：栈的大小在进程启动时由操作系统设定，且通常比堆小得多。如果尝试在栈上分配过多内存，可能会导致栈溢出。(ulimit 设置)\n访问速度： 堆：访问堆上的内存一般比访问栈上的内存慢，因为必须通过指针来访问堆中的内存。\n栈：访问栈内存更快，因为数据存储的位置是在编译时就确定了的，而且栈上的数据通常都存储在 CPU 的缓存中。\n总的来说，堆和栈各有优势，选择使用哪一个取决于具体需求，例如数据的生命周期、所需内存的大小等因素。\nC++常量在哪个区 函数内部的 const 变量和对象的 const 成员变量通常会被存放在栈上， 字符串字面量和 const 修饰的全局/静态变量会在常量区\n如果子类重写了父类的方法，在子类中如何访问 直接用父类显式调用\nclass Parent { public: void foo() { cout \u0026lt;\u0026lt; \u0026#34;This is the parent\u0026#39;s foo()\u0026#34; \u0026lt;\u0026lt; endl; } }; class Child : public Parent { public: void foo() { Parent::foo(); cout \u0026lt;\u0026lt; \u0026#34;This is the child\u0026#39;s foo()\u0026#34; \u0026lt;\u0026lt; endl; } }; 数组、指针的区别 概念\n数组是用于储存多个相同类型数据的集合。 数组名是首元素的地址。 指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在内存中的地址。 指针名指向了内存的首地址。 区别\n赋值：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝 存储方式 数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下标进行访问的，数组的存储空间，不是在静态区就是在栈上。 指针的存储空间不能确定。它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。 求 sizeof 数组所占存储空间的内存大小：sizeof（数组名）/sizeof（数据类型） 在 32 位平台下，无论指针的类型是什么，sizeof（指针名）都是 4，在 64 位平台下，无论指针的类型是什么，sizeof（指针名）都是 8。 初始化 // 数组 int a[5] = {0}; char b[] = \u0026#34;Hello\u0026#34;; // 按字符串初始化，大小为6 char c[] = {\u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;\\0\u0026#39;}; // 按字符初始化 int *arr = new int[10]; // 动态创建一维数组 // 指针 int *p = new int(0); // 指向对象的指针 delete p; int *p1 = new int[10]; // 指向数组的指针 delete[] p1; // 指向类的指针： string *p2 = new string; delete p2; int **pp = \u0026amp;p; // 指向指针的指针（二级指针） **pp = 10; 指针操作: 数组名的指针操作。数组指针也称指向一维数组的指针，亦称行指针。访问数组中第 i 行 j 列的一个元素，有几种操作方式：(p[i]+j)、((p+i)+j)、((p+i))[j]、p[i][j]。其中，优先级：()\u0026gt;[]\u0026gt;*。这几种操作方式都是合法的。 int a[3][4]; int(*p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组 p = a; //将该二维数组的首地址赋给p，也就是a[0]或\u0026amp;a[0][0] p++; //该语句执行过后，也就是p=p+1；p跨过行a[0][]指向了行a[1][] return 0; 指针变量的数组操作 char *str = \u0026#34;hello,douya!\u0026#34;; str[2] = \u0026#39;a\u0026#39;; *(str+2) = \u0026#39;b\u0026#39;; //这两种操作方式都是合法的。 extern \u0026lsquo;C\u0026rsquo; 的作用过程 extern \u0026ldquo;C\u0026rdquo; 是一种链接规范（Linkage Specification），在 C++代码中经常会看到，它用于解决 C++和 C 之间的函数名称混淆问题。\n在 C++中，函数支持重载，也就是说可以有多个同名但参数不同的函数。为了区分这些函数，C++在编译时会对函数名进行修饰（Name Mangling），生成一个独特的名字。而 C 语言并不支持函数重载，因此也就没有名字修饰的过程。\nC++中 struct 和 class 的区别 struct 默认继承和访问权限都是 public，而 class 默认继承和访问权限都是 private\nclass 可以定义类模板 \u0026lt;template typename\u0026gt;\n2、说说构造函数有几种，分别什么作用 默认构造函数 如果没写构造函数，就会生成一个无参数的构造函数\n拷贝构造函数 如果没写拷贝构造函数，系统自定生成一个，但是生成的是浅拷贝。参数是类的指针，\n两种情况：\nLine line1(10); Line line2 = line1; // 这里也调用了拷贝构造函数 移动构造函数\n指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。\nC++11 标准中为了满足用户使用左值初始化同类对象时也通过移动构造函数完成的需求，新引入了 std::move() 函数，它可以将左值强制转换成对应的右值，由此便可以使用移动构造函数。\nMove(Move\u0026amp;\u0026amp; source) : data{ source.data } { cout \u0026lt;\u0026lt; \u0026#34;Move Constructor for \u0026#34; \u0026lt;\u0026lt; *source.data \u0026lt;\u0026lt; endl; source.data = nullptr; } map 的迭代器和 vector 的迭代器有什么区别 map 是双向的，vector 可以随机访问\n常用的迭代器按功能强弱分为输入、输出、正向、双向、随机访问五种，这里只介绍常用的三种。\n正向迭代器。假设 p 是一个正向迭代器，则 p 支持以下操作：++p，p++，*p。此外，两个正向迭代器可以互相赋值，还可以用==和!=运算符进行比较。 双向迭代器。双向迭代器具有正向迭代器的全部功能。除此之外，若 p 是一个双向迭代器，则--p和p--都是有定义的。--p使得 p 朝和++p相反的方向移动。 随机访问迭代器。随机访问迭代器具有双向迭代器的全部功能。若 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作： p+=i：使得 p 往后移动 i 个元素。 p-=i：使得 p 往前移动 i 个元素。 p+i：返回 p 后面第 i 个元素的迭代器。 p-i：返回 p 前面第 i 个元素的迭代器。 p[i]：返回 p 后面第 i 个元素的引用。 vector 中 clear 函数内存释放的机制 vector.clear()并不会真正释放内存，clear 实际所做的是为 vector 中所保存的所有对象调用析构函数(如果有的话)，然后初始化 size 这些东西，让觉得把所有的对象清除了。\n介绍下纯虚函数 在 C++中，纯虚函数是一种特殊的虚函数。它在基类中声明, 并使用 = 0 来标记。这意味着该函数没有默认的实现。纯虚函数需要由任何直接或间接继承基类的派生类进行重写和实现。\nclass AbstractClass { public: virtual void pureVirtualFunction() = 0; // 纯虚函数 }; unordered_map 的底层结构 unordered_map 内部实现了一个哈希表（也叫散列表），通过把关键码值映射到 Hash 表中一个位置来访问记录，查找时间复杂度可达 O（1），其中在海量数据处理中有着广泛应用。因此，元素的排列顺序是无序的。\n类型转换 static_cast：这是用来进行各种不同类型之间的转换的最通用工具。它可以转换相关类型之间的值，例如将一个 double 转换为 int，或者将一个指针转换为相关类型的指针（即使该操作不安全）。静态转换不能去除表达式的常量性或者改变表达式的引用性。 double d = 3.14; int i = static_cast\u0026lt;int\u0026gt;(d); // i becomes 3 dynamic_cast：主要用于类层次结构中基类和派生类之间的向上转换和向下转换。如果转换不成功，则结果为 NULL。此外，它还能在转换过程中进行类型安全检查，所以使用起来比较安全。 BaseClass *b = new DerivedClass(); DerivedClass *d = dynamic_cast\u0026lt;DerivedClass*\u0026gt;(b); // safe downcast const_cast：这个运算符用来修改类型的 const 或 volatile 属性。比如，你可能有一个指向常量的指针，但是你需要传给一个需要非常量指针参数的函数。 const int a = 10; int* p = const_cast\u0026lt;int*\u0026gt;(\u0026amp;a); reinterpret_cast：这个转换运算符可以对任何类型的指针进行任意转换，也可以对任何整数进行转换。使用时必须非常谨慎，因为其产生的结果完全依赖于机器。当您需要将一种类型强制转换为另一种无关类型时，可能会使用这个转换。 int i = 10; int* ip = \u0026amp;i; char* cp = reinterpret_cast\u0026lt;char*\u0026gt;(ip); 每种转换方式都有其特定的用途，应根据实际需要选择合适的转换方式。\nB+树的优点 更适合磁盘或其他块存储操作： 在 B+ 树中，所有记录节点都保持在叶子节点，并且这些叶子节点形成了一个链接列表。这意味着对整个范围的搜索可以在磁盘上进行顺序访问，而不是随机访问，从而显著提高了效率。\n查询效率更稳定： 在 B 树中，由于非叶节点也包含关键字信息，因此可能需要深入到某个分支才能找到我们要的数据，也就是说查询效率是不平衡的。但在 B+树中，所有查询都要查找到叶子节点，查询路径长度相同，查询时间具有稳定性。\n插入和删除简单： 由于所有的数据值都在叶子节点，因此更改树（如插入和删除）将只影响叶节点，这种变化相对于 B 树来说更加容易处理。\n利于大范围的查询： B+ 树的叶子节点之间通过指针连接，必要时可以做到全表扫描。这在需要大范围的元素查找时，比 B 树具有更高的效率。\n每个节点存储更多的关键字： 在 B+树中，内部节点不保存数据信息，只保存关键字信息，因此每个节点可以保存更多的关键字，树的高度更低，有助于减少 I/O 次数。\n请你说下 fork 函数中父进程和子进程的内容差异 复制了父进程的内容： 当调用 fork() 时，子进程继承了父进程的代码、数据段、堆和栈等内存布局，打开的文件描述符，还有环境变量。\n新创建或者更改的内容： 子进程拥有自己唯一的进程 ID，其父进程 ID 设置为原进程的 ID。子进程不会继承父进程的子进程，所有待处理的信号都被清除。\n共享的内容： 虽然子进程拷贝了父进程的文件描述符，但这些文件描述符指向的是相同的文件表项，因此父子进程实际上是共享文件的。\n迭代器什么时候会失效？ 当容器调用erase()方法后，当前位置到容器末尾元素的所有迭代器全部失效。 当容器调用insert()方法后，当前位置到容器末尾元素的所有迭代器全部失效。 如果容器扩容，在其他地方重新又开辟了一块内存。原来容器底层的内存上所保存的迭代器全都失效了，如 vector pushback STL 有几大组件？ **容器：**一些封装数据结构的模板类，例如 vector 向量容器、list 列表容器等。 **算法：**STL 提供了非常多（大约 100 个）的数据结构算法，它们都被设计成一个个的模板函数，这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件 中，少部分位于头文件 中。 **迭代器：**在 c++STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂。 **函数对象：**如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。 **适配器：**可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。 **内存分配器：**为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。 c++从源代码文件到可执行文件的经历过程 预编译： 将所有的#define 删除，并且展开所有的宏定义 处理所有的条件预编译指令，如#if、#ifdef 处理#include 预编译指令，将被包含的文件插入到该预编译指令的位置。 过滤所有的注释 添加行号和文件名标识。 编译 词法分析：将源代码的字符序列分割成一系列的记号。 语法分析：对记号进行语法分析，产生语法树。 语义分析：判断表达式是否有意义。 代码优化： 目标代码生成：生成汇编代码。 目标代码优化： 汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。 链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接。 静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows 下以.lib 为后缀，Linux 下以.a 为后缀。 动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows 下以.dll 为后缀，Linux 下以.so 为后缀。 简述一下 C++11 中 Lambda 新特性 lambda 表达式可以方便的创建和定义匿名函数\n语法：\n[capture list] (params list) mutable exception-\u0026gt; return type { function body }\n各项具体含义如下\ncapture list：捕获外部变量列表 params list：形参列表 mutable 指示符：用来说用是否可以修改捕获的变量 exception：异常设定 return type：返回类型 function body：函数体 此外，我们还可以省略其中的某些成分来声明“不完整”的 Lambda 表达式，常见的有以下几种：\n序号 格式 1 [capture list] (params list) -\u0026gt; return type {function body} 2 [capture list] (params list) {function body} 3 [capture list] {function body} 其中：\n格式 1 声明了 const 类型的表达式，这种类型的表达式不能修改捕获列表中的值。 格式 2 省略了返回值类型，但编译器可以根据以下规则推断出 Lambda 表达式的返回类型： （1）：如果 function body 中存在 return 语句，则该 Lambda 表达式的返回类型由 return 语句的返回类型确定； （2）：如果 function body 中没有 return 语句，则返回值为 void 类型。 格式 3 中省略了参数列表，类似普通函数中的无参函数。 Lambda 表达式可以使用其可见范围内的外部变量，但必须明确声明（明确声明哪些外部变量可以被该 Lambda 表达式使用.\n#include\u0026lt;iostream\u0026gt; using namespace std; int main() { string captured_var = \u0026#34;captured\u0026#34;; auto fun = [captured_var](int a){ cout\u0026lt;\u0026lt;\u0026#34;hello\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;captured_var\u0026lt;\u0026lt;endl; }; fun(1); return 0; } 多态实现的原理 静态多态：编译器根据实参类型来推断调用哪个函数，如果有就调用，没有就报错； 动态多态：非虚函数总是在编译时根据调用该函数的对象，引用或指针的类型而确定。如果调用虚函数，则直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定或指针所指向的对象所属类型定义的版本。需要动态绑定条件： 1、虚函数。基类中必须有虚函数，派生类中必须重写虚函数。 2、通过基类类型的指针或引用来调用虚函数。 为什么构造函数不能是虚函数 1、 在对象创建时，虚函数的调用需要通过虚表实现，但是此时对象还没有创建完成，虚表也未被构造，因此无法调用虚函数。\n2、 此外，将构造函数声明为虚函数也没有意义，因为构造函数的目的是创建对象并初始化其状态，而虚函数的目的是在运行时通过对象的实际类型来调用其相应的实现。因此，构造函数不能是虚函数。\n虚函数和构造函数可以抛出异常吗？ 构造函数可以抛出异常，虚函数也可以抛出异常。在构造函数中，如果出现错误，例如初始化失败，可以抛出异常。这将使对象的创建失败，并允许调用方处理异常。同样，在析构函数中，如果出现错误，例如释放资源失败，也可以抛出异常。\n需要注意的是，在构造函数中抛出异常可能会导致对象没有完全构造完成就被销毁，因此可能需要手动管理资源以避免内存泄漏。在析构函数中抛出异常也可能会导致未能正确地清理对象，并可能会导致资源泄漏。因此，应该谨慎地在构造函数和析构函数中使用异常。\nC++11 新语法 智能指针 ，lambda 表达式，auto 自动推到类型，右值引用和移动语义，列表初始化, Range-based for loops), 智能指针，Lambda 表达式\n列表初始化的优点 更一致的语法 防止窄化转换（Narrowing conversions）如 int pi = 3.14 如果列表初始化 pi{3.14} 会报错 清楚地表示想要调用的构造函数 std::vector\u0026lt;int\u0026gt; v(5, 10); // 调用第一个构造函数，创建一个有5个元素，每个元素值为10的vector std::vector\u0026lt;int\u0026gt; w {5, 10}; // 调用第二个构造函数，创建一个包含两个元素5和10的vector C++ map 的底层 map 的底层是自平衡二叉树（红黑树） 1、每个节点要么是红色，要么是黑色 2、根节点是黑色，叶子结点是黑色（nil）节点 3、如果一个节点是红色，那么他的子节点是黑色 4、每个节点，从该节点到后代叶子结点中均包含相同数量的黑色节点\nC++ static 关键字 在 C++中，static 关键字可以用来修饰全局变量，也可以用来修饰类的成员变量和成员函数。当 static 关键字用来修饰全局变量时，它的含义和普通的全局变量有所不同。具体来说，static 关键字可以让这个变量只在该编译单元内，并且程序运行一直存在，在内存中被放在静态变量区。\n与普通的全局变量不同，使用 static 修饰的全局变量只能在定义它的编译单元中访问，其他的编译单元无法访问这个变量。这种方式可以避免全局变量在不同的编译单元中重名的问题，同时也可以提高程序的安全性和可维护性。\nC++中的构造函数和析构函数可以声明为 inline 吗 inline函数是一种特殊的函数，可以在调用处直接将其代码插入到程序中，从而避免函数调用的开销。在 C++中，可以使用inline关键字来声明一个函数为inline函数。通常情况下，适合使用inline函数的函数包括：函数体比较小；频繁调用的函数等。 构造函数和析构函数也可以声明为inline函数，但是通常情况下不建议这样做。因为构造函数和析构函数的执行通常比较复杂，包括调用父类构造函数、初始化成员变量、释放资源等操作，如果将它们声明为inline函数，会导致程序变得难以维护。此外，由于构造函数和析构函数的调用是自动的，因此与普通函数的调用开销相比，这种优化效果相对较小，因此一般不建议将构造函数和析构函数声明为inline函数。\nC++ 中 sizeof 数组 在 C++ 中，sizeof 数组返回的是整个数组所占用的内存空间的字节数。具体来说，如果数组是一个静态数组，那么 sizeof 数组返回的是该数组中所有元素所占用的总内存空间的字节数；如果数组是一个指针，则 sizeof 数组返回的是指针本身所占用的内存空间的字节数，而不是指针所指向的内存空间的字节数。\n下面是一些示例代码，用于说明 sizeof 数组的使用方法：\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { int arr[5] = {1, 2, 3, 4, 5}; // sizeof 数组返回的是数组中所有元素所占用的总内存空间的字节数 cout \u0026lt;\u0026lt; \u0026#34;sizeof(arr) = \u0026#34; \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; endl; // 输出 20，即 5 个 int 类型变量所占用的总内存空间的字节数 // sizeof 指针返回的是指针本身所占用的内存空间的字节数 int* ptr = arr; cout \u0026lt;\u0026lt; \u0026#34;sizeof(ptr) = \u0026#34; \u0026lt;\u0026lt; sizeof(ptr) \u0026lt;\u0026lt; endl; // 输出 8，即 64 位系统中指针所占用的内存空间的字节数 return 0; } 需要注意的是，sizeof 数组的结果与数组的元素类型和元素个数有关，而与数组的内容无关。例如，如果数组中包含了指针类型的元素，那么 sizeof 数组返回的结果将包含指针本身所占用的内存空间的字节数，而不仅仅是指针所指向的内存空间的字节数。\nc++中 strlen 和 sizeof 字符串 在 C++ 中，strlen 函数返回的是一个字符串的长度，即该字符串中字符的个数，但不包括字符串末尾的空字符(\u0026rsquo;\\0\u0026rsquo;)。而 sizeof 操作符返回的是一个字符串所占用的内存空间的字节数，包括字符串末尾的空字符(\u0026rsquo;\\0\u0026rsquo;)。\n下面是一些示例代码，用于说明 strlen 和 sizeof 字符串的使用方法：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int main() { char str1[] = \u0026#34;hello\u0026#34;; char str2[] = {\u0026#39;w\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;\\0\u0026#39;}; char* str3 = \u0026#34;C++\u0026#34;; // strlen 返回字符串的长度，不包括字符串末尾的空字符(\u0026#39;\\0\u0026#39;) cout \u0026lt;\u0026lt; \u0026#34;strlen(str1) = \u0026#34; \u0026lt;\u0026lt; strlen(str1) \u0026lt;\u0026lt; endl; // 输出 5，即 \u0026#34;hello\u0026#34; 中字符的个数 cout \u0026lt;\u0026lt; \u0026#34;strlen(str2) = \u0026#34; \u0026lt;\u0026lt; strlen(str2) \u0026lt;\u0026lt; endl; // 输出 5，即 \u0026#34;world\u0026#34; 中字符的个数 cout \u0026lt;\u0026lt; \u0026#34;strlen(str3) = \u0026#34; \u0026lt;\u0026lt; strlen(str3) \u0026lt;\u0026lt; endl; // 输出 3，即 \u0026#34;C++\u0026#34; 中字符的个数 // sizeof 返回字符串所占用的内存空间的字节数，包括字符串末尾的空字符(\u0026#39;\\0\u0026#39;) cout \u0026lt;\u0026lt; \u0026#34;sizeof(str1) = \u0026#34; \u0026lt;\u0026lt; sizeof(str1) \u0026lt;\u0026lt; endl; // 输出 6，即 \u0026#34;hello\u0026#34; 所占用的内存空间的字节数，包括 \u0026#39;\\0\u0026#39; cout \u0026lt;\u0026lt; \u0026#34;sizeof(str2) = \u0026#34; \u0026lt;\u0026lt; sizeof(str2) \u0026lt;\u0026lt; endl; // 输出 6，即 \u0026#34;world\u0026#34; 所占用的内存空间的字节数，包括 \u0026#39;\\0\u0026#39; cout \u0026lt;\u0026lt; \u0026#34;sizeof(str3) = \u0026#34; \u0026lt;\u0026lt; sizeof(str3) \u0026lt;\u0026lt; endl; // 输出 8，即指针所占用的内存空间的字节数 return 0; } 需要注意的是，如果字符串中包含了 Unicode 字符或多字节字符，strlen 函数返回的长度可能会不正确，因为它只会计算单字节字符的数量。此时可以使用 Unicode 编码或多字节编码相关的库函数来计算字符串的长度。另外，如果字符串中没有包含空字符(\u0026rsquo;\\0\u0026rsquo;)，那么 sizeof 字符串返回的结果将不包括空字符所占用的字节数。\n设计模式 设计模式是一种被经过验证的、被证明在特定情况下可行的解决问题的方法。常见的设计模式有以下几种：\n工厂模式（Factory Pattern）：用于创建对象的模式，通过工厂类封装对象的创建过程，将对象的创建和使用分离开来。\n单例模式（Singleton Pattern）：用于保证一个类只有一个实例，通过私有化构造函数、提供静态方法等方式实现。\n代理模式（Proxy Pattern）：用于控制对对象的访问，通过代理对象对真实对象的访问进行控制和增强。\n观察者模式（Observer Pattern）：用于对象间的一对多依赖关系，当一个对象状态发生改变时，它的所有依赖者都会收到通知并自动更新。\n装饰器模式（Decorator Pattern）：用于动态地给一个对象添加一些额外的功能，通过嵌套多个装饰器实现功能的叠加。\n策略模式（Strategy Pattern）：用于定义一系列算法，将每个算法都封装起来，并使它们之间可以互换。\n模板方法模式（Template Method Pattern）：用于定义一个算法框架，将具体的实现留给子类来实现。\n适配器模式（Adapter Pattern）：用于将一个类的接口转换成客户端所期望的另一个接口，使得原本不兼容的接口可以一起工作。\n迭代器模式（Iterator Pattern）：用于遍历集合或容器中的元素，将遍历算法与集合本身分离开来，从而提高代码的可复用性和可维护性。\n建造者模式（Builder Pattern）：用于将一个复杂的对象的构建过程和它的表示分离开来，使同样的构建过程可以创建不同的表示。\nmalloc 底层实现 malloc 函数的内部实现通常是通过维护一个空闲链表来管理可用的内存块。当调用 malloc 函数时，它会遍历空闲链表，查找一个大小足够的内存块，并返回该内存块的起始地址。如果没有足够大的内存块，malloc 函数会向操作系统申请一段新的内存空间，并将其添加到空闲链表中。\n当调用 free 函数释放内存时，malloc 函数会将该内存块添加到空闲链表中，并进行内存合并操作，将相邻的空闲内存块合并成一个更大的内存块，以便于后续的内存分配。\nplacement new placement new 是一种 C++中的特殊形式的 new 操作符，它可以在已经分配好的内存块上构造一个对象，而不需要再分配新的内存空间。\n在 C++中，通常使用 new 操作符来动态分配内存并构造对象。new 操作符会先调用 operator new 函数分配内存，然后调用对象的构造函数来初始化对象。而 placement new 可以直接在已经分配好的内存块上调用对象的构造函数来初始化对象，而不需要再分配新的内存空间。\nplacement new 的语法如下：\nvoid* operator new(size_t size, void* ptr); 其中，第一个参数表示要分配的内存块大小，第二个参数表示指向已经分配好的内存块的指针。使用 placement new 时，需要在已经分配好的内存块上调用构造函数来初始化对象，示例如下：\nvoid* mem = malloc(sizeof(MyClass)); // 分配内存 MyClass* obj = new(mem) MyClass(); // 在内存块上构造对象 在上面的示例中，我们首先使用 malloc 函数分配了一个大小为 MyClass 的内存块，然后使用 placement new 在这个内存块上构造了一个 MyClass 对象。需要注意的是，使用 placement new 时，需要将分配的内存地址作为构造函数的参数传递给 new，这样构造函数就会在这个内存块上进行初始化，而不是分配一个新的内存块。\n需要注意的是，使用 placement new 构造对象时，需要手动调用对象的析构函数来释放对象占用的资源，示例如下：\nobj-\u0026gt;~MyClass(); // 手动调用析构函数释放资源 free(mem); // 释放内存 总之，placement new 是一种特殊形式的 new 操作符，可以在已经分配好的内存块上构造对象，而不需要再分配新的内存空间。\n动态链接中的全局作用域表 在程序链接过程中，全局偏移表（Global Offset Table，简称 GOT）是动态链接的重要组成部分。GOT 主要用于实现位置无关代码（Position Independent Code，简称 PIC），这在动态链接库（Dynamic Shared Object，简称 DSO）或者 Position Independent Executable（简称 PIE）中非常重要。\n全局偏移表的主要作用如下：\n存储全局数据的地址： 对于动态链接库来说，由于其在内存中的位置在加载时才能确定，因此不能在编译时直接使用绝对地址访问全局数据。为解决这个问题，编译器会生成一张全局偏移表来存储所有全局数据的地址，然后通过相对于这张表的偏移来访问具体的数据。\n支持动态函数调用： 全局偏移表还可以支持动态函数调用。程序在运行时，如果需要调用一个动态链接库中的函数，实际上会先查找全局偏移表，根据表中存储的函数地址来进行函数调用。具体的函数地址在程序初次调用时由动态链接器填入。\n总的来说，全局偏移表是实现动态链接和位置无关代码的重要技术手段，它让我们可以在运行时动态地确定和修改全局数据和函数的地址。\n正则表达式 regex_match(string, regex(\u0026ldquo;pattern\u0026rdquo;)) 返回 bool 值，代表是否匹配成功；\n虚继承是如何实现的 虚基类指针： 每个实例对象中都会有一个指向虚基类的指针（通常位于对象内存布局的开始处），这就是虚基类指针。\n虚基类表： 虚基类表是一个保存了虚基类相关信息的表格，包括虚基类与派生类的偏移量等信息。\n访问虚基类成员： 当我们访问虚基类的成员时，首先会通过虚基类指针找到虚基类表，然后通过虚基类表找到虚基类成员相对于派生类的偏移，最后根据这个偏移找到虚基类成员。\n说下红黑树 红黑树是一种自平衡二叉查找树，它是一种二叉树，其中每个节点都带有一个额外的信息：节点的颜色，可以是红色或黑色。\n红黑树的性质如下：\n每个节点要么是红色，要么是黑色。 根节点是黑色的。 每个叶子节点（NIL 节点，空节点）都是黑色的。 如果一个节点是红色的，则它的子节点必须是黑色的。 从任意一个节点到其每个叶子节点的所有路径都包含相同数目的黑色节点 为什么用红黑树不用 AVL 树 Map 使用红黑树而不是 AVL 树的原因主要是在于红黑树相比于 AVL 树有更好的性能表现，尤其是在插入和删除操作较为频繁的情况下。 红黑树和 AVL 树都是自平衡二叉查找树，它们都可以保证在最坏情况下的时间复杂度为 O(log n)，但是它们的平衡策略不同。AVL 树保证左右子树的高度差不超过 1，而红黑树则保证黑色节点的高度差不超过 2。 相比于 AVL 树，红黑树的平衡性要稍微差一些，但是它的旋转和变色操作更少，因此在插入和删除操作较为频繁的情况下，红黑树的性能更好。此外，红黑树的实现也更加简单，易于理解和实现。 因此，Map 使用红黑树而不是 AVL 树，主要是考虑到红黑树在实际应用中具有更好的性能表现和更简单的实现方式。\n宏定义和 inline inline 在编译期间展开，而宏在预编译时进行文本替换 inline 标识的是一个函数，采用的是参数传递，而宏定义的是文本替换的一种方式 内联函数会进行类型安全检查、语法判断，而宏在文本替换后可能会导致编译错误 宏是无类型的，将其用于任何类型，运算都是有意义的，内联函数则需要通过创建模板使得函数独立于类型 #ifdef __cplusplus #ifdef __cplusplus 是 C++中的预处理指令，用于检查是否在 C++ 环境中编译代码。\n这个预处理指令的作用主要是解决 C 语言和 C++ 语言之间的兼容性问题。因为 C++ 是 C 的超集，C++ 编译器能够理解 C 代码，但是 C 编译器并不能理解所有 C++ 代码。所以如果你正在编写一个既需要在 C 环境中编译，也需要在 C++ 环境中编译的头文件，就需要用到 #ifdef __cplusplus。\n其使用方式一般如下：\n#ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif // C code here #ifdef __cplusplus } #endif 上述代码中，extern \u0026ldquo;C\u0026rdquo; 告诉 C++ 编译器按照 C 语言的规则来编译和链接该部分的代码。这样做的好处是可以防止 C++ 编译器将函数名进行名字修饰（mangle），使得在链接时能够找到正确的函数实现。\n当编译器遇到 #ifdef __cplusplus 时，如果当前环境是 C++，那么它会处理 #ifdef 和 #endif 之间的内容。否则，它会忽略这部分内容。\nexplicit 作用 explicit 关键字用于防止 C++ 编译器执行隐式转换构造函数。使用 explicit 关键字定义的构造函数只能显式地进行类型转换，不能在隐式转换的情况下被调用。\nclass MyClass { public: operator int() const { return m_x; } private: int m_x; }; int main() { int x = MyClass(42); // 编译错误：无法将 MyClass 隐式转换为 int int y = static_cast\u0026lt;int\u0026gt;(MyClass(42)); // 显式类型转换 return 0; } delete 构造函数有什么用 将构造函数和析构函数设置为 delete 可以在编译时防止对象的创建和销毁，这可以用于以下几种情况：\n禁止对象的拷贝和移动 如果一个类需要禁止对象的拷贝和移动，可以将其复制构造函数、移动构造函数、复制赋值运算符和移动赋值运算符都设置为 delete。这样，当其他代码试图拷贝或移动对象时，编译器将会产生错误。\n实现单例模式 如果一个类只需要一个对象实例，可以将其构造函数设置为 private 或 protected，并将其复制构造函数、移动构造函数、复制赋值运算符和移动赋值运算符都设置为 delete。然后，在类中定义一个静态成员变量和一个静态方法来获取唯一的对象实例。这样，其他代码就无法创建多个对象实例。\nC++写一个单例模式 class Singleton { public: // 获取单例对象的全局访问点 static Singleton\u0026amp; getInstance() { static Singleton instance; return instance; } // 禁止拷贝构造函数和赋值运算符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; // 单例类的其他方法和属性 void doSomething() { // ... } private: // 私有构造函数，禁止外部实例化 Singleton() { // ... } // 私有析构函数，禁止外部删除实例 ~Singleton() { // ... } }; 枚举和宏定义 枚举和宏定义都是 C/C++中定义常量的方式，但它们之间有以下的异同：\n异同点：\n都可以用于定义常量，可以提高程序的可读性和可维护性。\n都可以用于定义常量字符串等复杂类型。\n都可以在程序中多次使用。\n不同点：\n宏定义是在预处理阶段进行替换，是一种文本替换技术，而枚举是在编译阶段进行处理，是一种类型安全的常量定义方式。\n宏定义没有类型检查，容易出现类型错误，而枚举可以避免这种问题。\n宏定义可以定义任何类型的常量，而枚举只能定义整型常量。\n宏定义可以被重新定义，而枚举不可以。\n枚举可以用于 switch 语句中，使得代码更加简洁易读。\n综上所述，枚举和宏定义都可以用于定义常量，但是枚举具有类型安全和可读性好的特点，而宏定义则更加灵活，可以定义任何类型的常量。在实际开发中，应该根据具体情况选择使用哪种方式，遵循代码规范和设计原则，提高程序的可维护性和可读性。\ninline 的作用 ，它提示编译器将函数体内的代码直接插入到调用该函数的地方，而不是通过函数调用的方式执行。这样做可以减少函数调用的开销，提高程序的执行效率。 inline 关键字只是向编译器发出提示，是否将函数作为内联函数实现，最终是否内联由编译器决定。\ninline 函数必须在头文件中定义，否则编译器无法在调用处将函数代码插入到程序中。\ninline 函数不能包含复杂的控制语句，如循环或递归，否则会导致内联函数的代码量过大，反而会降低程序执行效率。\n对于虚函数和递归函数，即使使用 inline 关键字，编译器也不会将其内联。\ninline 函数中不能使用 static 关键字，因为 static 表示函数仅可在当前文件中使用，而 inline 函数需要在多个文件中共享。\nunique_ptr 底层实现 本质上就是 RAII，注意要把拷贝构造函数和移动构造函数删除\ntemplate \u0026lt;typename T\u0026gt; class unique_ptr { public: explicit unique_ptr(T* ptr = nullptr) : ptr_(ptr) {} ~unique_ptr() { delete ptr_; } unique_ptr(const unique_ptr\u0026amp;) = delete; // 禁止复制构造 unique_ptr\u0026amp; operator=(const unique_ptr\u0026amp;) = delete; // 禁止赋值操作 unique_ptr(unique_ptr\u0026amp;\u0026amp; u) noexcept { // 移动构造函数 ptr_ = u.release(); } unique_ptr\u0026amp; operator=(unique_ptr\u0026amp;\u0026amp; u) noexcept { // 移动赋值运算符 reset(u.release()); return *this; } T* get() const noexcept { return ptr_; } T* release() noexcept { // 释放所有权 T* result = ptr_; ptr_ = nullptr; return result; } void reset(T* p = nullptr) noexcept { // 重置内部指针 delete ptr_; ptr_ = p; } T\u0026amp; operator*() const { return *ptr_; } T* operator-\u0026gt;() const { return ptr_; } private: T* ptr_; }; noexcept 的作用 noexcept 是 C++11 中引入的一个关键字，用于表示函数是否会抛出异常。具体来说，如果一个函数被声明为 noexcept，则表明该函数不会抛出任何异常，包括 C++ 异常和操作系统异常。\nnoexcept 关键字主要有以下作用：\n优化代码性能：noexcept 声明可以让编译器针对不抛出异常的函数进行优化，从而提高代码的性能。\n提高代码可靠性：使用 noexcept 声明可以让代码更加可靠，因为调用 noexcept 函数不会抛出异常，可以避免程序异常终止等问题。\n改善代码风格：使用 noexcept 声明可以使代码更加简洁，更容易理解，因为它明确了函数的异常保证，可以避免需要额外的代码来处理异常的情况。\n需要注意的是，如果一个 noexcept 函数在运行时抛出异常，将会导致 std::terminate 函数被调用，从而导致程序终止。\nC++内存模型 栈区（Stack）：由编译器自动分配和释放，存储局部变量、函数参数和返回地址等信息。栈区的内存分配和释放速度非常快，但是大小有限，通常只能存储较小的数据。\n堆区（Heap）：由程序员手动分配和释放，存储动态分配的内存，大小不受限制。堆区的内存分配和释放速度较慢，且容易产生内存泄漏和内存碎片等问题。\n全局区（Global）：存储全局变量和静态变量，程序启动时分配，程序结束时释放。全局区的内存分配和释放速度较快，但是容易产生命名冲突和数据共享等问题。\n常量区（Constant）：存储常量字符串和全局常量等，不允许修改。常量区的内存分配和释放由编译器自动处理，通常位于代码段或只读数据段。\n代码区（Code）：存储程序的可执行代码，由操作系统加载到内存中执行。代码区的内存分配和释放由操作系统管理，通常位于只读代码段。\n模板可以使用选虚函数吗，为什么 可以\n右值引用解决了什么问题 右值引用是 C++11 引入的一种新的引用类型，主要目的是支持移动语义（Move Semantics）和完美转发（Perfect Forwarding）。在 C++11 之前，我们只有左值引用。\n左值（Lvalue）：它们是可以从内存中寻址的对象，或者拥有名字的对象，比如变量。 右值（Rvalue）：它们是临时对象，或者不拥有名字的对象，比如返回值、字面量等。 在 C++11 之前，引用都是指向左值的，而在 C++11 中，新增了右值引用，能够引用一个右值。右值引用使用两个 ampersands（\u0026amp;\u0026amp;）表示：\nint\u0026amp;\u0026amp; rvalue_ref = 1; 这个特性非常重要，因为它允许我们修改临时对象。此外，使用右值引用，我们可以将资源（如内存或文件句柄）从一个对象安全地\u0026#34;移动\u0026#34;到另一个对象，而无需进行昂贵的深拷贝操作。这对于大型对象或者只能移动的资源来说，性能提升极大。 一个最常见的例子就是 std::move，它可以将一个左值转换为右值引用，以便进行移动操作而非拷贝操作：\nstd::string str1 = \u0026#34;Hello, World.\u0026#34;; std::string str2 = std::move(str1); // 将 str1 的内容\u0026#34;移动\u0026#34;到 str2 上述代码中，str1的内容被移动到str2，而不是复制过去。这样，str2现在拥有原先str1的内存，str1则处于一个有效但未定义的状态。这样做的好处就是避免了不必要的内存分配和释放操作，提高了程序的效率。 完美转发 \u0026ldquo;完美转发\u0026quot;是 C++11 中引入的一种新特性，它能够在函数模板中精确地保持参数的类型。也就是说，它可以将参数以原始形式（包括全部 cv 限定符和引用类型）传递给另一个函数。\n在早期的 C++版本中，所有的参数都是按值传递的。这意味着在函数调用过程中，参数可能会被拷贝，且不能保持其原有的类型特性，例如是否为 const、是否为引用等。这就是所谓的\u0026quot;不完美转发\u0026rdquo;。\n然而，在 C++11 中，引入了右值引用和 std::forward 函数，使我们可以实现\u0026quot;完美转发\u0026quot;。\n举个例子：\ntemplate \u0026lt;typename T\u0026gt; void wrapper(T\u0026amp;\u0026amp; arg) { // 完美转发arg到foo函数 foo(std::forward\u0026lt;T\u0026gt;(arg)); } 在本例中，wrapper 函数接收一个万能引用（universal reference，指的是 T\u0026amp;\u0026amp;类型的参数，由 Scott Meyers 首次提出这个术语），并将其完美转发给 foo 函数。不论我们传递给 wrapper 函数的参数是左值还是右值，它们都会以原样的方式传递给 foo 函数。\n这样做的优点是：\n避免不必要的对象拷贝，提高程序效率。 保留参数的类型信息，例如是否为 const 或引用等，使得行为更加符合预期。 这就是所谓的\u0026quot;完美转发\u0026quot;。\n智能指针的缺点 虽然智能指针在管理动态内存方面有很多优点，但是它们仍然存在一些弊端，包括：\n对象所有权的问题 智能指针的设计初衷是为了解决内存管理的问题，但是智能指针本身也具有所有权的概念。在使用智能指针时，需要明确对象的所有权关系，否则会出现对象被多个智能指针所管理的情况，导致内存泄漏或多次释放同一块内存的问题。\n循环引用的问题 智能指针可能导致循环引用的问题。如果两个或多个对象之间相互引用，并且它们都使用智能指针来管理内存，就会导致循环引用的问题。这种情况下，智能指针可能无法正确释放内存，从而导致内存泄漏的问题。\n不支持数组的管理 智能指针不支持数组的管理。虽然可以使用 std::unique_ptr\u0026lt;T[]\u0026gt; 来管理动态分配的数组，但是 std::unique_ptr\u0026lt;T[]\u0026gt; 并不是标准智能指针的一种，它需要使用自定义删除器来释放数组的内存。\n性能问题 智能指针的实现需要使用额外的内存和计算时间，可能会导致一定的性能开销。此外，在多线程环境下，智能指针的引用计数可能需要使用原子操作，也会对性能产生一定的影响。\n综上所述，虽然智能指针在管理动态内存方面有很多优点，但是它们也存在一些弊端。在使用智能指针时，需要注意对象的所有权关系、循环引用的问题、不支持数组的管理和性能问题等方面的考虑。\n说一下 inline inline 是 C++ 中的一个关键字，用于修饰函数，表示该函数可以被编译器内联展开。\n函数内联是一种编译器优化技术，它的作用是将函数调用的过程转化为函数体的直接执行，从而减少函数调用的开销，提高程序的执行效率。具体来说，编译器会将内联函数的代码复制到每个调用该函数的地方，从而避免了函数调用的开销，减少了代码的跳转次数，提高了程序的运行速度。\n使用 inline 关键字修饰函数时，编译器并不一定会将函数内联展开，具体是否内联展开取决于编译器的优化策略和代码的具体情况。通常情况下，编译器会对一些简单的函数进行内联展开，如只包含一行代码的函数或者只有几行代码的函数。\n需要注意的是，使用 inline 关键字修饰函数时，应该遵循以下几点原则：\n内联函数的代码应该比较简单，不要包含过多的复杂逻辑和控制语句，否则会导致代码膨胀，反而降低程序的执行效率。\n内联函数的代码应该放在头文件中，以便编译器能够在每个调用该函数的地方进行内联展开。\n在某些情况下，使用 inline 关键字并不能提高程序的执行效率，甚至会降低程序的性能。因此，在使用 inline 关键字时，应该根据具体情况进行判断和选择。\n综上所述，inline 是 C++ 中的一个关键字，用于修饰函数，表示该函数可以被编译器内联展开，从而提高程序的执行效率。在使用 inline 关键字时，应该遵循一定的原则和注意事项，以保证程序的正确性和可靠性。\ninline 和宏定义的区别 内联函数在编译时展开，可以做一些类型检测处理。宏在预编译时展开；内联函数直接嵌入到目标代码中，宏是简单的做文本替换。 C++中引入了类及类的访问控制，**在涉及到类的保护成员和私有成员就不能用宏定义来操作 ** 哈希冲突解决办法 哈希处理冲突的方式主要有以下几种：\n链地址法（Chaining）：将哈希表中冲突的元素存储在同一个链表中，每个链表节点存储一个元素。当插入新元素时，如果发生冲突，则将新元素添加到链表的末尾。当查找元素时，首先根据哈希值找到对应的链表，然后在链表中顺序查找目标元素。链地址法是一种简单有效的哈希冲突解决方法，适用于元素数量较多的情况。\n开放地址法（Open Addressing）：将所有元素都存储在哈希表中，当发生冲突时，根据特定的规则查找哈希表中下一个未被占用的位置，直到找到合适的位置为止。开放地址法可以避免链表操作的开销，但需要保证哈希表中至少留有一部分空间，否则容易出现死循环。常用的开放地址法包括线性探测、二次探测和双重哈希等。\n再哈希法（Rehashing）：在哈希表中发生冲突时，使用第二个哈希函数重新计算哈希值，直到找到一个空槽为止。再哈希法可以避免链表操作和二次探测的缺点，但需要使用多个哈希函数，增加了计算的复杂度。\n建立公共溢出区（Overflow Area）：将哈希表中冲突的元素存储在一个公共的溢出区中，当插入新元素时，如果发生冲突，则将新元素添加到溢出区中。当查找元素时，首先根据哈希值找到对应的槽位，如果槽位为空，则表明目标元素不存在；如果槽位有元素，则需要在哈希表中查找目标元素，如果没有找到，则需要在溢出区中查找。\n以上是主要的哈希处理冲突的方式。不同的方式适用于不同的场景，开放地址法适合元素数量较少的情况，链地址法适合元素数量较多的情况，再哈希法和建立公共溢出区则是一些特殊场景下的解决方案\n虚函数可以 inline 吗 虚函数可以被声明为 inline 函数，但是它们的行为与非虚函数的 inline 函数不同。\n当一个函数被声明为 inline 时，编译器会尝试将函数的代码插入到每个调用该函数的地方，从而避免函数调用的开销，提高程序的执行效率。然而，虚函数的动态绑定特性使得编译器无法在编译时确定调用哪个函数，因此它们不能像非虚函数一样被完全展开。\n在某些情况下，编译器可能会将虚函数的调用转换为静态绑定，从而实现类似于 inline 函数的效果。这种情况下，虚函数会被完全展开，并且调用该函数的代码会被替换为函数的实际代码。但是，这种转换需要满足一定的条件，例如函数必须是非虚函数，或者编译器必须能够确定调用的对象类型等。\n因此，虚函数可以被声明为 inline 函数，但是它们的行为与非虚函数的 inline 函数不同，而且是否能够实现真正的 inline 取决于具体的实现和调用方式。\n手撕代码：写一个 string 类 以下是一个简单的 string 类的实现，包括构造函数、析构函数、拷贝构造函数、赋值运算符、下标运算符、比较运算符、长度函数和字符串连接函数。\n好的，下面是一个简单的 String 类的实现，包括默认构造函数、拷贝构造函数、移动构造函数、析构函数和 operator= 运算符的实现。 #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; class String { public: // 默认构造函数 String() : data_(nullptr), size_(0), capacity_(0) {} // 拷贝构造函数 String(const String\u0026amp; other) : data_(nullptr), size_(0), capacity_(0) { reserve(other.size_); std::memcpy(data_, other.data_, other.size_ + 1); size_ = other.size_; } // 移动构造函数 String(String\u0026amp;\u0026amp; other) noexcept : data_(other.data_), size_(other.size_), capacity_(other.capacity_) { other.data_ = nullptr; other.size_ = 0; other.capacity_ = 0; } // 析构函数 ~String() { if (data_) { delete[] data_; } } // operator= 运算符 String\u0026amp; operator=(const String\u0026amp; other) { if (this != \u0026amp;other) { reserve(other.size_); std::memcpy(data_, other.data_, other.size_ + 1); size_ = other.size_; } return *this; } // 获取字符串长度 size_t size() const { return size_; } // 判断是否为空 bool empty() const { return size_ == 0; } // 添加字符 void push_back(char c) { if (size_ + 1 \u0026gt; capacity_) { reserve(size_ + 1); } data_[size_] = c; size_++; data_[size_] = \u0026#39;\\0\u0026#39;; } // 清空字符串 void clear() { delete[] data_; data_ = nullptr; size_ = 0; capacity_ = 0; } private: char* data_; size_t size_; size_t capacity_; // 分配内存 void reserve(size_t new_capacity) { if (new_capacity \u0026gt; capacity_) { char* new_data = new char[new_capacity + 1]; if (data_) { std::memcpy(new_data, data_, size_ + 1); delete[] data_; } data_ = new_data; capacity_ = new_capacity; } } }; int main() { String s1; // 调用默认构造函数 std::cout \u0026lt;\u0026lt; \u0026#34;s1: \u0026#34; \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // s1: 0 String s2 = \u0026#34;Hello, world!\u0026#34;; // 调用拷贝构造函数 std::cout \u0026lt;\u0026lt; \u0026#34;s2: \u0026#34; \u0026lt;\u0026lt; s2.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // s2: 13 String s3 = std::move(s2); // 调用移动构造函数 std::cout \u0026lt;\u0026lt; \u0026#34;s3: \u0026#34; \u0026lt;\u0026lt; s3.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // s3: 13 std::cout \u0026lt;\u0026lt; \u0026#34;s2: \u0026#34; \u0026lt;\u0026lt; s2.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // s2: 0 s1 = s3; // 调用 operator= 运算符 std::cout \u0026lt;\u0026lt; \u0026#34;s1: \u0026#34; \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // s1: 13 s1.push_back(\u0026#39;!\u0026#39;); std::cout \u0026lt;\u0026lt; \u0026#34;s1: \u0026#34; \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // s1: 14 s1.clear(); std::cout \u0026lt;\u0026lt; \u0026#34;s1: \u0026#34; \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // s1: 0 return 0; } 在移动构造函数中，我们将 other 对象的指针、长度和容量直接转移给新对象，然后将 other 对象的指针、长度和容量置为 0 或 nullptr，以防止其析构时重复释放指针所指的内存。\ncapacity 是指 String 对象当前已分配的内存空间大小，它与 size 是两个不同的概念。\nsize 表示 String 对象中实际存储的字符数，它不包括最后的空字符（\u0026rsquo;\\0\u0026rsquo;），而 capacity 则表示 String 对象当前已经分配的内存空间大小（以字节为单位），它是为了在添加字符时避免频繁分配内存空间，从而提高程序的效率。\n例如，在添加字符之前，如果 String 对象已经分配了足够的内存空间，那么就可以直接在已有的内存空间中添加新字符，而不必重新分配内存空间。这个过程就是通过 reserve() 函数实现的。当需要添加的字符数超过当前的 capacity 时，reserve() 函数会重新分配更大的内存空间，并将原来的数据复制到新的内存空间中。\n在 String 类中，我们跟踪 capacity 的主要目的是为了实现 push_back() 函数，该函数用于向 String 对象的末尾添加一个字符。当添加的字符数超过当前的 capacity 时，它会自动重新分配更大的内存空间，从而避免了频繁的内存分配和释放操作。\ni++和++i的区别，哪个快？ ++i 快点 i++ 和 ++i 对于基本类型（如 int，float 等）来说，在性能上没有明显的区别。现代编译器会对这种情况进行优化，使得两者的运行速度几乎相同。\n但是当我们使用复杂类型（如迭代器，自定义类等）时，可能就会有不同了 在这样的情况下：\n对于前缀递增 ++it，它将 it 加一，并返回增加后的值。只涉及一次操作。 对于后缀递增 it++，它首先需要创建一个临时的原始 it 的副本，然后增加 it，最后返回原始副本的值。涉及两次操作。 因此，对于复杂类型，通常 ++i 会比 i++ 更快，因为它避免了创建临时对象。\n但是，请注意，大多数现代编译器对于这类代码进行了高度优化，因此在实际使用中，您可能看不到任何显著的性能差异。除非你正在编写对性能极度敏感的代码，否则在选择使用 i++ 还是 ++i 时，可读性和代码清晰度应该是更重要的考虑因素。\n// 前缀形式： int\u0026amp; int::operator++() //这里返回的是一个引用形式，就是说函数返回值也可以作为一个左值使用 {//函数本身无参，意味着是在自身空间内增加1的 *this += 1; // 增加 return *this; // 取回值 } //后缀形式: const int int::operator++(int) //函数返回值是一个非左值型的，与前缀形式的差别所在。 {//函数带参，说明有另外的空间开辟 int oldValue = *this; // 取回值 ++(*this); // 增加 return oldValue; // 返回被取回的值 } 一个是返回引用，另一个返回值\nvector 的 clear 在 C++ 中，可以使用 vector 的 clear() 成员函数清除其内部存储的元素。调用 clear() 后，vector 的大小将变为 0，但是内存空间并不会被释放，仍然保留在 vector 中以备下次使用。其实也就是 size 会变成 0，但是 capacity 不变\n不允许使用 auto 的场景 不能作为函数参数 类的非静态成员变量的初始化 定义数组 推导定义数组 constexpr 的作用 编译时求值 好处：\n安全性增加 。通过编译时检查避免运行时错误产生。 效率提高 。可以在编译时完成复杂的构造,而无需在运行时再次构造。 gcc 优化的几个等级 gcc 中指定优化级别的参数有：-O0、-O1、-O2、-O3、-Og、-Os、-Ofast。\n在编译时，如果没有指定上面的任何优化参数，则默认为 -O0，即没有优化。\n参数 -O1、-O2、-O3 中，随着数字变大，代码的优化程度也越高，不过这在某种意义上来说，也是以牺牲程序的可调试性为代价的。\n参数 -Og 是在 -O1 的基础上，去掉了那些影响调试的优化，所以如果最终是为了调试程序，可以使用这个参数。不过光有这个参数也是不行的，这个参数只是告诉编译器，编译后的代码不要影响调试，但调试信息的生成还是靠 -g 参数的。\n参数 -Os 是在 -O2 的基础上，去掉了那些会导致最终可执行程序增大的优化，如果想要更小的可执行程序，可选择这个参数。\n参数 -Ofast 是在 -O3 的基础上，添加了一些非常规优化，这些优化是通过打破一些国际标准（比如一些数学函数的实现标准）来实现的，所以一般不推荐使用该参数\n尾递归 主要是空间复杂度 尾递归是指递归函数的递归调用语句是函数中的最后一条语句。\n尾递归能够优化是因为:\n尾递归不需要保存调用帧(call stack frame),只需要覆盖当前帧就可以了。\n所以尾递归可以被编译器优化成迭代,空间复杂度可以降到 O(1)。\n非尾递归需要保存每一层的调用帧,空间复杂度是 O(n),n 是递归深度。\n举个例子:\n尾递归:\ndef factorial(n, acc=1): if n == 0: return acc return factorial(n-1, n*acc) 非尾递归:\ndef factorial(n): if n == 0: return 1 return n * factorial(n-1) # 这里还需要有x上一个n，不是单纯只有递归函数 第一个例子是尾递归,可以被优化。第二个不是,需要保存每一层 factorial 的调用帧,空间复杂度是 O(n)。\n所以尾递归对于递归深度很大的函数来说很有用,可以避免栈溢出。许多函数式语言的编译器会自动优化尾递归。\n写一个 shared_ptr template \u0026lt;class T\u0026gt; class SmartPoint { private: T* ptr; // 指向动态分配对象的原始指针 std::size_t* refCount; // 维护指针引用计数 void dispose() { // 释放函数，处理内存释放逻辑 --(*refCount); if (*refCount == 0) { delete ptr; delete refCount; } } public: // 构造函数 explicit SmartPoint(T* p = nullptr) : ptr(p), refCount(new std::size_t(1)) {} // 拷贝构造函数 SmartPoint(const SmartPoint\u0026amp; sp) : ptr(sp.ptr), refCount(sp.refCount) { ++(*refCount); } // 赋值操作符重载 SmartPoint\u0026amp; operator=(const SmartPoint\u0026amp; sp) { // 自我赋值检查 if (this != \u0026amp;sp) { dispose(); // 使用封装的释放函数 ptr = sp.ptr; refCount = sp.refCount; ++(*refCount); } return *this; } // 解引用操作符重载 T\u0026amp; operator*() const { return *ptr; } // 间接访问成员操作符重载 T* operator-\u0026gt;() const { return ptr; } // 析构函数 ~SmartPoint() { dispose(); // 使用封装的释放函数 } }; 什么是野指针 野指针是一种编程术语，主要出现在 C/C++等允许直接操作内存的编程语言中。\n野指针具体指的是：\n已经释放（delete 或 free）但没有置为 nullptr 的指针。 未初始化的指针。 如果对这样的指针进行解引用或者访问，就可能导致程序运行错误，例如段错误（segmentation fault），甚至修改系统的关键数据，导致系统崩溃。因此，处理指针时要特别小心，尤其是在使用完毕后记得将指针置为 nullptr，以避免成为野指针。\n下面是一个简单的例子：\nint* ptr = new int(10); // 分配内存并初始化 delete ptr; // 释放内存 // 这时候 ptr 就是一个野指针，因为它已经被删除，但仍然持有之前分配的内存的地址 为了防止以上情况发生，应该在释放内存后立即将指针置为空：\nint* ptr = new int(10); // 分配内存并初始化 delete ptr; // 释放内存 ptr = nullptr; // 将指针置为null，防止变成野指针 join 和 detach 的区别 线程的 join()和 detach()是两种不同的方法，用于管理线程的生命周期和资源回收。\njoin(): 当一个线程被创建并开始执行后，调用该线程的 join()方法会使当前线程等待，直到被调用的线程执行完毕。换句话说，join()方法会阻塞当前线程，直到被调用的线程完成其任务。这意味着在调用线程的 join()方法之后，程序会暂停执行，直到被调用的线程结束。\ndetach(): 当一个线程被创建并开始执行后，可以调用该线程的 detach()方法来分离它。分离线程后，它将变成一个“后台线程”，不再与主线程有关联。当一个线程被分离后，它将独立地运行，不再受主线程控制。一旦一个线程被分离，就无法再使用 join()方法等待它的完成，也无法获取它的返回值。\n简而言之，join()方法用于等待一个线程的完成，并获取它的结果，而 detach()方法用于将一个线程从主线程中分离出来，使其独立运行。需要注意的是，如果不显式地调用 join()或 detach()方法，当主线程结束时，所有仍然运行的线程都会被自动分离。\nmake_shared 有什么好处 在 C++中，shared_ptr 是一个智能指针，用于实现共享所有权的概念。它可以有多个 shared_ptr 指针指向相同的对象。这是一种非常好的方式来处理由动态分配创建的对象，因为当最后一个 shared_ptr 停止指向对象时，对象就会被删除。\n创建 shared_ptr 有两种常见的方法：\n方法一：使用 new 操作符\nstd::shared_ptr\u0026lt;int\u0026gt; p1(new int(5)); 这种方式直接使用 new 操作符申请内存并初始化 shared_ptr。这种方式虽然简单明了，但是如果在 new 操作和 shared_ptr 构造之间抛出异常，可能会导致资源泄露。\n方法二：使用 std::make_shared 函数\nstd::shared_ptr\u0026lt;int\u0026gt; p2 = std::make_shared\u0026lt;int\u0026gt;(5); make_shared 函数模板将用其参数来构造给定类型的对象，并返回此对象的 shared_ptr。这种方式更优，因为它提供了异常安全。还有一个额外的性能优势，即这种方式只进行一次动态内存分配，而 new 操作符则需要两次。此外，make_shared 更高效，原因是它同时分配内存以适应控制块和用户数据，这样可以减少内存碎片和内存管理开销。\n对比:\n异常安全：std::make_shared 具有更好的异常安全性。 性能：std::make_shared 只需要一次内存分配，而直接使用 new 需要两次，所以 std::make_shared 性能更优。 内存管理：std::make_shared 同时分配内存以适应控制块和用户数据，可以减少内存碎片和内存管理开销。 在谈论 std::make_shared 提供的安全性时，我们通常指的是异常安全。这主要涉及到两个因素： 内存泄漏：当我们使用 new 操作符创建一个对象，然后将其传递给 std::shared_ptr 时，如果在这两个步骤之间发生异常，那么新分配的对象可能无法被正确删除，从而导致内存泄漏。例如：\ncpp try { std::shared_ptr\u0026lt;int\u0026gt; p(new int(5)); } catch (...) { // 如果在 shared_ptr 构造函数执行之前发生异常，那么新分配的 int 对象就会泄漏 } 在上面的代码中，如果在 new int(5) 和 std::shared_ptr 构造函数之间有一个异常被抛出，那么新分配的内存无法被正确回收。但是，如果我们使用 std::make_shared，由于对象的创建和 shared_ptr 的构造是一次原子操作，所以不会出现这种问题。\n强异常安全保证：即使在异常发生时，std::make_shared 也能保持程序状态的完整性。它遵循了\u0026quot;构造-复制-销毁\u0026quot;（construct-copy-destroy）惯例，其中所有可能失败的操作（如内存分配）都在修改任何数据之前完成。这意味着在异常发生时，不会有半构造的 shared_ptr 留下。\n因此，std::make_shared 更“安全”，因为它提供了更好的异常安全性，尤其是在内存分配或其他可能失败的操作中。\n什么是虚假唤醒，如何解决 在 C++中，虚假唤醒是指当一个线程在等待某个条件变量时，即使没有收到显式的通知，也可能被唤醒。这可能会导致程序行为异常或者错误。\n解决虚假唤醒的方法通常是使用循环来检查预期的条件，而非仅靠单个 if 语句。这样，即使发生虚假唤醒，线程会再次检查该条件，发现条件并未满足，则继续等待。\n例如：\nstd::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); while(!condition) { cv.wait(lock); } 也可以使用 lambda 表达式来解决，不用 while 循环，只有在 g_deque 不为空的情况下才会返回 true\ncv.wait(lock, [] {return !q.empty(); }); gcc的参数 gcc 是 GNU Compiler Collection 的缩写，它是一个用于编译C/C++以及其他语言的强大编译器。以下是一些常用的 gcc 命令行参数：\n-o outputfile: 指定输出文件的名称。例如，gcc -o myprog myprog.c 将会编译 myprog.c 并生成可执行文件 myprog。 -c: 只编译但不链接，通常生成 .o 对象文件。例如，gcc -c myprog.c 会生成 myprog.o。 -g: 在编译的时候包含调试信息，这样在使用 gdb 或其他调试器时可以显示更多有用的信息。 -Wall: 开启所有警告信息。这个参数可以帮助你发现代码中的潜在问题。 -I dir: 添加头文件搜索路径。如果你的头文件不在标准的系统路径下，你可以用 -I 参数告诉 gcc 到哪里找它们。 -L dir: 添加库文件搜索路径。如果你的库文件不在标准的系统路径下，你可以用 -L 参数告诉 gcc 到哪里找它们。 -l libname: 链接到名为 libname 的库。例如，-lm 将链接到数学库 libm。 -std=: 用于指定C或C++的版本，例如 -std=c99 或 -std=c++11。 -D name: 定义预处理宏。例如，gcc -D DEBUG ... 相当于在源码前面添加了 #define DEBUG。 以上只是 gcc 最常用的部分参数，实际上 gcc 的参数非常丰富，可以根据具体需求选择合适的参数。\n","permalink":"https://chx9.github.io/posts/cs/cpp/","summary":"apple 多态介绍 定义：首先，可以解释一下什么是多态。多态（Polymorphism）是面向对象编程的一个重要特性，它允许我们使用父类的指针或引用来操作子类对象。这样，同一个函数或者操作符可以对不同类型的对象产生不同的行为。 两种形式：C++中的多态主要有两种形式：静态多态（或编译时多态）","title":"C++"},{"content":"1、采用 IO 复用技术 Epoll 和线程池实现多线程的 Reactor 高并发模型 IO 复用 IO 多路复用是现代操作系统中常用的一种网络编程技术。它允许一个进程同时监听多个文件描述符，从而可以同时处理多个网络连接，而无需为每个连接使用一个单独的线程。\n常用的 IO 多路复用的三种方式是 select、poll 和 epoll。它们的实现方式不同，但都可以实现 IO 多路复用的功能。它们的区别如下：\nselect select 是最古老、最常见的 IO 多路复用方式之一。它使用一个文件描述符集合来监听多个文件描述符，当其中任何一个文件描述符变为可读或可写时，select 函数就会返回。\nselect 的一个缺点是它使用的是线性扫描算法，因此它的性能随着文件描述符数量的增加而逐渐降低。\npoll poll 是 select 的一种改进，它使用一个 pollfd 结构体数组来监听多个文件描述符。与 select 不同的是，pollfd 结构体数组是动态的，因此它可以监听更多的文件描述符。\npoll 的一个缺点是它仍然使用线性扫描算法，因此它的性能也会受到文件描述符数量的限制。\nepoll epoll 是 Linux 特有的一种 IO 多路复用方式。它使用一个 epollfd 结构体来管理多个文件描述符，并使用事件通知机制来通知应用程序哪些文件描述符已准备好进行读写操作。\nepoll 的优点是它使用了基于事件驱动的方式来通知应用程序，因此它的性能不会随着文件描述符数量的增加而下降。\nPoll 机制相较于 Select 机制中，解决了文件描述符数量上限为 1024 的缺陷。但另外两点缺陷依然存在：\n每次调用 poll，都需要把 fd 集合从用户态拷贝到内核态，fd 越多开销则越大； 每次调用 poll，都需要在内核遍历传递进来的所有 fd，这个开销在 fd 很多时也很大\nepoll 是 Linux 下的一种 I/O 事件通知机制，可以用于高效地处理大量的 socket 连接。它提供了三个主要的函数：\nepoll_create()：创建一个 epoll 实例，返回一个文件描述符。该函数的参数 size 指定 epoll 实例中最大的文件描述符数目，一般设置为需要监听的 socket 数。 epoll_ctl()：向 epoll 实例中添加或删除一个文件描述符，或者修改一个文件描述符的监听事件。该函数的参数 epfd 是 epoll 实例的文件描述符，op 指定操作类型，fd 是需要添加/删除/修改的文件描述符，event 指定要监听的事件类型。 epoll_wait()：等待文件描述符上的事件发生，当有事件发生时，该函数将返回一个结构体数组，每个结构体描述一个事件。该函数的参数 epfd 是 epoll 实例的文件描述符，events 是一个存放事件的数组，maxevents 指定最多返回的事件数目，timeout 指定等待的超时时间。如果 timeout 为-1，表示一直等待，直到有事件发生；如果 timeout 为 0，表示立即返回，不等待。 单 reactor 多线程高并发模型有什么缺陷，在什么场景下会触发，解决办法是什么？\n单 reactor 多线程高并发模型的缺陷在于：\n竞争条件：多个线程同时访问共享资源，容易出现竞争条件，导致数据不一致或者程序崩溃。 上下文切换：线程切换需要消耗时间，当线程数过多时，会导致过多的上下文切换，降低程序的性能。 瓶颈：单 reactor 模型只有一个事件循环，无法充分利用多核 CPU 的优势，无法处理更多的并发连接。 当并发连接数量增加时，单 reactor 多线程模型容易出现线程切换开销大、竞争条件等问题，导致性能下降，甚至出现程序崩溃等情况。\nRactor 模型和 Proactor 模型 Reactor 模型：\n在 Reactor 模型中，应用程序将某个对象（通常是一个 socket）和其对应的事件处理函数注册到事件多路分发器上。然后，事件多路分发器会阻塞等待操作系统的事件通知。当某个对象上发生了注册的事件（例如，数据已经准备好可以读取），事件多路分发器就会调用相应的处理函数进行处理。 因此，在 Reactor 模型中，所有 I/O 操作都由应用程序显示地触发。实际的 I/O 操作（例如读和写）是同步的，尽管事件分发是异步的。\nProactor 模型：\nProactor 模型与 Reactor 模型的主要区别在于，I/O 操作的启动和完成都是异步的。当应用程序想要执行一个 I/O 操作时，它只需要发起该操作即可，然后就可以立即返回继续执行其他任务。当操作系统完成该操作时，它会自动调用预先注册的回调函数。 因此，在 Proactor 模型中，应用程序无需关心具体的 I/O 操作，而只需要发起这些操作并处理它们的结果。\n对比：\n操作复杂性：Reactor 模型中，应用程序需要负责管理 I/O 操作的具体过程，这使得编程较为复杂。相反，在 Proactor 模型中，操作系统会自动完成 I/O 操作，并在操作结束时通知应用程序，这使得编程更为简单。\nI/O 操作的阻塞性：在 Reactor 模型中，I/O 操作本身是阻塞的，只有事件分发是异步的。这可能导致一些性能问题，特别是在处理大量并发请求时。相反，在 Proactor 模型中，所有的 I/O 操作都是非阻塞的，这使得它能够更好地支持大规模并发。\n应用场景：Reactor 模型更适合于需要立即响应事件但不需要执行大量 I/O 操作的情况，如 GUI 程序。而 Proactor 模型则更适合于需要处理大量并发 I/O 操作的情况，如网络服务器。\n总的来说，Proactor 模型解决了 Reactor 模型中的一些问题，提供了一种更简洁、更高效的异步 I/O 实现方式。然而，选择哪种模型取决于具体的应用场景和需求。\nepoll 触发模式 epoll 支持三种触发模式：\nEPOLL_ET（边沿触发）：只有当文件描述符状态发生变化时，epoll 才会触发相应的事件。该模式适用于需要及时响应文件描述符状态变化的场景，但相对来说需要更加精细的管理。 EPOLL_LT（水平触发）：只要文件描述符处于就绪状态，epoll 就会持续不断地触发事件。该模式适用于需要频繁读写文件描述符的场景，但相对来说会产生更多的 CPU 开销。 epoll 底层是如何实现的 一颗红黑树，一张准备就绪句柄链表，少量的内核 cache，就帮我们解决了大并发下的 socket 处理问题。\n执行 epoll_create()时，创建了红黑树和就绪链表；\n执行 epoll_ctl()时，如果增加 socket 句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据；\n执行 epoll_wait()时立刻返回准备就绪链表里的数据即可。 红黑树维护事件表，事件驱动机制下的回调函数加入就绪链表，拷贝只拷贝就绪链表\n当某一进程调用 epoll_create 方法时，Linux 内核会创建一个 eventpoll 结构体，这个结构体中有两个成员与 epoll 的使用方式密切相关，如下所示：\ntruct eventpoll { ... /*红黑树的根节点，这棵树中存储着所有添加到epoll中的事件， 也就是这个epoll监控的事件*/ struct rb_root rbr; /*双向链表rdllist保存着将要通过epoll_wait返回给用户的、满足条件的事件*/ struct list_head rdllist; ... }; 我们在调用 epoll_create 时，内核除了帮我们在 epoll 文件系统里建了个 file 结点，在内核 cache 里建了个红黑树用于存储以后 epoll_ctl 传来的 socket 外，还会再建立一个 rdllist 双向链表，用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个 rdllist 双向链表里有没有数据即可。有数据就返回，没有数据就 sleep，等到 timeout 时间到后即使链表没数据也返回。所以，epoll_wait 非常高效。\n所有添加到 epoll 中的事件都会与设备(如网卡)驱动程序建立回调关系，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做 ep_poll_callback，它会把这样的事件放到上面的 rdllist 双向链表中。\n在 epoll 中对于每一个事件都会建立一个 epitem 结构体，如下所示：\nstruct epitem { ... //红黑树节点 struct rb_node rbn; //双向链表节点 struct list_head rdllink; //事件句柄等信息 struct epoll_filefd ffd; //指向其所属的eventepoll对象 struct eventpoll *ep; //期待的事件类型 struct epoll_event event; ... }; // 这里包含每一个事件对应着的信息。 2、利用状态机和正则解析 HTTP 报文请求，实现静态资源的处理 状态机一共有四个状态：REQUEST_LINE， HEADERS， BODY， FINISH，分别对应了 http 请求的三个内容，FINISH 是结束，程序通过 while 循环，将状态从 REQUEST_LINE→Headers→Body→Finish 转换。\nhttp 请求和响应的格式 请求格式：\n\u0026lt;Method\u0026gt; \u0026lt;Request-URI\u0026gt; \u0026lt;HTTP-Version\u0026gt; \u0026lt;Headers\u0026gt; \u0026lt;Body\u0026gt; 响应格式\n\u0026lt;HTTP-Version\u0026gt; \u0026lt;Status-Code\u0026gt; \u0026lt;Reason-Phrase\u0026gt; \u0026lt;Headers\u0026gt; \u0026lt;Body\u0026gt; 3、利用标准库容器封装 char，实现自动增长的缓冲区 缓冲区功能如果是固定的缓冲区，在存储小数据时会照成极大资源的浪费。自动增长的缓存区会根据每个客户端的请求响应数据大小，自适应的调整缓冲区大小。\n缓冲区场景\n从内核缓冲区中分散读取数据至缓冲区（in） HTTP 数据解析的时候，将缓冲区的数据读出（out） HTTP 生成响应数据的时候，会写入缓冲区（in） 将缓冲区中的数据写入内核缓冲区（out） 如何扩容：\n从内核缓冲区读数据采用的是分散读（readv），会定义一个长度为 2 的结构体 iovec 数组（0 存放缓冲区可写部分，1 存放一个临时 char 数组）。在读的时候会首先将 WritableBytes 空间占满，当还有数据需要写入的时候就需要扩容。扩容分为两种情况，因为在 HTTP 类解析缓冲区数据的时候，readPos_会不断增加，那么 PrependableBytes 就会不断增加，这块区域是空闲的，如果说 WritableBytes 和 PrependableBytes 的空间大小满组的话，那就只需要移动数据。那如果不满足的话，就要 resize 缓冲区的大小。\n分散写：\n写的内容也是被放在一个 2 个大小 iovec 数组（0 存放响应头，1 存放 html 文件）\n代码详解\nclass Buffer { public: Buffer(int initBuffSize = 1024); ~Buffer() = default; // 有多少字节的数据可以写 size_t WritableBytes() const; // 有多少字节的数据可以读 size_t ReadableBytes() const; // buffer头部有多少字节的数据空出来 size_t PrependableBytes() const; // 返回第一个可读字节的char地址 const char *Peek() const; // 确保WritableBytes小于len，如果不是，就调用MakeSpace_动态扩容 void EnsureWriteable(size_t len); // 写入结束，更新writePos_ void HasWritten(size_t len); // 写出，根据长度调整readPos_ void Retrieve(size_t len); // 写出，根据指针计算写出的长度，并调用Retrieve void RetrieveUntil(const char *end); // 重置缓冲区，在写入内核区缓存后来调用 void RetrieveAll(); std::string RetrieveAllToStr(); // 定位buffer内数据段末尾，在了http解析函数中使用 const char *BeginWriteConst() const; // 定位buffer内数据段首部 char *BeginWrite(); // 动态扩容 void Append(const std::string \u0026amp;str); // 核心是这个，其他重载函数内部调用了这个 void Append(const char *str, size_t len); void Append(const void *data, size_t len); void Append(const Buffer \u0026amp;buff); // 采用分散读，分散读的好处是减少系统调用次数，提高IO效率 ssize_t ReadFd(int fd, int *Errno); // 这个函数没有用，WriteFd写在了HttpConn::write中 ssize_t WriteFd(int fd, int *Errno); private: // 返回buffer头部指针 char *BeginPtr_(); const char *BeginPtr_() const; // 若PrependableBytes和WritableBytes大于len，整体数据往前移，若小于，那就要resize void MakeSpace_(size_t len); // 用动态数组封装的char缓冲区 std::vector\u0026lt;char\u0026gt; buffer_; // 如果没有实现log的话，就不需要原子，因为每个线程独自占有各自的buffer std::atomic\u0026lt;std::size_t\u0026gt; readPos_; std::atomic\u0026lt;std::size_t\u0026gt; writePos_; }; Buffer 类中的成员变量包括一个动态数组封装的 char 缓冲区 buffer*，以及两个 std::atomicstd::size_t类型的变量 readPos*和 writePos_，分别表示当前缓冲区的读取位置和写入位置。 类中提供的主要接口包括：\nWritableBytes()、ReadableBytes()、PrependableBytes()：分别用于获取缓冲区中可以写入的字节数、可以读取的字节数和缓冲区头部留出来的字节数。 Peek()：返回缓冲区中第一个可读字节的 char 地址。 EnsureWriteable()：确保缓冲区中可以写入的字节数大于等于 len，如果不够则进行动态扩容。 HasWritten()：写入结束后更新 writePos_。 Retrieve()、RetrieveUntil()：用于将已读取的数据从缓冲区中移除。 RetrieveAll()、RetrieveAllToStr()：用于将缓冲区中所有数据移除并返回。 BeginWriteConst()、BeginWrite()：返回缓冲区中可写数据的起始地址。 Append()：用于向缓冲区中增加额外的数据。 ReadFd()：用于采用分散读方式从文件描述符 fd 中读取数据并写入缓冲区。 除此之外，类中还有一些私有函数，用于实现动态扩容、返回 buffer 头部指针等功能。 非阻塞模式下 read 返回值 \u0026lt; 0 表示没有数据，= 0 表示连接断开，\u0026gt; 0 表示接收到数据。\n4、基于小根堆实现定时器，关闭超时的非活动链接 功能:为每一个客户端设置一个定时器，用户关闭超时的非活动链接。\n实现:定义了一个定时器结构体，包括 id（服务端为每个客户端分配的文件描述符），过期时间，回调函数以及重载了一个比较操作符。实现了一个 HeapTimer 类，用于存储管理定时器。此外还设计了 Tick 和 GetNextTick 函数。\nTrik 函数用于更新计时器堆的状态，通过 while 循环来不断 pop 出超时的定时器节点。\nGetNextTrick 用于返回堆顶元素的到期时间戳与当前时间戳的差，如果堆为空，则返回-1。同时，结合这个返回到期时间戳的函数，可以减少epoll_wait系统调用次数，来提高效率。epoll_wait 有一个参数叫 timeout，设置为 0，会直接返回，如果是-1 就一直阻塞，如果大于 0，表示要最多等到 timeout 时间才返回。那么我们假设 timeout 这段时间内没有新的事件发生，就没有必要一直轮询。\n5、利用 RAII 机制实现数据库连接池，减少数据库建立和关闭的消耗 epoll 的零拷贝技术 在使用 epoll 进行网络编程时，零拷贝技术可以提高数据传输的效率，减少 CPU 的使用率和数据复制的开销。\n具体来说，epoll 的零拷贝技术可以通过以下两种方式实现：\nsendfile 系统调用 sendfile 系统调用可以将文件数据直接从内核缓冲区发送到网络中，而无需将数据从内核缓冲区复制到用户空间缓冲区。在使用 epoll 进行网络编程时，可以通过 sendfile 系统调用将文件数据直接发送到网络中，从而避免了数据复制的开销。这种方式称为 epoll 的“零拷贝”技术。\nmmap 系统调用 mmap 系统调用可以将文件映射到进程的地址空间中，从而使得应用程序可以直接访问文件数据，而无需进行读写操作。在使用 epoll 进行网络编程时，可以通过 mmap 系统调用将文件映射到进程的地址空间中，然后使用 send 系统调用将数据直接从内核缓冲区发送到网络中，从而避免了数据复制的开销。\n总的来说，epoll 的零拷贝技术可以将数据传输的效率提高到极致，减少 CPU 的使用率和数据复制的开销。这在高并发的网络编程中非常有用，可以显著提高系统的性能和稳定性。\n为什么要用线程池 使用线程池的主要原因有:\n避免频繁创建和销毁线程。在使用超时或存在较长的 Waiting 时间的应用中,如果每次都需要创建一个新的线程将造成较大的开销。线程池可以重用过期的空闲线程,从而避免线程创建的开销。\n提高线程的可用性。在线程池中,可以有效地管理所有重复使用的线程,从而可以更好地利用这些可用的工作线程。\n控制并发数量。通过调整线程池中包含的线程数量,可以控制同一时间内允许运行的最大线程数目。这对于避免过载控制非常有用。\n提高资源利用率。 multiplex 可以重用同一个线程来处理多个任务,使资源得以更好地利用,比如共享内存的分配和设备等。\n管理任务的进度。线程池允许通过设置最大线程数来限制任务的并行进行数,以使任务进展得以控制和管理。\n避免死锁和饥饿，线程池可以通过控制线程的调度和资源分配来避免这些问题的发生。\n需要使用线程池的主要场景有:\nCPU 密集型任务。运行于循环或占用较长时钟周期的任务最适合使用线程池。\nI/O 密集型任务。涉及大量 I/O 等待的任务,比如数据库查询,网络请求等也非常合适。\n服务端应用。提供服务的应用,需要处理大量客户端请求,使用线程池可以管理多个请求使用同一个线程。\nGUI 应用。从事件驱动线程处理 GUI 事件的应用也应该使用线程池,以避免频繁创建和销毁 UI 线程。\n总结来说,在以下情况下,使用线程池会更为合适:\n任务较少,执行时间较长的任务。\n存在较长时间的 I/O 等待的任务。\n需要控制并发数的场景。如避免过载。\n需要重用空闲的工作线程的情况。如处理密集的但较短期的请求等。\n线程池的核心参数 创建一个线程池需要考虑的关键信息有:\n核心线程数(corePoolSize):线程池中始终存在的基本大小的工作线程数目。这个值通常很小,默认值是 1。\n最大线程数(maximumPoolSize):线程池能容纳的最大线程数。即使处理请求需要更多的工作线程,这个值也不会超过这个上限值。\n允许线程阻塞的时间(keepAliveTime):当空闲的工作线程数超过核心大小时,允许适当的扩充。当没有新的任务到达指定的时间后,线程池会进行判断,如果当前空闲的工作线程数超过核心大小,且空闲时间超过 keepAliveTime,那么多余的线程会被销毁。单位是毫秒。默认值是 60 秒。\n阻塞队列(BlockingQueue):用来存储任务的阻塞队列。通常选择 LinkedBlockingQueue 或者 ArrayBlockingQueue。他们同时还支持超时特性,可以指定阻塞队列不满时的超时时间。\n续约策略(补充策略):用于在任务捶捶式增长时决定是否增加或减少工作线程数的策略。常用策略有:\nFIFO FIFO 队列策略,按照任务添加到阻塞队列的顺序依次处理。公平性最强。 LIFO 后入先出队列策略。 PriorityQueue 优先级队列,根据任务优先级依次处理。 LinkedBlockingQueue 链式阻塞队列,默认使用 FIFO 策略。 ArrayBlockingQueue 数组阻塞队列,同样使用 FIFO 策略。\n","permalink":"https://chx9.github.io/posts/cs/webserver/","summary":"1、采用 IO 复用技术 Epoll 和线程池实现多线程的 Reactor 高并发模型 IO 复用 IO 多路复用是现代操作系统中常用的一种网络编程技术。它允许一个进程同时监听多个文件描述符，从而可以同时处理多个网络连接，而无需为每个连接使用一个单独的线程。 常用的 IO 多路复用的三种方式是 select、poll 和 epoll。它们","title":"Webserver"},{"content":"脏读，幻读，不可重复读解决了什么问题 脏读、幻读、可重复读是数据库中常见的隔离级别问题，它们分别解决了以下问题：\n脏读（Dirty Read）：当一个事务读取到另一个事务未提交的数据时，就产生了脏读。脏读可能导致数据的不一致性，因为读取到的数据可能会随时被其他事务修改或回滚。解决脏读的问题需要使用隔离级别为 Read Committed 或以上的级别，保证读取到的数据都是已经提交的数据。\n幻读（Phantom Read）：当一个事务读取到其他事务插入的新数据时，就产生了幻读。幻读可能导致数据的不一致性，因为读取到的数据可能会随时被其他事务修改或删除。解决幻读的问题需要使用隔离级别为 Serializable 级别，保证读取的数据都是一致的。\n可重复读（Repeatable Read）：当一个事务读取到其他事务修改的数据时，就产生了可重复读。可重复读可能导致数据的不一致性，因为读取到的数据可能会随时被其他事务修改或删除。解决可重复读的问题需要使用隔离级别为 Repeatable Read 或以上的级别，保证读取到的数据在事务提交之前不会被其他事务修改或删除。\n需要注意的是，提高隔离级别可以降低并发性能，因此需要根据实际情况来选择合适的隔离级别，同时需要注意数据库的锁机制和优化策略，以提高系统的性能和可用性。\nmysql 索引失效的几种方式 联合索引不满足最左匹配原则 使用了 select * 索引列参与运算 索引列参使用了函数示例 like 出现在开头 %abcd 使用 OR 操作 索引使用假设有一个联合索引(a,b,c)，分析以下查询情况： b = 2 and a=1 此查询条件可以很好地利用索引，因为索引的第二个字段是 b，第一个字段是 a，可以直接定位到满足条件的行。\nb = 2 or a = 1 这个查询条件不能很好地利用索引，因为这是一个或条件，需要同时扫描索引中 a=1 和 b=2 的记录，然后再将结果合并。因此，在这种情况下，数据库可能会选择使用全表扫描而不是索引扫描。\na = 1 and b \u0026gt; 2 此查询条件可以利用索引的前两个字段（a,b），可以直接定位到满足条件的行。\na \u0026gt; 1 and b =2 这个查询条件不能很好地利用索引，因为索引是按(a,b,c)的顺序排列的，而查询条件中第一个字段是 a，第二个字段是 b，第三个字段是 c，所以在 b=2 的情况下，需要扫描所有 a\u0026gt;1 的记录，直到找到满足条件的记录。因此，在这种情况下，数据库可能会选择使用全表扫描而不是索引扫描。\n索引使用 总之，联合索引(a,b,c)在不同的查询条件下，可以有不同的索引扫描效果。在实际应用中，建立联合索引的时候，需要根据实际情况和查询需求，选择合适的索引列顺序和索引列组合方式，以获得更好的索引扫描效果。\nmysql 优化 MySQL 查询优化是提高 MySQL 数据库性能的重要手段之一，它可以优化查询语句、数据表结构、索引等方面，以提高查询效率和性能。具体来说，MySQL 查询优化可以从以下几个方面入手：\n优化查询语句：优化查询语句是提高 MySQL 查询性能的第一步，可以通过使用合适的查询语句、避免使用子查询、避免使用%通配符、缩小查询范围等方式来减少查询时间和资源消耗。\n优化数据表结构：优化数据表结构可以提高 MySQL 数据库的查询性能和效率，可以通过合理设计数据表、避免使用过多的列、避免使用 TEXT 和 BLOB 类型等方式来提升 MySQL 数据库的性能。\n优化索引：索引是提高 MySQL 查询性能的重要手段之一，可以通过创建合适的索引、避免过多的索引、避免使用过多的组合索引、避免使用不必要的索引等方式来提高 MySQL 查询性能。\n避免全表扫描：全表扫描是 MySQL 查询性能低下的主要原因之一，可以通过使用索引、分区表、分页等方式来避免全表扫描，提高查询效率和性能。\n调整服务器参数：调整服务器参数可以提高 MySQL 数据库的性能和效率，可以通过调整缓存大小、调整线程池、调整查询缓存等方式来提高 MySQL 数据库的性能和效率。\n总之，MySQL 查询优化是提高 MySQL 数据库性能和效率的重要手段之一，需要根据实际情况采取合适的优化方法和手段来提高 MySQL 数据库的性能和效率。\n索引的类型 在数据库中，索引是一种特殊的数据结构，可以加快查询操作的速度。常见的索引类型包括以下几种：\nB-Tree 索引：B-Tree 索引是一种最常见的索引类型，适用于范围查找、等值查找等操作。B-Tree 索引可以快速定位到指定的记录，同时支持多列索引和前缀索引。\nHash 索引：Hash 索引是一种基于哈希表的索引类型，适用于只有等值查找操作的场景。Hash 索引可以快速定位到指定的记录，但不支持范围查找和排序操作。\nFull-Text 索引：Full-Text 索引是一种用于全文搜索的索引类型，适用于文本字段的搜索。Full-Text 索引可以在搜索中使用自然语言查询、通配符、布尔运算等操作，提供更加灵活的搜索功能。\nR-Tree 索引：R-Tree 索引是一种用于空间数据的索引类型，适用于地理信息、图像、音频等空间数据的查询。R-Tree 索引可以快速定位到指定的空间数据，同时支持范围查找和空间关系查询。\nBitmap 索引：Bitmap 索引是一种基于位图的索引类型，适用于低基数列的查询。Bitmap 索引可以将每个唯一值映射为一个位图，可以快速定位到指定的记录，同时支持多列索引和位图合并等操作。\n总之，不同类型的索引适用于不同的场景和查询操作，需要根据实际情况选择合适的索引类型来提高查询效率和性能。\n红黑树 红黑树是一种自平衡二叉查找树，每个节点有一个颜色属性：红或黑。红黑树满足以下特性：\n每个节点要么是黑色，要么是红色。 根节点是黑色。 所有叶子节点（NIL 节点，空节点）是黑色。 如果一个节点是红色的，则它的两个子节点都是黑色的。 从任意节点到其每个叶子节点的所有路径包含相同数量的黑色节点。\n红黑树比 AVL 树的优点 红黑树与 AVL 树都是自平衡二叉搜索树，但红黑树在实际应用中的优点如下：\n调整次数少：AVL 树每次插入或删除可能需要进行多次调整，而红黑树最多只需 3 次。 结构稳定：红黑树对于相同集合的数据，形成的结构是唯一的，而 AVL 树则可能有多种。 适用于读操作多的情况：AVL 树由于严格的平衡性，查找效率较高，适合读操作多的情况，而红黑树虽然平衡性较差，但是其维护平衡的代价小，更适合写操作多的场景。 数据库三大范式 数据库的三大范式是为了消除数据冗余和提高数据完整性而制定的规则：\n第一范式（1NF）：表的每一列都是不可分割的基本数据项，同一列中的值必须是相同类型，且唯一。\n第二范式（2NF）：在 1NF 的基础上，所有非主属性（非码属性）完全依赖于主键（码）。即一个表只描述一件事情。\n第三范式（3NF）：在 2NF 的基础上，消除传递依赖，非主属性之间不能存在依赖关系。\n第一范式（1NF）\n违反 1NF 的例子： 表格有一个“客户”字段，该字段中存储了客户的名字和地址。\n客户 张三, 北京 李四, 上海 遵循 1NF 后： 将“客户”字段分割为“客户名字”和“客户地址”。\n客户名字 客户地址 张三 北京 李四 上海 第二范式（2NF）\n违反 2NF 的例子：\n学号 课程 教室 老师 1001 数学 A101 张三 1002 英语 B201 李四 此表的主键是(学号, 课程)，但\u0026quot;教室\u0026quot;只依赖\u0026quot;课程\u0026quot;，\u0026ldquo;老师\u0026quot;也只依赖\u0026quot;课程\u0026rdquo;，不满足 2NF。\n遵循 2NF 后： 拆成两个表，每个表都满足所有非主属性完全依赖于全部候选键。\n学生选课表：\n学号 课程 1001 数学 1002 英语 课程表：\n课程 教室 老师 数学 A101 张三 英语 B201 李四 第三范式（3NF）\n违反 3NF 的例子：\n订单编号 商品编号 商品价格 O001 G001 50 O002 G002 100 此表中，“商品价格”直接依赖于“商品编号”，而不是“订单编号”。\n遵循 3NF 后： 拆分为两张表，消除传递依赖。\n订单表：\n订单编号 商品编号 O001 G001 O002 G002 商品表：\n商品编号 商品价格 G001 50 G002 100 mysql page cache 技术 MySQL 的 Page Cache 技术是一种基于内存的缓存技术，它可以将磁盘上的数据缓存在内存中，以加速数据库的读取操作。Page Cache 的实现原理是将磁盘上的数据分割成固定大小的页面（通常是 16KB），然后将这些页面缓存到内存中。\n当 MySQL 需要读取数据时，它首先检查 Page Cache 中是否已经缓存了所需的页面。如果页面已经在 Page Cache 中，则 MySQL 可以直接从内存中读取数据，从而避免了从磁盘上读取数据的开销。如果页面不在 Page Cache 中，则 MySQL 会从磁盘上读取数据并将其存储到 Page Cache 中，以便以后的读取操作可以更快地完成。\nPage Cache 技术可以显著提高 MySQL 的读取性能，特别是对于那些需要频繁读取的数据。然而，它也有一些限制，例如缓存的数据量受限于可用内存的大小，而且 Page Cache 中的数据不会随着数据库的更新而自动更新，需要手动调用 MySQL 的刷新函数才能更新。因此，在使用 Page Cache 技术时需要仔细评估内存使用和缓存更新的策略，以确保系统的性能和稳定性。\nmysql 如何实现 MVCC 的 主要是两个 版本号：每个数据行都有一个版本号，用于表示该数据行的版本信息。在 MySQL 中，每个事务都有一个唯一的事务 ID，每次对数据行进行修改时，都会创建一个新的版本，并将该版本与当前事务 ID 绑定。\n快照：每个事务都会创建一个独立的快照，用于保存该事务开始时数据库中所有数据行的版本信息。在 MySQL 中，快照是通过事务开始时的系统版本号来实现的。\n","permalink":"https://chx9.github.io/posts/cs/mysql/","summary":"脏读，幻读，不可重复读解决了什么问题 脏读、幻读、可重复读是数据库中常见的隔离级别问题，它们分别解决了以下问题： 脏读（Dirty Read）：当一个事务读取到另一个事务未提交的数据时，就产生了脏读。脏读可能导致数据的不一致性，因为读取到的数据可能会随时被其他事务修改或回滚。解决脏读的","title":"Mysql"},{"content":"进程和线程区别 1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序\n2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。线程启动速度快，轻量级\n进程的资源：\n独立的内存空间（虚拟地址空间） 系统资源，如打开的文件、信号处理器等 线程的资源:\n程序计数器：用于指令读取，函数调用，指令跳转 寄存器：用于保存线程的上下文信息。 栈 协程 协程是用户态的轻量级线程，线程内部调度的基本单位，都是运行在用户态，拥有自己的寄存器上下文和栈 c++的协程库: boost coroutine, libco\n线程由操作系统管理，切换需要操作系统内核，耗费时间和资源，协程切换是程序员自己控制 线程之间通信通过共享内存或者传递消息，而协程之间直接通过函数调用或者共享变量 线程可以通过多个 cpu 实现并行，但是协程只在一个线程中 线程创建、销毁需要操作系统接入，而协程在用户空间内完成 协程适用于 高并的网络编程，异步 io 操作，高并发网络编程，**短时间的计算密集型，**线程：cpu 密集型 多个线程情况下 CPU 利用率不高 1、同步和通信不高效(死锁，数据竞争)\n2、线程过多：竞争过于激烈； 线程数过少：CPU 核心限制\n3、io 密集型\nepoll 的底层实现 红黑树用来管理所有的文件描述符\n内核中的事件表：存储所有就绪的文件描述符\n内核中的回调函数：内核调用回调函数处理处理所有就绪的文件描述符 同步模型的优点：\n同步 io 和异步 io 的优缺点 同步 io 优点：\n编程简单 可靠性高（阻塞） 同步模型的缺点：\n性能低（阻塞） 异步模型的优点： 高性能 编程复杂 异步模型的缺点：\n可靠性低（可能会出现操作未完成就返回结果，需要判断错误） 互斥锁、读写锁、自旋锁 互斥锁，最基本的同步机制，保护临界区资源访问\n读写锁，允许多个线程同时读共享资源，但是只允许一个锁读取共享资源，读写锁的实现通常是基于互斥锁和条件变量实现的。\n自旋锁是一种轻量级同步机制，当自旋锁被占用时，线程不会进入阻塞状态，而是一直循环等待，适用于锁占用短的场景，锁占用长的\n加锁的方式 阻塞锁，一直等待资源 自旋锁，一直循环等待 乐观锁，假设读取共享资源的时候不会修改它，如果被修改了，就重新尝试 信号量能保证线程同步吗？ 信号量可以用来保证线程同步，但最好与锁一起使用来保证线程互斥。信号量是一种计数器，用来保护共享资源。当一个线程想要访问共享资源时，它必须先获取信号量，然后才能访问共享资源。如果信号量的计数器为 0，则线程必须等待，直到有另一个线程释放信号量。这样可以确保多个线程不会同时访问共享资源，从而保证线程同步。\n在使用信号量时，需要注意一些问题。首先，信号量只能保证线程同步，不能保证线程互斥。如果多个线程都可以获得信号量，则它们可以同时访问共享资源。因此，最好与锁一起使用来保证线程互斥。其次，信号量可能会产生死锁问题。当多个线程互相等待对方释放信号量时，就会发生死锁。因此，在使用信号量时，需要仔细考虑并发情况，以确保线程安全和性能。\nlinux 下递归删除某个目录下以 cpp 为结尾的文件 find /path/to/directory -type f -name \u0026#34;*.cpp\u0026#34; -delete 如果不加 -type f，find 命令会查找目录中的所有类型的文件，包括普通文件、目录、符号链接等，可能会误删一些非文件类型的内容。加上 -type f 可以限定只查找普通文件，避免误删其他类型的内容。\n死锁的四个条件 互斥条件：一个资源每次只能被一个进程使用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 如果一个系统中存在上述四个条件，就会出现死锁的情况，死锁的解决方法通常需要采用多种方法，如锁机制的优化、资源分配算法的改进等。\n内核态和用户态 内核态（Kernel Mode）和用户态（User Mode） 是操作系统设计中的两种运行级别或模式，用于区分进程对硬件资源的访问权限。\n内核态（Kernel Mode）\n在内核态下，代码有权访问系统的任何资源，不受任何保护和限制。它可以直接执行任意 CPU 指令，可以访问任何物理内存地址，也可以访问和操作所有的硬件设备。 由于其高权限，内核态主要被操作系统内核、设备驱动程序等使用。 错误的操作可能导致整个系统崩溃或者数据丢失。 用户态（User Mode） 在用户态下，代码执行在一个受保护的环境中，只能访问一部分范围的内存，不能直接访问硬件设备，对 CPU 指令集的使用也有所限制。 当一个用户程序需要进行一项系统调用（如读写文件，发送网络数据）时，它会切换到内核态，由内核代为完成，然后再切换回用户态。 这种机制能够保护系统的稳定性和安全性，防止用户程序的错误操作影响整个系统。 linux 常用命令 下面列举一些常用的 Linux 命令：\nls：列出目录下的文件和子目录。 cd：切换当前目录。 pwd：显示当前所在目录的路径。 mkdir：创建一个新目录。 rmdir：删除一个空目录。 rm：删除文件或目录。 cp：复制文件或目录。 mv：移动或重命名文件或目录。 cat：查看文件内容。 grep：在文件或输入流中查找匹配的文本。 tail：查看文件的末尾内容。 head：查看文件的开头内容。 find：在指定目录下查找文件。 chmod：修改文件或目录的权限。 chown：修改文件或目录的所有者。 ps：查看当前系统进程。 top：查看当前系统资源占用情况。 tar：打包和解压缩文件。 ssh：远程登录到另一台计算机。 scp：在本地和远程计算机之间复制文件。 df：查看磁盘空间使用情况。 free：查看系统内存使用情况。 uname：查看系统信息。 ifconfig：查看网络接口信息。 ping：测试网络连接。 traceroute：查看网络路由情况。 netstat：显示网络连接、路由表和网络接口等信息。 iptables：管理系统防火墙规则。 systemctl：管理系统服务。 ps aux：显示所有进程的详细信息。 kill：终止指定进程。 nohup：让进程在后台运行。 screen：在一个终端窗口中打开多个终端会话。 wget：下载文件。 curl：向服务器发送请求并显示响应。 tar：压缩和解压缩文件。 gzip：压缩和解压缩文件。 zip：压缩和解压缩文件。 ssh-keygen：生成 SSH 密钥对。 linux 中查询进程占用 cpu 的情况 在 Linux 系统中，可以使用 top 命令来查看系统中占用 CPU 最多的进程，具体操作如下：\n打开终端并输入 top 命令。 top 命令会实时显示系统资源使用情况，包括 CPU、内存、进程等。在进程列表中，可以看到各个进程的 CPU 使用情况以及其他相关信息。 进程列表默认按照 CPU 使用率排序，可以通过按下“P”键，然后再按下“Enter”键，将进程列表按照 CPU 使用率从高到低排序。\n打开终端并输入 ps aux 命令。 ps 命令会列出当前系统中所有的进程，包括进程的 PID、CPU 占用率、内存使用情况等。 若要按照 CPU 使用率排序，可以使用 ps aux \u0026ndash;sort=-%cpu 命令。\n0 拷贝 小林 coding\n普通拷贝 内存映射 mmap sendfile 零拷贝（Zero Copy）是一种提高数据传输效率和性能的技术，其基本思想是在数据传输过程中减少数据拷贝和内存复制操作，从而减少 CPU 的开销和系统资源的占用，提高数据传输的效率和性能。\n在传统的数据传输方式中，数据通常需要从应用程序的缓冲区复制到内核空间的缓冲区，然后再从内核空间的缓冲区复制到网络设备的缓冲区，最后再从网络设备的缓冲区复制到目标主机的内核空间缓冲区，最后再从目标主机的内核空间缓冲区复制到目标应用程序的缓冲区。这样的数据传输方式需要经过多次数据拷贝和内存复制操作，耗费大量的 CPU 时间和系统资源，降低了数据传输的效率和性能。\n零拷贝技术可以通过使用 DMA（Direct Memory Access）技术和共享内存等技术，将数据从应用程序的缓冲区直接传输到网络设备的缓冲区，从而避免了数据拷贝和内存复制操作。这样就可以大大减少 CPU 的开销和系统资源的占用，提高数据传输的效率和性能。\n在使用零拷贝技术时，需要注意以下几点：\n零拷贝技术需要硬件和操作系统的支持，不是所有的硬件和操作系统都支持零拷贝技术。 零拷贝技术需要应用程序和网络设备之间的协作，需要对数据传输进行特殊处理。 零拷贝技术可能会增加代码的复杂度和难度，需要谨慎使用。 总之，零拷贝技术可以提高数据传输的效率和性能，但需要硬件和操作系统的支持，并且需要谨慎使用。\n页调度/置换算法 页调度（Page Replacement）是操作系统中的一个重要概念，用于管理内存中的虚拟页（Virtual Page），当内存中的页框（Page Frame）不足时，需要将某些页从内存中换出（Swap Out），并将新的页换入（Swap In），以便为新的进程或线程腾出空间。\nFIFO：最先进入内存的页面最先被替换。 Optimal：理论上最佳，替换未来最长时间不会被访问的页面，但实际难以实现。 LRU：替换最近最少使用的页面，需要记录页面使用历史。 LFU：替换最不常使用的页面，基于访问频率。 Clock：循环队列置换，是 LRU 的高效实现，广泛用于操作系统。 NUR：最近未使用，是对 LRU 的一种近似实现。 Random：随机选择一个页面替换。\n如何优化生产者消费者模型 使用适当的数据结构：例如，使用支持并发的阻塞队列可以简化编程，提高效率。\n合理设置缓冲区大小：如果缓冲区过小，可能导致生产者频繁阻塞；若过大，可能浪费内存资源。\n优化线程数量：生产者和消费者的线程数量应根据系统的处理能力进行调整。过多线程可能导致上下文切换开销增加，过少则不能充分利用系统资源。\n使用异步处理：避免生产者和消费者之间的直接等待关系，提高吞吐量。\n采用批处理：批量生产和消费数据可以减少线程间同步的次数，提高处理速度。\n考虑优先级：对于有优先级需求的场景，可以设置优先级队列以满足业务需求。\n避免频繁 GC：如果生产者和消费者频繁创建和销毁对象，可能引发频繁的垃圾收集，影响性能。可以通过对象池等方式复用对象。\n评估并优化锁的使用：确保必要且适当的锁定以减少竞争，但也要避免引入不必要的锁。\nDMA 技术（page cache） 是 DMA 的基本实现过程：\n请求 DMA 传输：当设备需要读写内存时，它会发出 DMA 传输的请求。\nDMA 控制器接管总线：一旦 CPU 接到 DMA 请求，并且在完成当前指令后，它会释放总线并将其交给 DMA 控制器。\n执行数据传输：DMA 控制器将数据从内存中读取并发送给设备，或者从设备读取数据并将其写入内存。在此过程中，CPU 无需参与数据的读写操作，可以执行其他任务。\n传输完成：DMA 控制器在传输完成后，会向 CPU 发出中断信号，通知 CPU 数据已经传输完成。\nCPU 重新接管总线：在处理完 DMA 传输完成的中断后，CPU 再次接管总线，恢复正常的指令执行。\n分段和分页 分段 程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。 通过段号和偏移量确定物理地址 不足之处：\n内存碎片的问题（外部内存）。 内存交换的效率低。 分页 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小\n页表是存储在内存里的，内存管理单元 （MMU） 就做将虚拟内存地址转换成物理地址的工作。\n提高内存的利用率，没有外部碎片 但会产生内碎片（一个页可能填充不满）。 而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。\n如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。\nTLB,页表缓存\n如何优化读 优化读操作可以从多个角度进行：\n使用缓存：将常用数据或最近使用的数据存储在内存中，可以大大提高读取速度。\n预读（Prefetching）：如果能预测到未来会读取哪些数据，可以提前将这些数据加载到缓存中。\n数据分区：将数据分布在不同的磁盘上，可以并行地读取数据，提高读取速度。\n索引：对于数据库等系统，使用索引可以快速定位到数据，减少磁盘 I/O 操作。\n数据压缩：压缩数据可以减少读取的数据量，但需要注意解压缩可能带来的额外计算开销。\n批量读取：一次读取大块的数据比多次读取小块的数据更高效。\n合理排列数据：尽可能地使顺序访问的数据在物理硬盘上连续存放（例如，利用文件系统的预留空间功能）。\n虚拟内存 虚拟内存是一种内存管理技术，它使得应用程序认为它们自己拥有连续可用的内存（一个连续完整的地址空间），而实际上，它们的物理内存被切割成了多个块，这些块在物理内存和硬盘之间动态地交换。\n以下是虚拟内存的基本原理和特点：\n地址转换：操作系统通过页表将虚拟地址（程序中使用的地址）映射为物理地址（实际内存硬件的地址）。这样，程序可以在一个连续的地址空间中运行，即使物理内存是离散分布的。\n按需加载和置换：当程序访问某个地址时，如果对应的页面不在物理内存中（发生缺页中断），操作系统会选择一个页面置换出内存，将需要的页面从硬盘载入内存。这样，只有需要用到的页面才被加载，节省了内存资源。\n内存保护：每个程序都在其自己的虚拟地址空间中运行，无法访问其他程序的地址空间，增强了系统的稳定性和安全性。\n内存共享和映射文件：虚拟内存技术使得多个进程可以共享物理内存或映射同一个文件到其虚拟内存，方便了进程间的通信和文件操作。\n虚拟内存大大提高了内存的使用效率，简化了程序的编写，是现代操作系统的重要组成部分。\nkill -9 和 kill -15 的区别？ kill 命令在 Linux 中被用来终止或发送信号给进程。-9 和-15 是具体的信号编号，分别对应 SIGKILL 和 SIGTERM 信号。\nkill -9 (SIGKILL) SIGKILL 信号会强制结束进程，进程无法忽略这个信号。当你发送 SIGKILL 信号后，操作系统会立刻停止进程。由于进程没有机会进行清理（例如关闭打开的文件或网络连接），所以可能会导致数据丢失或其他问题。 kill -15 (SIGTERM) SIGTERM 是默认的 kill 信号。与 SIGKILL 不同，进程能够捕捉到 SIGTERM 信号，并决定如何响应。大多数进程会在接收到 SIGTERM 后进行一些清理工作，然后优雅地结束。如果进程忽略了 SIGTERM 信号或者无法正常结束，则可以使用 SIGKILL 来强制结束。 僵尸进程和孤儿进程 僵尸进程是已终止但父进程未回收其状态信息的进程。解决方法：父进程应调用 wait()获取子进程状态，或者将这些进程的父进程更改为 init。\n孤儿进程是父进程结束后仍在运行的进程。处理方式：被 init 进程自动接管，无需特别处理。\n自旋锁和互斥锁 自旋锁（Spinlock）：\n用于保护短时期的临界区。当无法获取锁时，线程会一直在循环中尝试获取锁（忙等待即\u0026quot;自旋\u0026quot;），而不是睡眠。 更适合于锁保护代码执行时间非常短的情况，因为它避免了上下文切换的开销。 互斥锁（Mutex）：\n当无法获得锁时，线程会进入睡眠状态，直到有其他线程释放锁唤醒它。 如果被保护的代码可能需要长时间执行或等待其他资源，使用互斥锁将更有效，因为它能让出CPU给其他线程使用。 sed 和 awk 的区别 sed：\n主要用于文件中的文本替换。\n提供了基于行的处理方式，例如删除行、插入行或替换行。 常用于简单的文本转换和操作。 awk： 更强大的文本处理工具，提供了编程语言的特性，如变量、循环和条件判断。\n可以处理多个文件。 主要设计用来处理具有明确定义格式和字段的文本。 history 命令 history: 显示先前执行过的命令列表。 history n: 显示最近的n个命令。 !n: 重复执行历史中的第n个命令。 !!: 重复执行上一个命令。 !-n: 重复执行倒数第n个命令。 !string: 运行以指定字符串开始的最后一个命令。 !?string?: 运行包含指定字符串的最后一个命令。 history -c: 清除历史记录。 history -d offset: 删除历史中的特定条目。 Bash shell允许通过HISTCONTROL和HISTIGNORE环境变量来控制history命令的行为：\nHISTCONTROL可以设置为：\nignorespace：以空格开头的命令不会保存到历史记录中。 ignoredups：连续的重复命令只会保存一次。 ignoreboth：同时应用上述两种规则。 HISTIGNORE允许您指定一个模式列表，匹配的命令不会保存到历史记录中。例如，HISTIGNORE='ls💿pwd'会忽略ls、cd\nfind命令 find命令用于在Linux文件系统中搜索和定位文件的列表，此命令可以根据多种条件如名称、类型、大小等来查找文件。\nfind /dir/ -name filename: 在/dir/目录及其子目录中查找名为filename的文件。 find /dir/ -iname filename: 同上，但忽略大小写。 find . -type f: 在当前目录及其子目录中查找所有普通文件。 find . -type d: 在当前目录及其子目录中查找所有目录。 find /dir/ -user username: 查找/dir/目录及其子目录中所有者为username的文件。 find /dir/ -mmin n: 查找/dir/目录及其子目录中在n分钟前被修改的文件。 find /dir/ -size +10M: 查找/dir/目录及其子目录中大于10MB的文件。 你还可以通过-exec选项与其他命令结合使用，对搜索结果执行操作： 8. find /dir/ -name '*.txt' -exec rm {} \\;: 在/dir/目录及其子目录中查找所有.txt文件并删除之。\nmerge 和 rebase的区别 Merge（合并）：\n保留原始分支的历史，不改变提交顺序。 创建一个新的合并提交，将两个或多个分支的更改合并到一起。 可能会产生较为复杂的提交历史，因为每个分支的提交都会保留。 Rebase（变基）：\n将当前分支的更改移动到另一个分支的基础上，形成一个线性历史。 不会创建新的合并提交，使得提交历史更为简洁。 可能会改写提交历史，因此需要谨慎使用，尤其是在公共分支上。 ","permalink":"https://chx9.github.io/posts/cs/os/","summary":"进程和线程区别 1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序 2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。线程启动速度快，轻量级 进程","title":"Operating System"},{"content":"141 环形链表 class Solution { public: bool hasCycle(ListNode *head) { auto fast = head; auto slow = head; while(fast \u0026amp;\u0026amp; fast-\u0026gt;next){ slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; if(slow == fast) return true; } return false; } }; 142 环形链表 https://leetcode.cn/problems/linked-list-cycle-ii/?favorite=2cktkvj 有一个链表，如果有环，返回环的入口处，没有则返回 方法一：哈希表 哈希表第一个重复的值，就是入口处 方法二：快慢指针 如果有环，快慢指针将会再某一点相遇，此时的慢指针和head与环入口点距离相等\nclass Solution { public: ListNode *detectCycle(ListNode *head) { if(head == nullptr) return nullptr; ListNode* fast = head; ListNode* slow = head; while(fast \u0026amp;\u0026amp; fast-\u0026gt;next){ fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; if(fast == slow){ auto res = head; while(res!=slow){ res = res-\u0026gt;next; slow = slow-\u0026gt;next; } return res; } } return nullptr; } }; 146 LRU缓存 https://leetcode.cn/problems/lru-cache/\n请你设计一个Last Recent Used Cache 使用一个双向指针（带有head和tail节点，同时节点中包含key和value值）以及一个unordered_map储存，实现两个函数，moveToHead()和removeTail()\nclass LRUCache { struct ListNode{ int key; int val; ListNode* next; ListNode* prev; ListNode(): key(0), val(0){} ListNode(int key, int val):key(key), val(val){} }; private: int capacity; unordered_map\u0026lt;int, ListNode*\u0026gt; cache; ListNode* head; ListNode* tail; public: LRUCache(int capacity) { this-\u0026gt;capacity = capacity; head = new ListNode(); tail = new ListNode(); head-\u0026gt;next = tail; tail-\u0026gt;next = head; head-\u0026gt;prev = tail; tail-\u0026gt;prev = head; } int get(int key) { if(cache.count(key) != 0){ moveToHead(key); return cache[key]-\u0026gt;val; } return -1; } void put(int key, int value) { if(cache.count(key)==0){ addToHead(key, value); }else{ cache[key]-\u0026gt;val = value; moveToHead(key); } if(cache.size() \u0026gt; this-\u0026gt;capacity){ removeTail(); } } void addToHead(int key, int value){ auto node = new ListNode(key, value); cache[key] = node; // auto tp = head-\u0026gt;next; head-\u0026gt;next = node; node-\u0026gt;prev = head; node-\u0026gt;next = tp; tp-\u0026gt;prev = node; } void moveToHead(int key){ auto node = cache[key]; node-\u0026gt;prev-\u0026gt;next = node-\u0026gt;next; node-\u0026gt;next-\u0026gt;prev = node-\u0026gt;prev; auto tp = head-\u0026gt;next; // head-\u0026gt;next = node; node-\u0026gt;prev = head; node-\u0026gt;next = tp; tp-\u0026gt;prev = node; } void removeTail(){ auto last = tail-\u0026gt;prev; cache.erase(last-\u0026gt;key); tail-\u0026gt;prev = last-\u0026gt;prev; last-\u0026gt;prev-\u0026gt;next = tail; delete last; } }; 148 排序链表 https://leetcode.cn/problems/sort-list/?favorite=2cktkvj merge_sort排序对链表进行排序： 1、如果merge_sort传入的头尾链表相距一个单位，则切断链表，返回head 2、快慢链表找到中间值 3、合并链表 注意遍历快慢链表的方法，fast != tail，然后在循环中判断是否需要fast进两步\nclass Solution { public: ListNode* merge_sort(ListNode* head, ListNode* tail){ if(!head ){ return head; } if(head-\u0026gt;next == tail){ head-\u0026gt;next = nullptr; return head; } auto fast = head; auto slow = head; while(fast!=tail \u0026amp;\u0026amp; fast-\u0026gt;next!=tail){ fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; } return merge(merge_sort(head, slow), merge_sort(slow, tail)); } ListNode* merge(ListNode* l1, ListNode*l2){ auto dummy = new ListNode(); auto cur = dummy; while(l1 \u0026amp;\u0026amp; l2){ if(l1-\u0026gt;val \u0026lt; l2-\u0026gt;val){ cur-\u0026gt;next = l1; l1 = l1-\u0026gt;next; }else{ cur-\u0026gt;next = l2; l2 = l2-\u0026gt;next; } cur = cur-\u0026gt;next; } if(l1){ cur-\u0026gt;next = l1; }else{ cur-\u0026gt;next = l2; } return dummy-\u0026gt;next; } ListNode* sortList(ListNode* head) { return merge_sort(head, nullptr); } }; 152.乘积最大子数组 https://leetcode.cn/problems/maximum-product-subarray/\n动态规划，因为数组中可能有负数，所以不仅仅要维护一个当前最大动态数组，还要维护当前最小数组，防止负负得正变成最大值\nclass Solution { public: int maxProduct(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if( nums.size()==0 ) return 0; vector\u0026lt;int\u0026gt; curMax(nums.size()); vector\u0026lt;int\u0026gt; curMin(nums.size()); int res = nums[0]; curMax[0] = nums[0]; curMin[0] = nums[0]; for(int i=1;i\u0026lt;nums.size();i++){ int cur = nums[i]; curMax[i] = max(max(curMax[i-1]*cur, curMin[i-1]*cur), cur); curMin[i] = min(min(curMin[i-1]*cur, curMax[i-1]*cur), cur); res = max(res, curMax[i]); } return res; } }; 155 最小栈 https://leetcode.cn/problems/min-stack/\n维护两个栈，除了基础的栈外，维护一个储存最小值的栈\nclass MinStack { private: stack\u0026lt;int\u0026gt; min_st; stack\u0026lt;int\u0026gt; st; public: MinStack() { } void push(int val) { st.push(val); if(min_st.empty() || min_st.top() \u0026gt;= val){ min_st.push(val); } } void pop() { int top = st.top(); st.pop(); if(min_st.top() == top){ min_st.pop(); } } int top() { return st.top(); } int getMin() { return min_st.top(); } }; 160 相交链表 https://leetcode.cn/problems/intersection-of-two-linked-lists/\n判断两个链表是否相交 便利 两个链表，在达到尾端（注意要达到nullptr）如果遇到相等的情况，就是相交，否则他们将会在nullptr处相交：\nclass Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { if(!headA || !headB) return nullptr; auto tpa = headA; auto tpb = headB; while(tpa!=tpb){ tpa = tpa? tpa-\u0026gt;next : headB; tpb = tpb? tpb-\u0026gt;next : headA; } return tpa; } }; 169 多数元素 https://leetcode.cn/problems/majority-element/\n1、排序取中间值 2、摩尔投票算法\nclass Solution { public: int majorityElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int cnt = 0; int candidate; for(int num: nums){ if(cnt==0){ candidate = num; cnt++; }else{ if(candidate==num){ cnt++; }else{ cnt--; } } } return candidate; } }; 198 打家劫舍 打家劫舍i https://leetcode.cn/problems/house-robber/\n动态规划 max(f[i-1], nums[i]+f[i-2]) 偷i-2家和i家或者偷i-1并且不偷i家\nclass Solution { public: int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; f(nums.size(), 0); if(f.size()==1) return nums[0]; f[0] = nums[0]; f[1] = max(nums[0], nums[1]); for(int i=2;i\u0026lt;nums.size();i++){ f[i] = max(f[i-1], nums[i]+f[i-2]); } return f[nums.size()-1]; } }; 优化空间之后\nclass Solution { public: int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int prev = 0; int cur = nums[0]; for(int i=1;i\u0026lt;nums.size();i++) { int tp = cur; cur = max(cur, prev+nums[i]); prev = tp; } return cur; } }; 打家劫舍ii https://leetcode.cn/problems/house-robber-ii/\n有环 ,如果偷了第0家，那么不可以偷第n-1家，所以rob(nums, 0, n-2)，如果偷了n-1家，那么不可以偷第0家，所以rob(nums, 1, n-1)。\nclass Solution { public: int rob_helper(vector\u0026lt;int\u0026gt;\u0026amp; nums, int start, int end) { int prev = 0; int cur = nums[start]; for (int i = start + 1; i \u0026lt;= end; i++) { int tp = cur; cur = max(cur, prev + nums[i]); prev = tp; } return cur; } int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.size() == 1) return nums[0]; int n = nums.size(); return max(rob_helper(nums, 1, n - 1), rob_helper(nums, 0, n - 2)); } }; 打家劫舍iii 核心思想是后序遍历，现将子节点值遍历出来 建立两个哈希表，g[root]表示选择当前节点的最大值，f[root]表示不选择当前节点的最大值\n同样的思想，偷到当前节点有两种情况，如果偷当前节点，那么左孩子节点和右孩子节点都不能偷，直接就是root→val+f[root→left]+f[root→right]，如果不偷当前节点，那么左孩子可偷可不偷，右孩子也是可偷可不偷，所以max(g[root→left], f[root→right])+max(g[root→right], f[root→right])\nclass Solution { private: unordered_map\u0026lt;TreeNode*, int\u0026gt; g, f; // g[node] 表示选择 // f[node] 表示不选择 public: void dfs(TreeNode* root){ if(root == nullptr) return; dfs(root-\u0026gt;left); dfs(root-\u0026gt;right); g[root] = root-\u0026gt;val + f[root-\u0026gt;left] + f[root-\u0026gt;right]; f[root] = max(g[root-\u0026gt;left], f[root-\u0026gt;left]) + max(g[root-\u0026gt;right], f[root-\u0026gt;right]); } int rob(TreeNode* root) { dfs(root); return max(g[root], f[root]); } }; 200 岛屿数量 https://leetcode.cn/problems/number-of-islands/?favorite=2cktkvj 深度优先遍历+visit数组\nclass Solution { private: vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visit; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; directions{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; int n; int m; public: void dfs(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid, int i, int j){ if(i\u0026gt;=n || i\u0026lt;0 || j\u0026gt;=m || j\u0026lt;0 || visit[i][j] == true || grid[i][j]==\u0026#39;0\u0026#39;){ return; } visit[i][j] = true; for(auto direction: directions){ int next_i = i + direction[0]; int next_j = j + direction[1]; dfs(grid, next_i, next_j); } } int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(); int m = grid[0].size(); this-\u0026gt;n = n; this-\u0026gt;m = m; if(n==0) return 0; int res = 0; visit = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(n, vector\u0026lt;bool\u0026gt;(m, false)); for(int i=0;i\u0026lt;n;i++) { for(int j=0;j\u0026lt;m;j++){ if(visit[i][j]==false \u0026amp;\u0026amp; grid[i][j]==\u0026#39;1\u0026#39;){ res++; dfs(grid, i, j); } } } return res; } }; 206 翻转链表 https://leetcode.cn/problems/reverse-linked-list/\n头插法：正向遍历+dummy节点\nclass Solution { public: ListNode* reverseList(ListNode* head) { auto dummy = new ListNode(); while(head){ auto dummy_next = dummy-\u0026gt;next; auto head_next = head-\u0026gt;next; dummy-\u0026gt;next = head; head-\u0026gt;next = dummy_next; head = head_next; } return dummy-\u0026gt;next; } }; 迭代法\nclass Solution { public: ListNode* reverseList(ListNode* head) { ListNode* prev = nullptr; ListNode* cur = head; while(cur){ auto next = cur-\u0026gt;next; cur-\u0026gt;next = prev; prev = cur; cur = next; } return prev; } }; 递归法\nclass Solution { public: ListNode* reverseList(ListNode* head) { if(head == nullptr) return nullptr; if(head-\u0026gt;next == nullptr) return head; auto next = head-\u0026gt;next; auto reversed = reverseList(head-\u0026gt;next); head-\u0026gt;next = nullptr; next-\u0026gt;next = head; return reversed; } }; 207 课程表 https://leetcode.cn/problems/course-schedule/\n计算入度+广度优先算法\n先遍历，记录所有节点的入度和整张图 用stack或者queue push进入度为0的课程（表示可以直接上掉课程），while循环，每次pop出来记录可以上掉的课程，计算此课程的完成是否可以让其他课程进入入度为0的状态，如有则push进 stack或者queue，结果是完成课程的数量是否等于全部课程 class Solution { public: bool canFinish(int numCourses, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; prerequisites) { vector\u0026lt;int\u0026gt; in(numCourses, 0); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(numCourses, vector\u0026lt;int\u0026gt;(numCourses, 0)); for(auto prerequisite: prerequisites){ in[prerequisite[0]]++; graph[prerequisite[0]][prerequisite[1]] = 1; } int cnt = 0; stack\u0026lt;int\u0026gt; st; for(int i=0;i\u0026lt;numCourses;i++){ if(in[i] == 0){ st.push(i); } } while(!st.empty()) { auto top = st.top(); st.pop(); cnt++; for(int i=0;i\u0026lt;numCourses;i++){ if(graph[i][top] != 0){ in[i]--; if(in[i] == 0){ st.push(i); } } } } return cnt == numCourses; } }; 208 实现前缀树 https://leetcode.cn/problems/implement-trie-prefix-tree/\n数据类型的主要结构是children，是一个vector\u0026lt;Trie*\u0026gt;, 长度为26（对应26个字母）以及一个is_end的bool变量代表是否到了结尾。 在插入单词过程中，从this指针开始，遍历字符串的每个字符，每个字符串减去\u0026rsquo;a\u0026rsquo;，获得下标，如果当前指针的child是nullptr，那么创建新的。遍历到最后一个字母，需要将其is_end置true。 search()和startwith()通过深度优先搜索，如果是nullptr那么就没有包含这个单词，search比startwith条件更加苛刻，需要is_end为true\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; children; bool is_end; Trie* dfs(string word){ auto cur = this; for(char c: word){ int idx = c - \u0026#39;a\u0026#39;; if(cur-\u0026gt;children[idx] == nullptr){ return nullptr; } cur = cur-\u0026gt;children[idx]; } return cur; } public: Trie():children(26), is_end(false) { } void insert(string word) { auto cur = this; for(char c: word){ int idx = c-\u0026#39;a\u0026#39;; if(cur-\u0026gt;children[idx] == nullptr){ cur-\u0026gt;children[idx] = new Trie(); } cur = cur-\u0026gt;children[idx]; } cur-\u0026gt;is_end = true; } bool search(string word) { auto res = dfs(word); if(res!=nullptr \u0026amp;\u0026amp; res-\u0026gt;is_end){ return true; } return false; } bool startsWith(string prefix) { auto res = dfs(prefix); if(res!=nullptr){ return true; } return false; } }; 215 数组中的第k大元素 https://leetcode.cn/problems/kth-largest-element-in-an-array/\n1、快速排序的变形 在快速排序中，如果pivot就是第k个，就得到了最终的结果，如果pivot比k要小，那么快排pivot+1到end，如果pivot比k要大，那么快排begin到pivot-1\nclass Solution { private: int res; int k; public: int partition(vector\u0026lt;int\u0026gt;\u0026amp; nums, int begin, int end){ int i = begin-1; int j; int pivot_val = nums[end]; for(j=begin;j\u0026lt;end;j++){ if(nums[j] \u0026gt; pivot_val){ i++; swap(nums[j], nums[i]); } } i++; swap(nums[i], nums[end]); return i; } void quick_sort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int begin, int end){ if(begin \u0026gt;= end){ res = nums[begin]; return; } int pivot = partition(nums, begin, end); if(pivot==k){ res = nums[pivot]; }else if(pivot\u0026lt;k){ quick_sort(nums, pivot+1, end); }else{ quick_sort(nums, begin, pivot-1); } } int findKthLargest(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { this-\u0026gt;k = k-1; quick_sort(nums, 0, nums.size()-1); return res; } }; 2、堆排序 用大根堆，大根堆第一个元素是最大值，进行k次删除堆顶元素之后就是答案\nclass Solution { public: void heapfy(vector\u0026lt;int\u0026gt; \u0026amp;nums, int i, int n){ int largest_idx = i; int left = i*2+1; int right = i*2+2; if(left\u0026lt;n \u0026amp;\u0026amp; nums[left] \u0026gt; nums[largest_idx]){ largest_idx = left; } if(right\u0026lt;n \u0026amp;\u0026amp; nums[right] \u0026gt; nums[largest_idx]){ largest_idx = right; } if(i!=largest_idx){ swap(nums[largest_idx], nums[i]); heapfy(nums, largest_idx, n); } } void build_heap(vector\u0026lt;int\u0026gt;\u0026amp; nums){ int n = nums.size(); for(int i=n/2-1;i\u0026gt;=0;i--){ heapfy(nums, i, n); } } int findKthLargest(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { build_heap(nums); int heap_size = nums.size(); for(int i=0;i\u0026lt;k;i++){ swap(nums[0], nums[heap_size-1]); heap_size--; heapfy(nums, 0, heap_size); } return nums[heap_size]; } }; 221.最大正方形 https://leetcode.cn/problems/maximal-square/\nf[i][j] = min(f[i-1][j-1], min(f[i-1][j], f[i][j-1])) + 1;\nclass Solution { public: int maximalSquare(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; matrix) { int n = matrix.size(); int m = matrix[0].size(); int res = 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(n, vector\u0026lt;int\u0026gt;(m, 0)); for(int i=0;i\u0026lt;n;i++) { f[i][0] = matrix[i][0] == \u0026#39;1\u0026#39;? 1: 0; res = max(res, f[i][0]); } for(int i=0;i\u0026lt;m;i++) { f[0][i] = matrix[0][i] == \u0026#39;1\u0026#39;? 1: 0; res = max(res, f[0][i]); } for(int i=1;i\u0026lt;n;i++) { for(int j=1;j\u0026lt;m;j++) { if(matrix[i][j] == \u0026#39;1\u0026#39;) { f[i][j] = min(f[i-1][j-1], min(f[i-1][j], f[i][j-1])) + 1; res = max(res, f[i][j]); } } } return res*res; } }; 226 翻转二叉树 https://leetcode.cn/problems/invert-binary-tree/\n1、递归方法\nclass Solution { public: TreeNode* invertTree(TreeNode* root) { if(root == nullptr) return root; auto left = invertTree(root-\u0026gt;left); auto right = invertTree(root-\u0026gt;right); root-\u0026gt;left = right; root-\u0026gt;right = left; return root; } }; 2、非递归 用stack或者queue进行储存（两种容器的代码是一样的，只不过或是层序遍历，stack是深度优先遍历）\nclass Solution { public: TreeNode* invertTree(TreeNode* root) { if(root==nullptr){ return nullptr; } queue\u0026lt;TreeNode*\u0026gt; q; q.push(root); while(!q.empty()) { auto front = q.top(); q.pop(); auto left = front-\u0026gt;left; front-\u0026gt;left = front-\u0026gt;right; front-\u0026gt;right = left; if(front-\u0026gt;left){ q.push(front-\u0026gt;left); } if(front-\u0026gt;right){ q.push(front-\u0026gt;right); } } return root; } }; 234 回文链表 https://leetcode.cn/problems/palindrome-linked-list/\n1、用vector储存\nclass Solution { public: bool isPalindrome(ListNode* head) { vector\u0026lt;ListNode*\u0026gt; v; while(head){ v.push_back(head); head = head-\u0026gt;next; } for(int i=0, j=v.size()-1;i\u0026lt;j;i++, j--){ if(v[i]-\u0026gt;val != v[j]-\u0026gt;val){ return false; } } return true; } }; 2、找到中点，翻转链表。 奇数链表中间点被看做前半部分，判断比较前半部分和翻转的后半部分是否相同时，以后半部分为标准。\nclass Solution { public: ListNode* reverse_list(ListNode* head){ ListNode* prev = nullptr; while(head){ auto next = head-\u0026gt;next; head-\u0026gt;next = prev; prev = head; head = next; } return prev; } bool isPalindrome(ListNode* head) { auto fast = head; auto slow = head; while(fast-\u0026gt;next \u0026amp;\u0026amp; fast-\u0026gt;next-\u0026gt;next){ fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; } auto mid = slow-\u0026gt;next; slow-\u0026gt;next = nullptr; mid = reverse_list(mid); while(mid \u0026amp;\u0026amp; head){ if(mid-\u0026gt;val != head-\u0026gt;val){ return false; } mid = mid-\u0026gt;next; head = head-\u0026gt;next; } return true; } }; 236 二叉树的公共祖先 https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/\n1、遍历方法 深度搜索函数搜查是否包含q和p，在搜索过程中，如果root等于q或者p并且left和right某个为正，或者左右都为正，代表是公共祖先\nclass Solution { private: TreeNode* res; public: bool contains(TreeNode* root, TreeNode* p, TreeNode* q){ if(root == nullptr) return false; bool left = contains(root-\u0026gt;left, p, q); bool right = contains(root-\u0026gt;right, p, q); if( ( root==p || root==q) \u0026amp;\u0026amp; (left || right) || (left \u0026amp;\u0026amp; right)){ res = root; return true; } return root==p || root == q ||left || right; } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { contains(root, p, q); return res; } }; 2、递归 递归函数返回值为nullptr表示没有找到\nclass Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root == nullptr || root==p || root==q) return root; auto left = lowestCommonAncestor(root-\u0026gt;left, p, q); auto right = lowestCommonAncestor(root-\u0026gt;right, p, q); if(left \u0026amp;\u0026amp; right) return root; if(left != nullptr) return left; return right; } }; 238 除自身以为的数组的乘积 https://leetcode.cn/problems/product-of-array-except-self/\n维护两个数组，一个是左边累积；一个是右边累积\nclass Solution { public: vector\u0026lt;int\u0026gt; productExceptSelf(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; res(nums.size(), 1); vector\u0026lt;int\u0026gt; left(nums.size(), 1); vector\u0026lt;int\u0026gt; right(nums.size(), 1); for(int i=1;i\u0026lt;nums.size();i++) { left[i] = nums[i-1]*left[i-1]; } for(int i=nums.size()-2;i\u0026gt;=0;i--) { right[i] = nums[i+1]*right[i+1]; } for(int i=1;i\u0026lt;nums.size()-1;i++) { res[i] = left[i]*right[i]; } res[0] = right[0]; res[nums.size()-1] = left[nums.size()-1]; return res; } }; 可以用一个变量代替第二个数组，因为不用保留前面的变量。\n239 滑动窗口的最大值 https://leetcode.cn/problems/sliding-window-maximum/\n1、优先队列 维护一个优先队列，内容是元素的值和下标的pair，每次push元素之前判断队列顶元素下标是否在范围内。\nclass Solution { public: struct node{ int idx; int val; }; struct cmp{ bool operator ()(node\u0026amp; a, node\u0026amp; b){ return a.val \u0026lt; b.val; } }; vector\u0026lt;int\u0026gt; maxSlidingWindow(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { priority_queue\u0026lt;node, vector\u0026lt;node\u0026gt;, cmp\u0026gt; q; vector\u0026lt;int\u0026gt; res; for(int i=0;i\u0026lt;k;i++) { q.push(node{i, nums[i]}); } res.push_back(q.top().val); for(int i=k;i\u0026lt;nums.size();i++) { q.push(node{i, nums[i]}); while(q.top().idx \u0026lt;= i-k){ q.pop(); } res.push_back(q.top().val); } return res; } }; 2、优化——单调队列 维护一个双端队列， 里面存元素的下标，让队列前面元素比后面元素大，且开头元素一定要符合窗口的范围。\nclass Solution { public: vector\u0026lt;int\u0026gt; maxSlidingWindow(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { deque\u0026lt;int\u0026gt; dq; vector\u0026lt;int\u0026gt; res; for (int i = 0; i \u0026lt; k; i++) { while (!dq.empty() \u0026amp;\u0026amp; nums[i] \u0026gt; nums[dq.back()]) { dq.pop_back(); } dq.push_back(i); } res.push_back(nums[dq.front()]); for (int i = k; i \u0026lt; nums.size(); i++) { while (!dq.empty() \u0026amp;\u0026amp; dq.front() \u0026lt;= i - k) { dq.pop_front(); } while (!dq.empty() \u0026amp;\u0026amp; nums[dq.back()] \u0026lt;= nums[i]) { dq.pop_back(); } dq.push_back(i); res.push_back(nums[dq.front()]); } return res; } }; 240 搜索二维矩阵 https://leetcode.cn/problems/search-a-2d-matrix-ii/\n从右上开始搜索\nclass Solution { public: bool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { int n = matrix.size(); int m = matrix[0].size(); int i = 0; int j = m - 1; while (i \u0026lt; n \u0026amp;\u0026amp; j \u0026gt;= 0) { int val = matrix[i][j]; if (val == target) { return true; } else if (val \u0026gt; target) { j--; } else { i++; } } return false; } }; 279 完全平方数 动态规划 f[i] = min(f[i], f[i-jj]+1)，其中(jj≤i)\nclass Solution { public: int numSquares(int n) { vector\u0026lt;int\u0026gt; f(n+1, INT_MAX); f[0] = 0; for(int i=1;i\u0026lt;=n;i++) { for(int j=1;j\u0026lt;=sqrt(i);j++) { f[i] = min(f[i], f[i-j*j]+1); } } return f[n]; } }; 283 移动零 https://leetcode.cn/problems/move-zeroes/\n和快速排序的parition差不多\nclass Solution { public: void moveZeroes(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int idx = -1; for(int i=0;i\u0026lt;nums.size();i++){ if(nums[i] !=0){ ++idx; swap(nums[idx], nums[i]); } } } }; 287 寻找重复数字 https://leetcode.cn/problems/find-the-duplicate-number/\n1、二分法O（n*lgn） 每次n次循环计算\nclass Solution { public: int findDuplicate(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int l = 1; int r = nums.size() - 1; int cnt; while (l \u0026lt; r) { int mid = l + (r - l) / 2; cnt = 0; for (int i = 0; i \u0026lt; nums.size(); i++) { if (nums[i] \u0026lt;= mid) { cnt++; } } if (cnt \u0026gt; mid) { r = mid; } else { l = mid + 1; } } return l; } }; 2、快慢指针 因为一定有某个点有两条线指向自己，所以必定存在环，且环的入口就是重复的数字。同链表的环\nclass Solution { public: int findDuplicate(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int fast = 0; int slow = 0; fast = nums[nums[fast]]; slow = nums[slow]; while (nums[fast] != nums[slow]) { fast = nums[nums[fast]]; slow = nums[slow]; } int cur = 0; while (nums[cur] != nums[slow]) { cur = nums[cur]; slow = nums[slow]; } return nums[slow]; } }; 297 二叉树的序列化和反序列化 https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/\n注意字符串拼接的时候要用+= ，c++底层有优化。 1、层序遍历\nclass Codec { public: vector\u0026lt;string\u0026gt; get_nodes(string data) { vector\u0026lt;string\u0026gt; res; int i = 0; while (i \u0026lt; data.size()) { int j = i; while (j \u0026lt; data.size() \u0026amp;\u0026amp; data[j] != \u0026#39;,\u0026#39;) { j++; } res.push_back(data.substr(i, j - i)); i = j + 1; } return res; } // Encodes a tree to a single string. string serialize(TreeNode* root) { string data = \u0026#34;\u0026#34;; if (root == nullptr) return data; queue\u0026lt;TreeNode*\u0026gt; q; q.push(root); while (!q.empty()) { auto front = q.front(); q.pop(); if (front) { data += to_string(front-\u0026gt;val) + \u0026#34;,\u0026#34;; q.push(front-\u0026gt;left); q.push(front-\u0026gt;right); } else { data += \u0026#34;null,\u0026#34;; } } return data.substr(0, data.size() - 1); } // Decodes your encoded data to tree. TreeNode* deserialize(string data) { if (data.size() == 0) return nullptr; auto nodes = get_nodes(data); queue\u0026lt;TreeNode*\u0026gt; q; auto root = new TreeNode(stoi(nodes[0])); q.push(root); int idx = 1; while (!q.empty()) { auto front = q.front(); q.pop(); if (nodes[idx] != \u0026#34;null\u0026#34;) { front-\u0026gt;left = new TreeNode(stoi(nodes[idx])); q.push(front-\u0026gt;left); } idx++; if (nodes[idx] != \u0026#34;null\u0026#34;) { front-\u0026gt;right = new TreeNode(stoi(nodes[idx])); q.push(front-\u0026gt;right); } idx++; } return root; } }; 300 最长递增子序列 https://leetcode.cn/problems/longest-increasing-subsequence/\n动态规划，要注意把之前的也加上\nclass Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; f(nums.size(), 1); int res = 1; for (int i = 1; i \u0026lt; nums.size(); i++) { for (int j = 0; j \u0026lt; i; j++) { if (nums[i] \u0026gt; nums[j]) { f[i] = max(f[i], f[j] + 1); } } res = max(f[i], res); } return res; } }; 301 删除无效括号 https://leetcode.cn/problems/remove-invalid-parentheses/\n先计算需要删除的左括号和右括号，然后通过深度优先搜索遍历\nclass Solution { private: vector\u0026lt;string\u0026gt; res; public: bool is_pair(char a, char b){ if(a==\u0026#39;)\u0026#39; \u0026amp;\u0026amp; b==\u0026#39;(\u0026#39;) return true; return false; } bool is_valid(string s){ stack\u0026lt;char\u0026gt; stk; for(char c: s){ if(c!=\u0026#39;)\u0026#39; \u0026amp;\u0026amp; c!=\u0026#39;(\u0026#39;) continue; if(!stk.empty() \u0026amp;\u0026amp; is_pair(c, stk.top())){ stk.pop(); }else{ stk.push(c); } } return stk.empty(); } void dfs(string s, int lr, int rr, int idx){ if(lr==0 \u0026amp;\u0026amp; rr == 0 \u0026amp;\u0026amp; is_valid(s)){ res.push_back(s); return; } for(int i=idx;i\u0026lt;s.size();i++){ if(i!=0 \u0026amp;\u0026amp; s[i] == s[i-1]) continue; if(lr+rr \u0026gt; s.size()-i) return; if(s[i] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; lr\u0026gt;0){ dfs(s.substr(0, i)+s.substr(i+1, s.size()-i-1), lr-1, rr, i); } if(s[i] == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; rr\u0026gt;0){ dfs(s.substr(0, i)+s.substr(i+1, s.size()-i-1), lr, rr-1, i); } } } vector\u0026lt;string\u0026gt; removeInvalidParentheses(string s) { int lr = 0; int rr = 0; for(char c: s){ if(c==\u0026#39;(\u0026#39;){ lr++; }else if(c==\u0026#39;)\u0026#39;){ if(lr\u0026gt;0){ lr--; }else{ rr++; } } } dfs(s, lr, rr, 0); return res; } }; 20 有效括号 https://leetcode.cn/problems/valid-parentheses/submissions/ 用stack进行判断，最后判断stack是否为空\nclass Solution { public: bool is_pair(char a, char b) { if (a == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; b == \u0026#39;(\u0026#39;) return true; if (a == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; b == \u0026#39;[\u0026#39;) return true; if (a == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; b == \u0026#39;{\u0026#39;) return true; return false; } bool isValid(string s) { stack\u0026lt;char\u0026gt; st; for (auto c : s) { if (!st.empty() \u0026amp;\u0026amp; is_pair(c, st.top()) == true) { st.pop(); } else { st.push(c); } } return st.empty(); } }; 22 括号生成 https://leetcode.cn/problems/generate-parentheses/\n回溯+剪枝 左括号数量比右括号数量多\nclass Solution { private: vector\u0026lt;string\u0026gt; res; public: void dfs(string\u0026amp; str, int left, int right, int n) { if (left \u0026gt; n || right \u0026gt; n) return; if (left == n \u0026amp;\u0026amp; right == n) { res.push_back(str); } if (left \u0026gt; right) { str.push_back(\u0026#39;(\u0026#39;); dfs(str, left + 1, right, n); str.pop_back(); str.push_back(\u0026#39;)\u0026#39;); dfs(str, left, right + 1, n); str.pop_back(); } else if (left == right) { str.push_back(\u0026#39;(\u0026#39;); dfs(str, left + 1, right, n); str.pop_back(); } } vector\u0026lt;string\u0026gt; generateParenthesis(int n) { int left = 0; int right = 0; string str = \u0026#34;\u0026#34;; dfs(str, left, right, n); return res; } }; 309 买卖股票 121 买卖股票的最佳时机 https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/\n维护一个变量，记录到当前的最小值\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int curMin = INT_MAX; int res = 0; for(int price:prices){ res = max(res, price-curMin); curMin = min(curMin, price); } return res; } }; 122. 买卖股票的最佳时机 II https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/\n不能多次交易股票，在i天结束后，只存在两个状态，0是持有现金，1是持有股票\nf[0][i] = max(f[0][i-1], f[1][i-1]+price[i]) f[1][i] = max(f[1][i-1], f[0][i-1]-price[i]) i天如果持有现金，要么i天没有买股票，那么取i-1天持有现金，或者i天卖出股票 i天如果持有股票， 那么i天没有买股票，那么取i-1天持有股票，或者i天买入股票\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt; \u0026amp;prices) { // 动态规划 vector\u0026lt;vector \u0026lt; int\u0026gt;\u0026gt; f(2, vector\u0026lt;int\u0026gt; (prices.size(), 0)); int cash_hold = 0; int stock_hold = -prices[0]; for (int i = 1; i \u0026lt; prices.size(); i++) { cash_hold = max(cash_hold, stock_hold + prices[i]); stock_hold = max(stock_hold, cash_hold - prices[i]); } return cash_hold; } }; 309 最佳买卖股票时机含冷冻期 https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/\n有冷却期，那么i天结束后就有三种状态：1、持有现金，非冷却期。2、持有现金，冷却期 3、持有股票\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { if (prices.size() == 1 || prices.size() == 0)return 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(3, vector\u0026lt;int\u0026gt;(prices.size())); // f[0][i] 持有现金，非冷冻期 // f[1][i] 持有现金，冷冻期 // f[2][i] 持有股票 f[2][0] = -prices[0]; for (int i = 1; i \u0026lt; prices.size(); i++) { f[0][i] = max(f[0][i - 1], f[1][i - 1]); f[1][i] = f[2][i - 1] + prices[i]; f[2][i] = max(f[2][i - 1], f[0][i - 1] - prices[i]); } return max(f[0][prices.size() - 1], f[1][prices.size() - 1]); } }; 312.戳气球 动态规划要求子问题必须独立，所以我们将其nums扩容2（两个边界-1和n）并设置成1，气球的索引变成了1-n,并且我们将戳气球的操作变成添加气球操作\n题解\n动态规划\ndp[i][j] 表示戳破在i和j之间的气球可以获得的最大值，其中不包括i和j，这样以来就转换成求\ndp[0][n+1] 如果正向思考，那么就是回到回溯。我们需要反向思考，\n谁是最后一个被戳破的气球\n，那就问题就可以被转换成\ndp[i][j] = max(d[i][k]+d[k][j] + points[i]*point[j]*point[k]) d[i][j] 依赖的状态是\nd[i][k] 和\nd[k][j] (其中i\u0026lt;k\u0026lt;j)，所以要注意顺序，\nclass Solution { public: int maxCoins(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;int\u0026gt; val(n + 2, 1); for (int i = 0; i \u0026lt; nums.size(); i++) { val[i + 1] = nums[i]; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n + 2, vector\u0026lt;int\u0026gt;(n + 2, 0)); for (int i = n - 1; i \u0026gt;= 0; i--) { for (int j = i + 1; j \u0026lt;= n + 1; j++) { for (int k = i + 1; k \u0026lt; j; k++) { int sum = dp[i][k] + dp[k][j] + val[i] * val[j] * val[k]; dp[i][j] = max(dp[i][j], sum); } } } return dp[0][n + 1]; } }; 322 零钱兑换 https://leetcode.cn/problems/coin-change/ 动态规划 f[i] = min(f[i-coin]+1, f[i])\nclass Solution { public: int coinChange(vector\u0026lt;int\u0026gt;\u0026amp; coins, int amount) { int max_val = amount + 1; vector\u0026lt;int\u0026gt; f(amount + 1, max_val); f[0] = 0; for (int i = 0; i \u0026lt;= amount; i++) { for (int coin : coins) { if (i - coin \u0026gt;= 0) { f[i] = min(f[i], f[i - coin] + 1); } } } return f[amount] != max_val ? f[amount] : -1; } }; 338 比特位计算 https://leetcode.cn/problems/counting-bits/\n动态规划， 如果i是偶数，那么比特位就是i/2，如果是奇数，那么就是f[i-1]+1 因为偶数的话相当于末尾补了一个0, 如2：10 4：100 奇数的话就相当于上一个偶数添加了一个1, 如2:10 3:11\nclass Solution { public: vector\u0026lt;int\u0026gt; countBits(int n) { vector\u0026lt;int\u0026gt; f(n + 1); f[0] = 0; for (int i = 1; i \u0026lt;= n; i++) { if (i % 2 == 0) { f[i] = f[i / 2]; } else { f[i] = f[i - 1] + 1; } } return f; } }; 347 前k个高频元素 https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/\n先用unordered_map进行存储，之后对频率进行操作，类似于第k个大的元素 1、优先队列\nclass Solution { private: vector\u0026lt;int\u0026gt; res; public: struct node { int val; int freq; }; struct cmp { bool operator()(node a, node b) { return a.freq \u0026lt; b.freq; } }; vector\u0026lt;int\u0026gt; topKFrequent(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { priority_queue\u0026lt;node, vector\u0026lt;node\u0026gt;, cmp\u0026gt; pq; unordered_map\u0026lt;int, int\u0026gt; dict; for (int each : nums) { dict[each]++; } for (auto it = dict.begin(); it != dict.end(); it++) { pq.push(node{ it-\u0026gt;first, it-\u0026gt;second }); } for (int i = 0; i \u0026lt; k; i++) { auto front = pq.top(); pq.pop(); res.push_back(front.val); } return res; } }; ! 394. 字符串解码 使用栈\nhttps://leetcode.cn/problems/decode-string/?favorite=2cktkvj\nclass Solution { public: string decodeString(string s) { string ans = \u0026#34;\u0026#34;; int mul = 0; stack\u0026lt;pair\u0026lt;int, string\u0026gt;\u0026gt; stk; for(int i=0;i\u0026lt;s.size();i++){ char cur = s[i]; if(isdigit(cur)){ mul = mul*10 + cur-\u0026#39;0\u0026#39;; }else if(isalpha(cur)){ if(stk.empty()){ ans.push_back(cur); }else{ stk.top().second.push_back(cur); } }else if(cur == \u0026#39;[\u0026#39;){ stk.push({mul, \u0026#34;\u0026#34;}); mul = 0; }else if(cur == \u0026#39;]\u0026#39;){ auto top = stk.top(); stk.pop(); string tp = \u0026#34;\u0026#34;; for(int i=0;i\u0026lt;top.first;i++){ tp += top.second; } if(stk.empty()){ ans += tp; }else{ stk.top().second += (tp); } } } return ans; } }; 406 根据身高建立队列 https://leetcode.cn/problems/queue-reconstruction-by-height/ cmp函数，第一个顺序是身高（高的排前面），第二顺序前面的人数（人少的排前面） 然后for循环遍历插入，insert位置是vector.begin()+前面排的人数\nclass Solution { public: static bool cmp(vector\u0026lt;int\u0026gt; a, vector\u0026lt;int\u0026gt; b){ if(a[0] != b[0]) return a[0] \u0026gt; b[0]; return a[1] \u0026lt; b[1]; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; reconstructQueue(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; people) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; sort(people.begin(), people.end(), cmp); for(int i=0;i\u0026lt;people.size();i++){ res.insert(res.begin() + people[i][1], people[i]); } return res; } }; 416 分割等和子集 https://leetcode.cn/problems/partition-equal-subset-sum/\n题目要求是是否存在等分子集，首先算出sum，然后转化为背包问题，也就是可以可以完全放下sum/2的物品\nclass Solution { public: bool canPartition(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int sum = 0; for(int val: nums){ sum += val; } if(sum%2 != 0) return false; int target = sum/2; int n = nums.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n+1, vector\u0026lt;int\u0026gt;(target+1, false)); for(int i=0;i\u0026lt;=n;i++) { dp[i][0] = true; } for(int i=1;i\u0026lt;=n;i++) { for(int j=1;j\u0026lt;=target;j++) { if(j-nums[i-1] \u0026lt; 0) { dp[i][j] = dp[i-1][j]; }else{ if(j-nums[i-1] == 0){ dp[i][j] = true; }else{ dp[i][j] = dp[i-1][j-nums[i-1]] || dp[i-1][j]; } } } } return dp[n][target]; } }; 437 路径总和 https://leetcode.cn/problems/path-sum-iii/\n前缀和, dfs回溯\nclass Solution { private: unordered_map\u0026lt;long long, int\u0026gt; cache; int res = 0; public: void dfs(TreeNode* root, long long cur, int targetSum){ cur += root-\u0026gt;val; res += cache[cur-targetSum]; cache[cur]++; if(root-\u0026gt;left) dfs(root-\u0026gt;left, cur, targetSum); if(root-\u0026gt;right) dfs(root-\u0026gt;right, cur, targetSum); cache[cur]--; } int pathSum(TreeNode* root, int targetSum) { if(root == nullptr) return 0; cache[0] = 1; dfs(root, 0, targetSum); return res; } }; 438 找到字符串中所有字母异位词 滑动窗口,注意滑动窗口valid的条件，当windows[add]==need[add]是valid才增加或者减少，valid的数值和need的key值相同时进行左边界改变\nclass Solution { public: vector\u0026lt;int\u0026gt; findAnagrams(string s, string p) { unordered_map\u0026lt;char, int\u0026gt; need; unordered_map\u0026lt;char, int\u0026gt; window; for(char c: p){ need[c]++; } vector\u0026lt;int\u0026gt; res; int left = 0; int right = 0; int valid = 0; while(right\u0026lt;s.size()) { char add = s[right++]; if(need.count(add)) { window[add]++; if(window[add] == need[add]){ valid++; } } while(valid \u0026gt;= need.size()) { char deleted = s[left]; if(right-left==p.size()){ res.push_back(left); } if(need.count(deleted)) { if(window[deleted] == need[deleted]){ valid--; } window[deleted]--; } left++; } } return res; } }; 560 和为 K 的子数组 https://leetcode.cn/problems/subarray-sum-equals-k/\nclass Solution { public: int subarraySum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { unordered_map\u0026lt;long long, int\u0026gt; cache; cache[0] = 1; int cur = 0; int res = 0; for(int i=0;i\u0026lt;nums.size();i++) { cur += nums[i]; res += cache[cur-k]; cache[cur]++; } return res; } }; 448 找到所有数组中消失的数字 https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/\ntricky， 遍历数组， num[i]的index对应的数字加上数组的长度，最后小于等于数组长度的就是消失的。\nclass Solution { public: vector\u0026lt;int\u0026gt; findDisappearedNumbers(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); for(int i=0;i\u0026lt;nums.size();i++) { nums[(nums[i]-1)%n] += n; } vector\u0026lt;int\u0026gt; res; for(int i=0;i\u0026lt;nums.size();i++){ if(nums[i] \u0026lt;=n){ res.push_back(i+1); } } return res; } }; 461 汉明距离 异或\nclass Solution { public: int hammingDistance(int x, int y) { int t = x^y; int op = 1; int res = 0; while(t) { res += t\u0026amp;op; t = t\u0026gt;\u0026gt;1; } return res; } }; 494 目标和 https://leetcode.cn/problems/target-sum\n算出neg的和然后转化为背包问题\nclass Solution { public: int findTargetSumWays(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int sum = 0; for(int num: nums){ sum += num; } int tp = sum - target; if(tp %2 != 0 || tp\u0026lt;0){ return 0; } int neg = tp/2; int n = nums.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n+1, vector\u0026lt;int\u0026gt;(neg+1, 0)); dp[0][0] = 1; for(int i=1;i\u0026lt;=n;i++) { for(int j=0;j\u0026lt;=neg;j++) { int cur = nums[i-1]; if(j- cur \u0026lt; 0){ dp[i][j] = dp[i-1][j]; }else{ dp[i][j] = dp[i-1][j] + dp[i-1][j-cur]; // 不选：计算i-1，j的数量，选了：计算i-1， j-cur的数量； } } } return dp[n][neg]; } }; 538. 把二叉搜索树转换为累加树 深度搜索，不过是先右节点，中间节点，左节点，用全局的cur变量记录\nclass Solution { private: int cur; public: void dfs(TreeNode* root){ if(root==nullptr) return; dfs(root-\u0026gt;right); cur += root-\u0026gt;val; root-\u0026gt;val = cur; dfs(root-\u0026gt;left); } TreeNode* convertBST(TreeNode* root) { dfs(root); return root; } }; 543 二叉树直径 https://leetcode.cn/problems/diameter-of-binary-tree\n定义max_depth函数，在计算最大深度中顺便计算本题结果。\nclass Solution { private: int res = INT_MIN; public: int max_depth(TreeNode* root){ if(root == nullptr) return 0; int left = max_depth(root-\u0026gt;left); int right = max_depth(root-\u0026gt;right); res = max(res, left+right); return 1+max(left, right); } int diameterOfBinaryTree(TreeNode* root) { if(root == nullptr) return 0; max_depth(root); return res; } }; 560 和为 K 的子数组 https://leetcode.cn/problems/subarray-sum-equals-k\n前缀和\nclass Solution { public: int subarraySum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { unordered_map\u0026lt;long long, int\u0026gt; cache; cache[0] = 1; int cur = 0; int res = 0; for(int i=0;i\u0026lt;nums.size();i++) { cur += nums[i]; res += cache[cur-k]; cache[cur]++; } return res; } }; 581 最短无序连续子数组 https://leetcode.cn/problems/shortest-unsorted-continuous-subarray\n分为三段左段，中段和右段。左端和右端是标准的升序数组，中段无序，但是满足其最小值大于左段最大值，最大值小于右端最小值。我们分别从左边开始遍历和从右边开始遍历，左边开始遍历寻找中段end，具体是，如果遍历到的点比最大值还要小那么更新end（原理是右端总是有当前值就是最大值），同理右边开始遍历，寻找中段begin，如果遍历到点比最小值还小那么更新begin（原理是左端总是有当前值就是最小值）\nclass Solution { public: int findUnsortedSubarray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int end = -1; int max_val = nums[0]; for(int i=0;i\u0026lt;nums.size();i++){ max_val = max(max_val, nums[i]); if(nums[i] \u0026lt; max_val){ end = i; } } int start = -1; int min_val = nums[nums.size()-1]; for(int i = nums.size()-1;i\u0026gt;=0;i--){ min_val = min(min_val, nums[i]); if(nums[i]\u0026gt;min_val){ start = i; } } return start==-1? 0: end-start+1; } }; 617 合并二叉树 https://leetcode.cn/problems/merge-two-binary-trees\nclass Solution { public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) { if(root1 == nullptr) return root2; if(root2 == nullptr) return root1; root1-\u0026gt;val = root1-\u0026gt;val + root2-\u0026gt;val; root1-\u0026gt;left = mergeTrees(root1-\u0026gt;left, root2-\u0026gt;left); root1-\u0026gt;right = mergeTrees(root1-\u0026gt;right, root2-\u0026gt;right); return root1; } }; 647 回文子串 https://leetcode.cn/problems/palindromic-substrings\n中心拓展法\nclass Solution { private: int res = 0; public: void extend_center(string\u0026amp; s, int start, int end) { while(start\u0026gt;=0 \u0026amp;\u0026amp; end\u0026lt;s.size() \u0026amp;\u0026amp; s[start] == s[end]) { res++; start--; end++; } } int countSubstrings(string s) { for(int i=0;i\u0026lt;s.size();i++) { extend_center(s, i, i+1); extend_center(s, i, i); } return res; } }; 739 每日温度 单调栈\nclass Solution { public: vector\u0026lt;int\u0026gt; dailyTemperatures(vector\u0026lt;int\u0026gt;\u0026amp; temperatures) { stack\u0026lt;int\u0026gt; st; vector\u0026lt;int\u0026gt; res(temperatures.size(), 0); for(int i=0;i\u0026lt;temperatures.size();i++) { while(!st.empty() \u0026amp;\u0026amp; temperatures[st.top()] \u0026lt; temperatures[i] ) { res[st.top()] = i-st.top(); st.pop(); } st.push(i); } return res; } }; 621 任务调度器 tricky\nclass Solution { public: static bool cmp(int x, int y){ return x\u0026gt;y; } int leastInterval(vector\u0026lt;char\u0026gt;\u0026amp; tasks, int n) { int len = tasks.size(); vector\u0026lt;int\u0026gt; vec(26); for(char c: tasks) vec[c-\u0026#39;A\u0026#39;]++; sort(vec.begin(), vec.end(), cmp); int cnt = 0; while(cnt\u0026lt;vec.size() \u0026amp;\u0026amp; vec[cnt]==vec[0]) cnt++; return max(len, cnt+(n+1)*(vec[0]-1)); } }; 1 两数之和 https://leetcode.cn/problems/two-sum/\n用unordered_map储存\nclass Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_map\u0026lt;int, int\u0026gt; dict; vector\u0026lt;int\u0026gt; res; if(nums.size() == 0){ return res; } for(int i=0;i\u0026lt;nums.size();i++){ if(dict.count(nums[i])){ res.push_back(i); res.push_back(dict[nums[i]]); return res; } dict[target-nums[i]] = i; } return res; } }; 2 两数相交 链表，注意进位的最后一次运算\nclass Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { // // 9 9 9 9 9 9 9 // 9 9 9 9 // auto dummy = new ListNode(0); auto cur = dummy; int val; int x = 0; while(l1 \u0026amp;\u0026amp; l2){ val = l1-\u0026gt;val+l2-\u0026gt;val + x; x = val/10; cur-\u0026gt;next = new ListNode(val%10); cur = cur-\u0026gt;next; l1 = l1-\u0026gt;next; l2 = l2-\u0026gt;next; } if(l1==nullptr){ swap(l1, l2); } while(l1){ val = l1-\u0026gt;val + x; x = val/10; cur-\u0026gt;next = new ListNode(val%10); cur = cur-\u0026gt;next; l1 = l1-\u0026gt;next; } if(x){ cur-\u0026gt;next = new ListNode(x); cur = cur-\u0026gt;next; } return dummy-\u0026gt;next; } }; 3 无重复字符的最长子串 https://leetcode.cn/problems/longest-substring-without-repeating-characters/\n双指针or滑动窗口？\n利用哈希表unordered_map\u0026lt;char, int\u0026gt;记录字符出现的位置，左指针初始为-1，左开右比，每次更新左指针的最大值\nclass Solution { public: int lengthOfLongestSubstring(string s) { int res = 0; unordered_map\u0026lt;char, int\u0026gt; cache; int left = -1; for(int right=0;right\u0026lt;s.size();right++){ char cur = s[right]; if(cache.count(cur)){ left = max(left, cache[cur]); } res = max(res, right-left); cache[cur] = right; } return res; } }; 4 寻找两个正序数组的中位数 将问题化简，当数组是奇数个时，求中间的那个，偶数时求中间的两位数，为了防止分类讨论，将问题转换为求第(n+m+1)/2个数字和第(n+m+2)/2个数字\n这道题让我们求两个有序数组的中位数，而且限制了时间复杂度为O(log (m+n))，看到这个时间复杂度，自然而然的想到了应该使用二分查找法来求解。那么回顾一下中位数的定义，如果某个有序数组长度是奇数，那么其中位数就是最中间那个，如果是偶数，那么就是最中间两个数字的平均值。这里对于两个有序数组也是一样的，假设两个有序数组的长度分别为m和n，由于两个数组长度之和 m+n 的奇偶不确定，因此需要分情况来讨论，对于奇数的情况，直接找到最中间的数即可，偶数的话需要求最中间两个数的平均值。为了简化代码，不分情况讨论，我们使用一个小trick，我们分别找第 (m+n+1) / 2 个，和 (m+n+2) / 2 个，然后求其平均值即可，这对奇偶数均适用。加入 m+n 为奇数的话，那么其实 (m+n+1) / 2 和 (m+n+2) / 2 的值相等，相当于两个相同的数字相加再除以2，还是其本身。\n这里我们需要定义一个函数来在两个有序数组中找到第K个元素，下面重点来看如何实现找到第K个元素。首先，为了避免产生新的数组从而增加时间复杂度，我们使用两个变量i和j分别来标记数组nums1和nums2的起始位置。然后来处理一些边界问题，比如当某一个数组的起始位置大于等于其数组长度时，说明其所有数字均已经被淘汰了，相当于一个空数组了，那么实际上就变成了在另一个数组中找数字，直接就可以找出来了。还有就是如果K=1的话，那么我们只要比较nums1和nums2的起始位置i和j上的数字就可以了。难点就在于一般的情况怎么处理？因为我们需要在两个有序数组中找到第K个元素，为了加快搜索的速度，我们要使用二分法，对K二分，意思是我们需要分别在nums1和nums2中查找第K/2个元素，注意这里由于两个数组的长度不定，所以有可能某个数组没有第K/2个数字，所以我们需要先检查一下，数组中到底存不存在第K/2个数字，如果存在就取出来，否则就赋值上一个整型最大值。如果某个数组没有第K/2个数字，那么我们就淘汰另一个数字的前K/2个数字即可。有没有可能两个数组都不存在第K/2个数字呢，这道题里是不可能的，因为我们的K不是任意给的，而是给的m+n的中间值，所以必定至少会有一个数组是存在第K/2个数字的。最后就是二分法的核心啦，比较这两个数组的第K/2小的数字midVal1和midVal2的大小，如果第一个数组的第K/2个数字小的话，那么说明我们要找的数字肯定不在nums1中的前K/2个数字，所以我们可以将其淘汰，将nums1的起始位置向后移动K/2个，并且此时的K也自减去K/2，调用递归。反之，我们淘汰nums2中的前K/2个数字，并将nums2的起始位置向后移动K/2个，并且此时的K也自减去K/2，调用递归即可。\nclass Solution { public: double findKth(vector\u0026lt;int\u0026gt;\u0026amp; nums1, int i1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int i2, int k){ if(i1 \u0026gt;= nums1.size()) return nums2[i2+k-1]; if(i2 \u0026gt;= nums2.size()) return nums1[i1+k-1]; if(k==1) return min(nums1[i1], nums2[i2]); int nums1_mid = i1+(k/2)-1 \u0026gt;= nums1.size() ? INT_MAX: nums1[i1+(k/2)-1]; int nums2_mid = i2+(k/2)-1 \u0026gt;= nums2.size() ? INT_MAX: nums2[i2+(k/2)-1]; if(nums1_mid \u0026gt; nums2_mid){ return findKth(nums1, i1, nums2, i2+(k/2), k-k/2); } return findKth(nums1, i1+(k/2), nums2, i2, k-k/2); } double findMedianSortedArrays(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { int n = nums1.size(); int m = nums2.size(); int left = (m+n+1)/2; int right = (m+n+2)/2; return (1.0*findKth(nums1, 0, nums2, 0, left) + findKth(nums1, 0, nums2, 0, right))/2; } }; 5 最长回文字串 trick中间增长法\nclass Solution { private: string res; public: void extend_mid(string \u0026amp;s , int i1, int i2){ while(i1\u0026gt;=0 \u0026amp;\u0026amp; i2\u0026lt;s.size() \u0026amp;\u0026amp; s[i1] == s[i2]){ int len = i2-i1+1; if(len\u0026gt;res.size()){ res = s.substr(i1, len); } i1--; i2++; } } string longestPalindrome(string s) { for(int i=0;i\u0026lt;s.size();i++) { extend_mid(s, i, i+1); extend_mid(s, i, i); } return res; } }; 11 盛最多水的容器 双指针\nhttps://leetcode.cn/problems/container-with-most-water/\nleft=0， right = size()-1, 当前的水容量是\n$$ min(height[left], height[right])* (right-left) $$\n当减少宽度时，如果移动更高的一边，那么容量肯定只会减少，如果移动更高的一边，容量可能减少也可能增加\nclass Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int res = INT_MIN; int left = 0; int right = height.size()-1; while(left\u0026lt;right) { res = max(res, (right-left)*min(height[left], height[right])); if(height[left]\u0026lt;height[right]){ left++; }else{ right--; } } return res; } }; 15 三数之和 首先对数组进行排序，然后转换为两数之和。（其中要进行去重 both in main and two sum）\nclass Solution { private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; public: void twoSum(vector\u0026lt;int\u0026gt; nums, int start, int target){ int left = start+1; int right = nums.size()-1; while(left\u0026lt;right){ int cur = nums[left] + nums[right]; if(cur == target){ res.push_back(vector\u0026lt;int\u0026gt;{nums[left], nums[right], nums[start]}); int left_val = nums[left]; int right_val = nums[right]; while(left\u0026lt;right \u0026amp;\u0026amp; nums[left] == left_val) left++; while(left\u0026lt;right \u0026amp;\u0026amp; nums[right] == right_val) right--; }else if(cur\u0026lt;target){ left++; }else{ right--; } } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { sort(nums.begin(), nums.end()); for(int i=0;i\u0026lt;nums.size();i++) { if(i!=0 \u0026amp;\u0026amp; nums[i] == nums[i-1]) continue; twoSum(nums, i, -nums[i]); } return res; } }; 17 电话号码的字母组合 https://leetcode.cn/problems/letter-combinations-of-a-phone-number/\nclass Solution { private: unordered_map\u0026lt;char, string\u0026gt; dict = { {\u0026#39;2\u0026#39;, \u0026#34;abc\u0026#34;}, {\u0026#39;3\u0026#39;, \u0026#34;def\u0026#34;}, {\u0026#39;4\u0026#39;, \u0026#34;ghi\u0026#34;}, {\u0026#39;5\u0026#39;, \u0026#34;jkl\u0026#34;}, {\u0026#39;6\u0026#39;, \u0026#34;mno\u0026#34;}, {\u0026#39;7\u0026#39;, \u0026#34;qprs\u0026#34;}, {\u0026#39;8\u0026#39;, \u0026#34;tuv\u0026#34;}, {\u0026#39;9\u0026#39;, \u0026#34;wxyz\u0026#34;}, }; vector\u0026lt;string\u0026gt; res; public: void dfs(string\u0026amp; digits, int idx, string\u0026amp; cur) { if(idx == digits.size()){ res.push_back(cur); } for(int i=0;i\u0026lt;dict[digits[idx]].size();i++) { cur.push_back(dict[digits[idx]][i]); dfs(digits, idx+1, cur); cur.pop_back(); } } vector\u0026lt;string\u0026gt; letterCombinations(string digits) { if(digits.size() == 0) return res; string cur = \u0026#34;\u0026#34;; dfs(digits, 0, cur); return res; } }; 19 删除链表的倒数第 N 个结点 https://leetcode.cn/problems/remove-nth-node-from-end-of-list\nclass Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { auto dummy = new ListNode(0); dummy-\u0026gt;next = head; auto fast = dummy; auto slow = dummy; for(int i=0;i\u0026lt;n;i++){ fast = fast-\u0026gt;next; } while(fast-\u0026gt;next){ fast = fast-\u0026gt;next; slow = slow-\u0026gt;next; } slow-\u0026gt;next = slow-\u0026gt;next-\u0026gt;next; return dummy-\u0026gt;next; } }; 20 有效括号 https://leetcode.cn/problems/valid-parentheses\n使用栈\nclass Solution { public: bool is_pair(char a, char b){ if(a==\u0026#39;)\u0026#39; \u0026amp;\u0026amp; b==\u0026#39;(\u0026#39;) return true; if(a==\u0026#39;]\u0026#39; \u0026amp;\u0026amp; b==\u0026#39;[\u0026#39;) return true; if(a==\u0026#39;}\u0026#39; \u0026amp;\u0026amp; b==\u0026#39;{\u0026#39;) return true; return false; } bool isValid(string s) { stack\u0026lt;char\u0026gt; st; for(auto c:s){ if(!st.empty() \u0026amp;\u0026amp; is_pair(c, st.top())==true){ st.pop(); }else{ st.push(c); } } return st.empty(); } }; 合并两个有序链表 https://leetcode.cn/problems/merge-two-sorted-lists/\n递归 class Solution { public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { if(list1 == nullptr) return list2; if(list2 == nullptr) return list1; if(list1-\u0026gt;val \u0026gt; list2-\u0026gt;val){ swap(list1, list2); } list1-\u0026gt;next = mergeTwoLists(list1-\u0026gt;next, list2); return list1; } }; 迭代 class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(!l1) return l2; if(!l2) return l1; ListNode* dummy = new ListNode(0); ListNode* tp = dummy; while(l1\u0026amp;\u0026amp;l2){ if(l1-\u0026gt;val \u0026lt; l2-\u0026gt;val){ tp-\u0026gt;next = l1; l1 = l1-\u0026gt;next; }else{ tp-\u0026gt;next = l2; l2 = l2-\u0026gt;next; } tp = tp-\u0026gt;next; } if(l1) tp-\u0026gt;next = l1; if(l2) tp-\u0026gt;next = l2; return dummy-\u0026gt;next; } }; 括号生成 https://leetcode.cn/problems/generate-parentheses\n深度搜索，其中注意左括号数量永远大于等于右括号\nclass Solution { private: vector\u0026lt;string\u0026gt; res; int n; public: void dfs(string\u0026amp; cur, int left, int right){ if(left\u0026gt;n || right\u0026gt;n || left\u0026lt;right){ return; } if(left==n \u0026amp;\u0026amp; right==n){ res.push_back(cur); } cur.push_back(\u0026#39;(\u0026#39;); dfs(cur, left+1, right); cur.pop_back(); cur.push_back(\u0026#39;)\u0026#39;); dfs(cur, left, right+1);; cur.pop_back(); } vector\u0026lt;string\u0026gt; generateParenthesis(int n) { string tp = \u0026#34;\u0026#34;; this-\u0026gt;n = n; dfs(tp, 0, 0); return res; } }; 23 合并K个升序链表 利用堆，注意大于是小根堆，小于是大根堆\nclass Solution { public: class cmp{ public: bool operator ()(ListNode* a, ListNode* b){ return a-\u0026gt;val \u0026gt; b-\u0026gt;val; } }; ListNode* mergeKLists(vector\u0026lt;ListNode*\u0026gt;\u0026amp; lists) { auto dummy = new ListNode(0); auto cur = dummy; priority_queue\u0026lt;ListNode*, vector\u0026lt;ListNode*\u0026gt;, cmp\u0026gt; q; for(auto\u0026amp; node: lists){ if(node!=nullptr){ q.push(node); } } while(!q.empty()) { auto front = q.top(); q.pop(); cur-\u0026gt;next = front; cur = cur-\u0026gt;next; if(front-\u0026gt;next != nullptr){ q.push(front-\u0026gt;next); } } return dummy-\u0026gt;next; } }; !31 下一个排列 class Solution { public: void nextPermutation(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int i = nums.size()-1; while(i\u0026gt;0){ if(nums[i-1] \u0026lt; nums[i]){ break; } i--; } if(i==0){ sort(nums.begin(), nums.end()); return; } i = i-1; int j = nums.size() - 1; while(j\u0026gt;=0){ if(nums[j] \u0026gt; nums[i]){ break; } j--; } swap(nums[i], nums[j]); sort(nums.begin()+i+1, nums.end()); } }; 32. 最长有效括号 https://leetcode.cn/problems/longest-valid-parentheses/\n动态规划\ndp[i] 是i个位置的字符为结尾的有效括号长度\n当s[i]是(的时候，dp[i]为0，\n当s[i]是)的时候, 讨论s[i-1]的情况\n当s[i-1]是(，那么 dp[i] = dp[i-2]+2; 注意i-2的是合法\n当s[i-2]是), 那么需要讨论i-1-len，len是dp[i-1]的值，如果s[i-1-len]是(，那么dp[i] = dp[i-1]+dp[i-1-dp[i-1]-1] +2\n最终返回所有dp的最大值\nclass Solution { public: int longestValidParentheses(string s) { vector\u0026lt;int\u0026gt; dp(s.size(), 0); if(s.size() == 0) return 0; int res = 0; for(int i=1;i\u0026lt;s.size();i++) { if(s[i] == \u0026#39;(\u0026#39;){ dp[i] = 0; }else if(s[i] == \u0026#39;)\u0026#39;){ if(s[i-1] == \u0026#39;(\u0026#39;){ dp[i] = 2; if(i-2\u0026gt;=0){ dp[i] += dp[i-2]; } }else{ if(dp[i-1]\u0026gt;0){ int len = dp[i-1]; int start = i-1-len; if(start\u0026gt;=0){ if(s[start] == \u0026#39;(\u0026#39;){ dp[i] = dp[i-1] + 2; if(start-1 \u0026gt;=0){ dp[i] += dp[start-1]; } } }else{ dp[i] = 0; } } } } res = max(res, dp[i]); } return res; } }; 49 字母异分位词 利用dict\nclass Solution { private: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; res; unordered_map\u0026lt;string, vector\u0026lt;string\u0026gt;\u0026gt; cache; vector\u0026lt;bool\u0026gt; visit; public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; groupAnagrams(vector\u0026lt;string\u0026gt;\u0026amp; strs) { for(auto\u0026amp; str: strs){ auto reve = str; sort(reve.begin(), reve.end()); cache[reve].push_back(str); } for(auto it=cache.begin();it!=cache.end();it++){ res.push_back(it-\u0026gt;second); } return res; } }; 53 最大子数组和 动态规划\nclass Solution { public: int maxSubArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int cur = nums[0]; int res = nums[0]; for(int i=1;i\u0026lt;nums.size();i++){ cur = max(nums[i], nums[i]+cur); res = max(res, cur); } return res; } }; 55 跳跃游戏 https://leetcode.cn/problems/jump-game/\n贪心，定义一个最远能跳的距离most_right, 遍历数组，如果能小于等于most_right,那么通过该下表推进most_right\nclass Solution { public: bool canJump(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int most_right = 0; for(int i=0;i\u0026lt;nums.size();i++) { if(i \u0026lt;= most_right){ most_right = max(most_right, i+nums[i]); if(most_right\u0026gt;=nums.size()-1){ return true; } } } return false; } }; 33 搜索旋转排序数组 二分搜索，分类讨论，target是在两块区间的那个部分（和nums[0]作比较），然后再讨论num[mid]在哪个区间\nclass Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0; int right = nums.size(); while(left\u0026lt;right){ int mid = left + (right-left)/2; if(nums[mid] == target) return mid; if(target==nums[0]) return 0; if(target\u0026gt;nums[0]) { if(nums[mid] \u0026gt; target){ right = mid; }else{ // target \u0026lt; mid; if(nums[mid] \u0026gt; nums[0]){ left = mid+1; }else{ right = mid; } } }else{ if(nums[mid]\u0026lt;target){ left = mid+1; }else{ if(nums[mid]\u0026gt;nums[0]){ left = mid+1; }else{ right = mid; } } } } return -1; } }; 56 合并区间 https://leetcode.cn/problems/merge-intervals\n首先对区间进行sort，第一排序顺序是左边界，第二排序顺序号是右边边界，建立 result vector数组，对区间进行遍历，如果区间右边界大于result数组最后一个的右边界，那么push进去，否则对result最后一个的右边界进行扩增\nclass Solution { public: static bool cmp(vector\u0026lt;int\u0026gt; a, vector\u0026lt;int\u0026gt; b){ if(a[0] != b[0]) return a[0] \u0026lt; b[0]; return a[1] \u0026lt; b[1]; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; merge(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { sort(intervals.begin(), intervals.end(), cmp); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; res.push_back(intervals[0]); for(int i=1;i\u0026lt;intervals.size();i++) { auto cur = intervals[i]; auto last = res[res.size() - 1]; if(cur[0] \u0026gt; last[1]){ res.push_back(cur); }else{ res[res.size()-1][1] = max(last[1], cur[1]); } } return res; } }; 34 在排序数组中查找元素的第一个和最后一个位置 https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array\nupper_bound和lower_bound函数的实现\n要注意两点，第一个是注意返回的idx的合法性，第二个是upper_bound返回的index需要-1\nclass Solution { public: int lower_bound(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target){ int left = 0; int right = nums.size(); while(left\u0026lt;right) { int mid = left + (right-left)/2; if(target\u0026gt;nums[mid]){ // (mid, right) left = mid+1; }else if(target==nums[mid]){ right = mid; }else{ // // target \u0026lt; nums[mid] right = mid; } } return left; } int upper_bound(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target){ int left = 0; int right = nums.size(); while(left \u0026lt; right){ int mid = left+(right-left)/2; if(target\u0026gt;nums[mid]){ // () left = mid+1; }else if(target == nums[mid]){ left = mid+1; }else{ // target \u0026lt; nums[mid] right = mid; } } return left; } vector\u0026lt;int\u0026gt; searchRange(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int upper = upper_bound(nums, target); int lower = lower_bound(nums, target); vector\u0026lt;int\u0026gt; res{-1, -1}; if(lower \u0026gt;=0 \u0026amp;\u0026amp; lower\u0026lt;nums.size() \u0026amp;\u0026amp; nums[lower] == target) res[0] = lower; if(upper-1 \u0026gt;= 0 \u0026amp;\u0026amp; upper-1\u0026lt;nums.size() \u0026amp;\u0026amp; nums[upper-1] == target) res[1] = upper-1; return res; } }; ！39 组合总和 https://leetcode.cn/problems/combination-sum/submissions/ 经典题目，回溯剪枝，当前节点 选择还是不选择？ 选择的话：\ncur_vec.push_back(candidates[cur_idx]); dfs(candidates, cur_val+candidates[cur_idx], cur_idx, target, cur_vec); cur_vec.pop_back(); 如果不选择\ndfs(candidates, cur_val, cur_idx+1, target, cur_vec); class Solution { private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; public: void dfs(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int cur_val, int cur_idx, int target, vector\u0026lt;int\u0026gt;\u0026amp; cur_vec){ if(cur_val == target){ res.push_back(cur_vec); return; } if(cur_val \u0026gt; target || cur_idx\u0026gt;=candidates.size()){ return; } // 选择当前路径 cur_vec.push_back(candidates[cur_idx]); dfs(candidates, cur_val+candidates[cur_idx], cur_idx, target, cur_vec); cur_vec.pop_back(); // 不选择当前路径 dfs(candidates, cur_val, cur_idx+1, target, cur_vec); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { vector\u0026lt;int\u0026gt; cur_vec; dfs(candidates, 0, 0, target, cur_vec); return res; } }; 42 接雨水 维护一个left_max和right_max\nclass Solution { public: int trap(vector\u0026lt;int\u0026gt;\u0026amp; height) { int left = 0; int right = height.size()-1; int res = 0; int max_left = height[left]; int max_right = height[right]; while(left \u0026lt; right) { if(height[left] \u0026gt; height[right]){ res += max(0, max_right - height[right]); max_right = max(max_right, height[right]); right--; }else{ res += max(0, max_left-height[left]); max_left = max(max_left, height[left]); left++; } } return res; } }; 46 全排列 https://leetcode.cn/problems/permutations\n回溯，visit数组\nclass Solution { private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; vector\u0026lt;bool\u0026gt; visit; public: void dfs(vector\u0026lt;int\u0026gt; \u0026amp; nums, vector\u0026lt;int\u0026gt;\u0026amp; cur_vec){ if(cur_vec.size() == nums.size()){ res.push_back(cur_vec); return; } for(int i=0;i\u0026lt;nums.size();i++) { if(visit[i] == false) { visit[i] = true; cur_vec.push_back(nums[i]); dfs(nums, cur_vec); cur_vec.pop_back(); visit[i] = false; } } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; nums) { visit = vector\u0026lt;bool\u0026gt; (nums.size(), false); vector\u0026lt;int\u0026gt; cur_vec; dfs(nums, cur_vec); return res; } }; 48 旋转图像 https://leetcode.cn/problems/rotate-image/\n先进行轴翻转，然后行reverse，在轴翻转的过程中注意i的范围是(0, n), j的范围是(i, m)，否则的话翻过来再翻过去等于没翻\nclass Solution { public: void rotate(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int n = matrix.size(); int m = matrix[0].size(); for(int i=0;i\u0026lt;n;i++) { for(int j=i;j\u0026lt;m;j++) { swap(matrix[i][j], matrix[j][i]); } } for(auto\u0026amp; row: matrix) { reverse(row.begin(), row.end()); } } }; 53 最大子数组和 https://leetcode.cn/problems/maximum-subarray/submissions/\n动态规划\nclass Solution { public: int maxSubArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int ans = nums[0]; int cur = nums[0]; for(int i=1;i\u0026lt;nums.size();i++){ cur = max(nums[i], cur+nums[i]); ans = max(ans, cur); } return ans; } }; 49 分母异位词 https://leetcode.cn/problems/group-anagrams/?\n利用dict和sort函数\nclass Solution { private: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; res; unordered_map\u0026lt;string, vector\u0026lt;string\u0026gt;\u0026gt; cache; vector\u0026lt;bool\u0026gt; visit; public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; groupAnagrams(vector\u0026lt;string\u0026gt;\u0026amp; strs) { for(auto\u0026amp; str: strs){ auto reve = str; sort(reve.begin(), reve.end()); cache[reve].push_back(str); } for(auto it=cache.begin();it!=cache.end();it++){ res.push_back(it-\u0026gt;second); } return res; } }; 不同路径 动态规划\nclass Solution { public: int uniquePaths(int m, int n) { swap(n, m); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(n, vector\u0026lt;int\u0026gt;(m, 0)); for(int i=0;i\u0026lt;n;i++){ f[i][0] = 1; } for(int i=0;i\u0026lt;m;i++){ f[0][i] = 1; } for(int i=1;i\u0026lt;n;i++){ for(int j=1;j\u0026lt;m;j++){ f[i][j] = f[i-1][j]+f[i][j-1]; } } return f[0][0]; } }; 64 最小路径和 动态规划\nhttps://leetcode.cn/problems/minimum-path-sum/\nclass Solution { public: int minPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(); int m = grid[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(n, vector\u0026lt;int\u0026gt;(m, 0)); f[0][0] = grid[0][0]; for(int i=1;i\u0026lt;n;i++){ f[i][0] = f[i-1][0] + grid[i][0]; } for(int i=1;i\u0026lt;m;i++){ f[0][i] = f[0][i-1] + grid[0][i]; } for(int i=1;i\u0026lt;n;i++) { for(int j=1;j\u0026lt;m;j++) { f[i][j] = min(f[i-1][j], f[i][j-1]) + grid[i][j]; } } return f[n-1][m-1]; } }; 70 爬楼梯 动态规划\nhttps://leetcode.cn/problems/climbing-stairs/\nclass Solution { public: int climbStairs(int n) { int prev = 1; int cur = 2; if(n==1) return 1; if(n==2) return 2; for(int i=3;i\u0026lt;=n;i++){ int tp = cur; cur = prev+cur; prev = tp; } return cur; } }; 72 编辑距离 动态规划\nclass Solution { private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f; public: int dfs(string\u0026amp; word1, string\u0026amp; word2, int i, int j){ if(i==0){ return j; } if(j==0){ return i; } if(word1[i-1] == word2[j-1]){ if(f[i-1][j-1] == -1){ f[i][j] = dfs(word1, word2, i-1, j-1); }else{ f[i][j] = f[i-1][j-1]; } return f[i][j]; } int delete_ , insert_, replace_; delete_ = f[i-1][j] != -1 ? f[i-1][j]+1 : dfs(word1, word2, i-1, j)+1; insert_ = f[i][j-1] != -1 ? f[i][j-1]+1 : dfs(word1, word2, i, j-1)+1; replace_ = f[i-1][j-1] != -1 ? f[i-1][j-1]+1 : dfs(word1, word2, i-1, j-1)+1; f[i][j] = min(min(delete_, insert_), replace_); return f[i][j]; } int minDistance(string word1, string word2) { f = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; (word1.size()+1, vector\u0026lt;int\u0026gt;(word2.size()+1, -1)); return dfs(word1, word2, word1.size(), word2.size()); } }; 75 颜色分类 https://leetcode.cn/problems/sort-colors/\n三指针\n本质就是三个指针，头指针和中指针负责0和1的交换，中指针和尾指针负责把2移到末\nclass Solution { public: void sortColors(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 三指针 int red_idx = 0; int blue_idx = nums.size()-1; int white_idx = 0; while(white_idx \u0026lt;= blue_idx){ if(nums[white_idx] == 1){ white_idx++; }else if(nums[white_idx] == 0){ swap(nums[white_idx], nums[red_idx]); red_idx++; white_idx++; }else{ swap(nums[blue_idx], nums[white_idx]); blue_idx--; } } } }; 78 子集 回溯， 两条路，选或者不选\nclass Solution { private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; public: void dfs(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;int\u0026gt;\u0026amp; cur, int idx){ if(idx\u0026gt;=nums.size()){ res.push_back(cur); return; } dfs(nums, cur, idx+1); cur.push_back(nums[idx]); dfs(nums, cur, idx+1); cur.pop_back(); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; cur; dfs(nums, cur, 0); return res; } }; 柱状图中的最大矩形 https://leetcode.cn/problems/maximal-rectangle/\n单调栈\nclass Solution { public: int largestRectangleArea(vector\u0026lt;int\u0026gt;\u0026amp; heights) { vector\u0026lt;int\u0026gt; left_min(heights.size(), -1); vector\u0026lt;int\u0026gt; right_min(heights.size(), heights.size()); stack\u0026lt;int\u0026gt; stk; for(int i=0;i\u0026lt;heights.size();i++) { while(!stk.empty() \u0026amp;\u0026amp; heights[i] \u0026lt; heights[stk.top()]){ right_min[stk.top()] = i; stk.pop(); } stk.push(i); } stk = stack\u0026lt;int\u0026gt;{}; for(int i=heights.size()-1;i\u0026gt;=0;i--) { while(!stk.empty() \u0026amp;\u0026amp; heights[i] \u0026lt; heights[stk.top()]){ left_min[stk.top()] = i; stk.pop(); } stk.push(i); } int res = 0; for(int i=0;i\u0026lt;heights.size();i++) { int left = left_min[i]; int right = right_min[i]; res = max(res, (right-left-1)* heights[i]); } return res; } }; 85 最大矩形 单调栈\n！ 注意matrix是字符的情况，转换成int的matrix的时候一定要注意先决条件matrix[i][j] == \u0026lsquo;0\u0026rsquo;\nclass Solution { public: int maximalRectangle(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; matrix) { int n = matrix.size(); int m = matrix[0].size(); int res = 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; int_matrix(n, vector\u0026lt;int\u0026gt;(m, 0)); for(int i=0;i\u0026lt;n;i++) { int_matrix[i][0] = matrix[i][0] == \u0026#39;0\u0026#39; ? 0 : 1; } for(int i=0;i\u0026lt;n;i++) { for(int j=1;j\u0026lt;m;j++) { if(matrix[i][j] == \u0026#39;1\u0026#39;) int_matrix[i][j] = int_matrix[i][j-1] + 1; } } for(int j=0;j\u0026lt;m;j++) { vector\u0026lt;int\u0026gt; down_min(n, n); vector\u0026lt;int\u0026gt; up_min(n, -1); stack\u0026lt;int\u0026gt; stk; for(int i=0;i\u0026lt;n;i++) { while(!stk.empty() \u0026amp;\u0026amp; int_matrix[stk.top()][j] \u0026gt; int_matrix[i][j]){ down_min[stk.top()] = i; stk.pop(); } stk.push(i); } stk = stack\u0026lt;int\u0026gt;{}; for(int i=n-1;i\u0026gt;=0;i--) { while(!stk.empty() \u0026amp;\u0026amp; int_matrix[stk.top()][j] \u0026gt; int_matrix[i][j]){ up_min[stk.top()] = i; stk.pop(); } stk.push(i); } for(int i=0;i\u0026lt;n;i++) { res = max(res, int_matrix[i][j] * (down_min[i]-up_min[i]-1)); } } return res; } }; 94 二叉树的中序遍历 掌握非递归方法\nclass Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { stack\u0026lt;TreeNode* \u0026gt; stk; vector\u0026lt;int\u0026gt; res; auto cur = root; while(cur || !stk.empty()) { while(cur){ stk.push(cur); cur = cur-\u0026gt;left; } auto top = stk.top(); stk.pop(); res.push_back(top-\u0026gt;val); if(top-\u0026gt;right) cur = top-\u0026gt;right; } return res; } }; 不同的二叉搜索树 https://leetcode.cn/problems/unique-binary-search-trees\nclass Solution { public: int numTrees(int n) { vector\u0026lt;int\u0026gt; g(n+1); if(n == 1) return 1; g[1] = 1; g[2] = 2; g[0] = 1; for(int i=3;i\u0026lt;=n;i++) { for(int j=1;j\u0026lt;=i;j++) { g[i] += g[j-1] * g[i-j]; } } return g[n]; } }; 98 验证二叉搜索树 https://leetcode.cn/problems/validate-binary-search-tree/\n利用二叉搜索树中序遍历的性质\nclass Solution { private: bool res = true; int cur = INT_MIN; bool init = false; public: void dfs(TreeNode* root){ if(root==nullptr) return; dfs(root-\u0026gt;left); if(init == false){ init = true; }else{ if(root-\u0026gt;val \u0026lt;= cur){ res = false; } } cur = root-\u0026gt;val; dfs(root-\u0026gt;right); } bool isValidBST(TreeNode* root) { dfs(root); return res; } }; 101 对称二叉树 https://leetcode.cn/problems/symmetric-tree 递归\nclass Solution { public: bool dfs(TreeNode* left, TreeNode* right){ if(left==nullptr \u0026amp;\u0026amp; right == nullptr) return true; if(left==nullptr || right == nullptr) return false; if(left-\u0026gt;val != right-\u0026gt;val) return false; return dfs(left-\u0026gt;right, right-\u0026gt;left) \u0026amp;\u0026amp; dfs(left-\u0026gt;left, right-\u0026gt;right); } bool isSymmetric(TreeNode* root) { if(root==nullptr) return true; return dfs(root-\u0026gt;left, root-\u0026gt;right); } }; 102 二叉树的层序遍历 https://leetcode.cn/problems/binary-tree-level-order-traversal\n队列\nclass Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { queue\u0026lt;TreeNode*\u0026gt; q; q.push(root); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; if(root==nullptr) return res; while(!q.empty()) { int sz = q.size(); vector\u0026lt;int\u0026gt; cur; while(sz--){ auto top = q.front(); q.pop(); cur.push_back(top-\u0026gt;val); if(top-\u0026gt;left){ q.push(top-\u0026gt;left); } if(top-\u0026gt;right){ q.push(top-\u0026gt;right); } } res.push_back(cur); } return res; } }; 104 二叉树的最大深度 https://leetcode.cn/problems/maximum-depth-of-binary-tree/\nclass Solution { public: int maxDepth(TreeNode* root) { if(root==nullptr) return 0; int left = maxDepth(root-\u0026gt;left); int right = maxDepth(root-\u0026gt;right); return 1+max(left, right); } }; 105 前序中序构造二叉树 https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\nclass Solution { public: TreeNode* build(vector\u0026lt;int\u0026gt;\u0026amp; preorder, int p_l, int p_r, vector\u0026lt;int\u0026gt;\u0026amp; inorder, int i_l, int i_r) { if(p_l \u0026gt; p_r) return nullptr; int root_val = preorder[p_l]; int i; for(i=i_l;i\u0026lt;=i_r;i++) { if(inorder[i] == root_val){ break; } } int left_num = i-i_l; auto root = new TreeNode(root_val); root-\u0026gt;left = build(preorder, p_l+1, p_l+left_num, inorder, i_l, i-1); root-\u0026gt;right = build(preorder, p_l+left_num+1, p_r, inorder, i+1, i_r); return root; } TreeNode* buildTree(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder) { return build(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1); } }; 114 二叉树展开为链表 https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/\n递归解决\nclass Solution { public: TreeNode* dfs(TreeNode* root){ if(root == nullptr){ return root; } auto left = dfs(root-\u0026gt;left); auto right = dfs(root-\u0026gt;right); if(left == nullptr){ root-\u0026gt;right = right; root-\u0026gt;left = nullptr; return root; } auto cur = left; while(cur-\u0026gt;right){ cur = cur-\u0026gt;right; } root-\u0026gt;right = left; root-\u0026gt;left = nullptr; cur-\u0026gt;right = right; return root; } void flatten(TreeNode* root) { dfs(root); } }; 124 二叉树的最大路径和 https://leetcode.cn/problems/binary-tree-maximum-path-sum\n递归\nclass Solution { private: int ans = INT_MIN; public: int dfs(TreeNode* root){ if(!root) return 0; int left = dfs(root-\u0026gt;left); int right = dfs(root-\u0026gt;right); int val = root-\u0026gt;val + max(left, 0) + max(right, 0); ans = max(ans, val); return root-\u0026gt;val + max(0, max(left, right)); } int maxPathSum(TreeNode* root) { dfs(root); return ans; } }; 128 最长连续序列 用map或者set（有序的）， 并且用iterator\nclass Solution { private: set\u0026lt;int\u0026gt; cache; int res = 1; public: int longestConsecutive(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for(int x: nums){ cache.insert(x); } int res = 0; auto it = cache.begin(); int streak = 1; while(it!=cache.end()) { streak = 1; while(it!=cache.end() \u0026amp;\u0026amp;cache.count(*it+1)!=0){ it++; streak++; } res = max(res, streak); it++; } return res; } }; 136 只出现一次的数字 利用亦或\nclass Solution { public: int singleNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int x = 0; for(int num: nums){ x = x^num; } return x; } }; 139 单词拆分 https://leetcode.cn/problems/word-break\n动态规划\nclass Solution { private: vector\u0026lt;bool\u0026gt; dp; public: bool wordBreak(string s, vector\u0026lt;string\u0026gt;\u0026amp; wordDict) { dp = vector\u0026lt;bool\u0026gt;(s.size()+1, false); dp[0] = true; for(int i=1;i\u0026lt;=s.size();i++) { if(dp[i-1] == true){ for(string\u0026amp; word: wordDict){ bool match = true; for(int j=0;j\u0026lt;word.size();j++) { if(word[j] != s[i-1+j]){ match = false; break; } } if(match == true){ dp[i+word.size()-1] = true; } } } } return dp[s.size()]; } }; 剑指 Offer 12. 矩阵中的路径 用visit数组\nclass Solution { private: vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visit; int n; int m; bool res =false; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; directions{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; public: void dfs(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string\u0026amp; word, int i, int j, int cur){ if(i\u0026lt;0 || i\u0026gt;=n || j\u0026lt;0 || j\u0026gt;=m || visit[i][j] || res==true || word[cur]!= board[i][j]){ return; } if(cur==word.size()-1){ res = true; return; } visit[i][j] = true; for(auto\u0026amp; direction: directions){ int next_i = i + direction[0]; int next_j = j + direction[1]; dfs(board, word, next_i, next_j, cur+1); } visit[i][j] = false; } bool exist(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string word) { n = board.size(); if(n==0) return false; m = board[0].size(); visit = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(n, vector\u0026lt;bool\u0026gt;(m, false)); for(int i=0;i\u0026lt;n \u0026amp;\u0026amp; !res; i++) { for(int j=0;j\u0026lt;m \u0026amp;\u0026amp; !res ;j++){ dfs(board, word, i, j, 0); } } return res; } }; 剑指 Offer 14- I. 剪绳子 动态规划，切出来的部分分为两种情况： 一种继续切割，另一种一整块，不切割\nclass Solution { public: int cuttingRope(int n) { vector\u0026lt;int\u0026gt; f(1005); f[1] = 1; for(int i=2;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=i/2;j++){ int x1 = j; int x2 = i-j; f[i] = max(f[i], f[x1]*x2); f[i] = max(f[i], x1*x2); } } return f[n]; } }; 剑指 Offer 16. 数值的整数次方 递归的方式（其实是二分）\nclass Solution { public: double fun(double x, int n){ if(n==0){ return 1; } double half = fun(x, n/2); return n%2==0? half*half : x*half*half; } double myPow(double x, int n) { long long N = n; return n\u0026gt;0 ? fun(x, N) : 1.0/fun(x, -N); } }; 剑指 Offer 26. 树的子结构 递归\nclass Solution { public: bool dfs(TreeNode* A, TreeNode* B){ if(!B) return true; if(!A) return false; bool left = dfs(A-\u0026gt;left, B-\u0026gt;left); bool right = dfs(A-\u0026gt;right, B-\u0026gt;right); return A-\u0026gt;val == B-\u0026gt;val \u0026amp;\u0026amp; left \u0026amp;\u0026amp; right; } bool isSubStructure(TreeNode* A, TreeNode* B) { if(!A || !B) return false; return dfs(A, B) || isSubStructure(A-\u0026gt;left, B) || isSubStructure(A-\u0026gt;right, B); } }; 剑指 Offer 31. 栈的压入、弹出序列 class Solution { public: bool validateStackSequences(vector\u0026lt;int\u0026gt;\u0026amp; pushed, vector\u0026lt;int\u0026gt;\u0026amp; popped) { stack\u0026lt;int\u0026gt; st; int idx = 0; for(int i=0;i\u0026lt;pushed.size();i++){ st.push(pushed[i]); while(!st.empty() \u0026amp;\u0026amp; st.top() == popped[idx]){ idx++; st.pop(); } } return st.empty(); } }; 剑指 Offer 33. 二叉搜索树的后序遍历序列 遍历，veriy(vector\u0026lt;int\u0026gt;\u0026amp; postorder, int begin, int end)， i从begin到root是小于， begin+1，到end是小于，最后判断i是否等于end。\nclass Solution { public: bool veriy(vector\u0026lt;int\u0026gt;\u0026amp; postorder, int begin, int end){ if(begin \u0026gt;= end) return true; int root_val = postorder[end]; int i = begin; while(i\u0026lt;end \u0026amp;\u0026amp; postorder[i]\u0026lt;root_val){ i++; } int left = i-1; while(i\u0026lt;end \u0026amp;\u0026amp; postorder[i]\u0026gt;root_val){ i++; } return i==end \u0026amp;\u0026amp; veriy(postorder, begin, left) \u0026amp;\u0026amp; veriy(postorder, left+1, end-1); } bool verifyPostorder(vector\u0026lt;int\u0026gt;\u0026amp; postorder) { return veriy(postorder, 0, postorder.size()-1); } }; 剑指 Offer 34. 二叉树中和为某一值的路径 dfs\nclass Solution { private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; public: void dfs(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; tp, int target){ if(root==nullptr) return; if(target == root-\u0026gt;val \u0026amp;\u0026amp; root-\u0026gt;left==nullptr \u0026amp;\u0026amp; root-\u0026gt;right==nullptr){ tp.push_back(root-\u0026gt;val); res.push_back(tp); tp.pop_back(); return; } if(root-\u0026gt;left){ tp.push_back(root-\u0026gt;val); dfs(root-\u0026gt;left, tp, target - root-\u0026gt;val); tp.pop_back(); } if(root-\u0026gt;right){ tp.push_back(root-\u0026gt;val); dfs(root-\u0026gt;right, tp, target - root-\u0026gt;val); tp.pop_back(); } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pathSum(TreeNode* root, int target) { vector\u0026lt;int\u0026gt; tp; dfs(root, tp, target); return res; } }; 剑指 Offer 35. 复杂链表的复制 用一个unordered_map存储对应的节点，然后利用后序遍历，当遍历完成之后，map也做好了\nclass Solution { private: unordered_map\u0026lt;Node*, Node*\u0026gt; cache; public: Node* copyRandomList(Node* head) { if(head == nullptr) return nullptr; auto root = new Node(head-\u0026gt;val); cache[head] = root; root-\u0026gt;next = copyRandomList(head-\u0026gt;next); root-\u0026gt;random = cache[head-\u0026gt;random]; return root; } }; 剑指 Offer 36. 二叉搜索树与双向链表 head和prev\nclass Solution { private: Node* prev = nullptr; Node* head = nullptr; public: void inorder(Node* root){ if(!root) return; inorder(root-\u0026gt;left); if(!head){ head = root; } auto right = root-\u0026gt;right; if(prev){ prev-\u0026gt;right = root; root-\u0026gt;left = prev; } prev = root; inorder(right); } Node* treeToDoublyList(Node* root) { if(!root) return root; inorder(root); prev-\u0026gt;right = head; head-\u0026gt;left = prev; return head; } }; 剑指 Offer 38. 字符串的排列 1、对字符串进行排序 2、if(i!=0 \u0026amp;\u0026amp; s[i]==s[i-1] \u0026amp;\u0026amp; visit[i-1]==true) continue; 在dfs的时候去重\nclass Solution { private: Node* prev = nullptr; Node* head = nullptr; public: void inorder(Node* root){ if(!root) return; inorder(root-\u0026gt;left); if(!head){ head = root; } auto right = root-\u0026gt;right; if(prev){ prev-\u0026gt;right = root; root-\u0026gt;left = prev; } prev = root; inorder(right); } Node* treeToDoublyList(Node* root) { if(!root) return root; inorder(root); prev-\u0026gt;right = head; head-\u0026gt;left = prev; return head; } }; # 剑指 Offer 46. 把数字翻译成字符串 ```c++ class Solution { public: int translateNum(int num) { string str = to_string(num); vector\u0026lt;int\u0026gt; dp(str.size()+1); dp[1] = 1; dp[0] = 1; for(int i=2;i\u0026lt;=str.size();i++){ int x = (str[i-2] - \u0026#39;0\u0026#39;) * 10 + (str[i-1] - \u0026#39;0\u0026#39;); if(x\u0026gt;=10 \u0026amp;\u0026amp; x\u0026lt;=25){ dp[i] = dp[i-2]+dp[i-1]; }else{ dp[i] = dp[i-1]; } } return dp[str.size()]; } }; 剑指 Offer 46. 把数字翻译成字符串 动态规划 如果str[i-1]+str[i] 在10到25之间的数字 $$ f_{i} = f_{i-1} + f_{i-2} $$ 否则 $$ f_{i} = f_{i-1} $$\nclass Solution { public: int translateNum(int num) { string str = to_string(num); vector\u0026lt;int\u0026gt; dp(str.size()+1); dp[1] = 1; dp[0] = 1; for(int i=2;i\u0026lt;=str.size();i++){ int x = (str[i-2] - \u0026#39;0\u0026#39;) * 10 + (str[i-1] - \u0026#39;0\u0026#39;); if(x\u0026gt;=10 \u0026amp;\u0026amp; x\u0026lt;=25){ dp[i] = dp[i-2]+dp[i-1]; }else{ dp[i] = dp[i-1]; } } return dp[str.size()]; } }; 剑指 Offer 47. 礼物的最大价值 动态规划\nclass Solution { public: int maxValue(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(); int m = grid[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(m, 0)); dp[0][0] = grid[0][0]; for(int i=1;i\u0026lt;n;i++) { dp[i][0] = dp[i-1][0] + grid[i][0]; } for(int j=1;j\u0026lt;m;j++) { dp[0][j] = dp[0][j-1] + grid[0][j]; } for(int i=1;i\u0026lt;n;i++) { for(int j=1;j\u0026lt;m;j++){ dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]; } } return dp[n-1][m-1]; } }; 剑指 Offer 49. 丑数 类似于合并三个有序链表\nclass Solution { public: int nthUglyNumber(int n) { vector\u0026lt;int\u0026gt; f(n, 0); f[0] = 1; int i2 = 0; int i3 = 0; int i5 = 0; for(int i=1;i\u0026lt;n;i++){ int x2 = f[i2]*2; int x3 = f[i3]*3; int x5 = f[i5]*5; int min_val = min(min(x2, x3), x5); f[i] = min_val; if(x2 == min_val){ i2++; } if(x3 == min_val){ i3++; } if(x5 == min_val){ i5++; } } return f[n-1]; } }; 剑指 Offer 56 - I. 数组中数字出现的次数 首先将所有数字进行异或操作，得到x， x中找到那个为1的位，根据异或为1的那个位将数字分为两组\nclass Solution { public: vector\u0026lt;int\u0026gt; singleNumbers(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int x = 0; for(auto i:nums){ x = (x^i); } int d = 1; while((d\u0026amp;x) != 0){ d = d\u0026lt;\u0026lt;1; } vector\u0026lt;int\u0026gt; ans{0, 0}; for(int i=0;i\u0026lt;nums.size();i++){ if((nums[i] \u0026amp; d) == 0){ ans[0] = ans[0] ^ nums[i]; }else{ ans[1] = ans[1] ^ nums[i]; } } return ans; } }; 剑指 Offer 56 - II. 数组中数字出现的次数 II 题目大概意思是有一个数只出现过1次，其他数都出现过3次。 解法是每个位上的1进行统计，然后对三取余，如果是1的话说明只出现过一次的数这个位上有1\nclass Solution { public: int singleNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; bits(32, 0); for(int num: nums){ int x = 1; int i = 0; while(num){ bits[i] += num \u0026amp; x; num = num \u0026gt;\u0026gt; 1; i++; } } int x = 0; int ans = 0; for(int i=0;i\u0026lt;32;i++){ ans += bits[i]%3 * pow(2, x); x++; } return ans; } }; 剑指 Offer 60. n个骰子的点数 逆向推导\n剑指 Offer 64. 求1+2+…+n 后序遍历\nclass Solution { private: int x = 0; public: int sumNums(int n) { int a = n\u0026gt;=1 \u0026amp;\u0026amp; sumNums(n-1); x += n; return x; } }; 剑指 Offer 66. 构建乘积数组 构建从左边和从右边的累计数组\nclass Solution { public: vector\u0026lt;int\u0026gt; constructArr(vector\u0026lt;int\u0026gt;\u0026amp; a) { vector\u0026lt;int\u0026gt; left(a.size(), 1); for(int i=1;i\u0026lt;a.size();i++){ left[i] = a[i-1]*left[i-1]; } vector\u0026lt;int\u0026gt; right(a.size(), 1); for(int i=a.size()-2;i\u0026gt;=0;i--){ right[i] = a[i+1]*right[i+1]; } vector\u0026lt;int\u0026gt; res(a.size(), 1); for(int i=0;i\u0026lt;a.size();i++){ res[i] = left[i]*right[i]; } return res; } }; 面试题13. 机器人的运动范围 class Solution { public: vector\u0026lt;int\u0026gt; constructArr(vector\u0026lt;int\u0026gt;\u0026amp; a) { vector\u0026lt;int\u0026gt; left(a.size(), 1); for(int i=1;i\u0026lt;a.size();i++){ left[i] = a[i-1]*left[i-1]; } vector\u0026lt;int\u0026gt; right(a.size(), 1); for(int i=a.size()-2;i\u0026gt;=0;i--){ right[i] = a[i+1]*right[i+1]; } vector\u0026lt;int\u0026gt; res(a.size(), 1); for(int i=0;i\u0026lt;a.size();i++){ res[i] = left[i]*right[i]; } return res; } }; 面试题45. 把数组排成最小的数 对数字进行排序\nstring ab = a+b; string ba = b+a; return ab\u0026lt;ba; class Solution { public: static bool cmp(string a, string b){ string ab = a+b; string ba = b+a; return ab\u0026lt;ba; } string minNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;string\u0026gt; str_num; for(int i=0;i\u0026lt;nums.size();i++){ str_num.push_back(to_string(nums[i])); } sort(str_num.begin(), str_num.end(), cmp); string res = \u0026#34;\u0026#34;; for(int i=0;i\u0026lt;str_num.size();i++){ res = res + str_num[i]; } return res; } }; !面试题59 - II. 队列的最大值 一个queue还有一个deque，queue push_back的时候，将max deque中back中小于等于value的都pop走，在pop_front的时候，将max deque中front中等于pop出来的value的pop出去，总体维护的队列back到front的数据是有序增大的\nclass MaxQueue { private: queue\u0026lt;int\u0026gt; q; deque\u0026lt;int\u0026gt; max_q; public: MaxQueue() { } int max_value() { if(max_q.empty()){ return -1; } return max_q.front(); } void push_back(int value) { q.push(value); while(!max_q.empty() \u0026amp;\u0026amp; max_q.back()\u0026lt;=value){ max_q.pop_back(); } max_q.push_back(value); } int pop_front() { if(q.empty()){ return -1; } int ans = q.front(); q.pop(); while(!max_q.empty() \u0026amp;\u0026amp; ans == max_q.front()){ max_q.pop_front(); } return ans; } }; 剑指 Offer 19. 正则表达式匹配 https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof 当p[i-1] == '*'的时候，总是可以删除一个前一个字符，即 dp[i][j] |= dp[i][j-2];，同时，如果如果当s[i-1] == p[j-2] || p[j-2] == '.'时，匹配 s 末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；\nclass Solution { public: bool isMatch(string s, string p) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(s.size()+1, vector\u0026lt;int\u0026gt;(p.size()+1, false)); dp[0][0] = true; // 初始化首行 空串必须匹配 成对带* 的 for(int i = 2; i \u0026lt;=p.size(); i += 2){ dp[0][i] = (p[i-1] == \u0026#39;*\u0026#39; \u0026amp;\u0026amp; dp[0][i-2]); } if(s.empty()) return dp[0][p.size()]; for(int i=1;i\u0026lt;=s.size();i++){ for(int j=1;j\u0026lt;=p.size();j++){ if(s[i-1]==p[j-1] || p[j-1] == \u0026#39;.\u0026#39;){ dp[i][j] = dp[i-1][j-1]; }else if(p[j - 1] == \u0026#39;*\u0026#39; \u0026amp;\u0026amp; j\u0026gt;=2){ if(s[i-1] == p[j-2] || p[j-2] == \u0026#39;.\u0026#39;){ dp[i][j] = dp[i-1][j]; } dp[i][j] |= dp[i][j-2]; } } } return dp[s.size()][p.size()]; } }; 剑指 Offer 51. 数组中的逆序对 https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof 利用merge_sort\nclass Solution { private: int ans = 0; public: void merge(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int mid, int right){ vector\u0026lt;int\u0026gt; tp1(mid-left+1); vector\u0026lt;int\u0026gt; tp2(right-(mid+1)+1); for(int i=left;i\u0026lt;=mid;i++){ tp1[i-left] = nums[i]; } for(int i=mid+1;i\u0026lt;=right;i++){ tp2[i-mid-1] = nums[i]; } int i = left; int i1 = 0; int i2 = 0; while(i1\u0026lt;tp1.size() \u0026amp;\u0026amp; i2\u0026lt;tp2.size()){ if(tp1[i1] \u0026lt;= tp2[i2]){ nums[i++] = tp1[i1++]; }else{ ans += (tp1.size()-i1); nums[i++] = tp2[i2++]; } } while(i1\u0026lt;tp1.size()){ nums[i++] = tp1[i1++]; } while(i2\u0026lt;tp2.size()){ nums[i++] = tp2[i2++]; } } void merge_sort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right){ if(left\u0026gt;=right) return; int mid = left+(right-left)/2; merge_sort(nums, left, mid); merge_sort(nums, mid+1, right); merge(nums, left, mid, right); } int reversePairs(vector\u0026lt;int\u0026gt;\u0026amp; nums) { merge_sort(nums, 0, nums.size()-1); for(int i=0;i\u0026lt;nums.size();i++){ printf(\u0026#34;%d\u0026#34;, nums[i]); } return ans; } }; 剑指 Offer 41. 数据流中的中位数 https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/\nclass MedianFinder { private: priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; min_q; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, less\u0026lt;int\u0026gt;\u0026gt; max_q; public: /** initialize your data structure here. */ MedianFinder() { } void addNum(int num) { max_q.push(num); int tp = max_q.top(); max_q.pop(); min_q.push(tp); if(max_q.size() != min_q.size()){ int tp = min_q.top(); min_q.pop(); max_q.push(tp); } } double findMedian() { if(min_q.size() == max_q.size()){ return (1.0 * min_q.top() + max_q.top()) / 2; } return max_q.top(); } }; 剑指 Offer 43. 1～n 整数中 1 出现的次数 class Solution { public: int countDigitOne(int n) { int left, now, right; long long k = 1; int ans = 0; while(left){ now = (n % (k*10)) / k; right = n%k; left = n / (k*10); if(now == 0){ // 12033; left:(0-11), right:(0-99); ans += left*k; }else if(now == 1){ // 12133 left:(0-11), right(0-99), 当left=left时, right=(0, right) ans += left*k + right+ 1; }else{ // 12933 left:(left) ans += (left+1)*k; } k = k*10; } return ans; } }; ","permalink":"https://chx9.github.io/posts/cs/leetcode/","summary":"141 环形链表 class Solution { public: bool hasCycle(ListNode *head) { auto fast = head; auto slow = head; while(fast \u0026amp;\u0026amp; fast-\u0026gt;next){ slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; if(slow == fast) return true; } return false; } }; 142 环形链表 https://leetcode.cn/problems/linked-list-cycle-ii/?favorite=2cktkvj 有一个链表，如果有环，返回环的入口处，没有则返回 方法一：哈希表 哈希表第一个重复的值，就是入口处 方法二：快慢指针 如果有环，快慢指针将会再某一点相遇，此时的慢指针和head与环入口点距离相等 class","title":"Leetcode"},{"content":"三次握手过程 四次挥手过程 为什么 TCP 要三次握手？ 最主要原因就是防止「历史连接」初始化了连接。 三次握手才可以同步双方的初始序列号 为什么 TCP 要四次挥手 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。 TCP 三次握手失败会发生什么 第一次握手失败 客户端重传 SYN 包，直到连接成功或者超时（每次等待两倍时间） 如果服务器无法响应，那么会发送 RST 包，表示拒绝连接 第二次握手失败 客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是客户端就会触发超时重传机制，重传 SYN 报文。 服务端这边会触发超时重传机制，重传 SYN-ACK 报文。 第三次握手失败 因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。 注意，ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文\n列举常用的 HTTP 状态码 HTTP 状态码是指在 HTTP 协议中，服务器向客户端返回的响应状态码。HTTP 状态码由三位数字组成，第一位数字表示响应类型，后两位数字没有具体分类作用。常见的 HTTP 状态码如下：\n1xx：信息响应类，表示服务器已接收到客户端的请求，需要进一步处理。 2xx：成功响应类，表示服务器已成功地接收到客户端的请求并返回响应结果。 3xx：重定向响应类，表示客户端需要进一步操作才能完成请求，如重定向到其他 URL。 4xx：客户端错误响应类，表示客户端请求存在错误或无法被服务器处理。 5xx：服务器错误响应类，表示服务器在处理请求时出现了错误或异常。 以下是常见的 HTTP 状态码及其含义：\n200 OK：表示请求被成功处理，并返回响应结果。 301 Moved Permanently：表示请求的资源已经被永久移动到新的位置，客户端需要使用新的 URL。 302 Found：表示请求的资源已经被暂时移动到新的位置，客户端需要使用新的 URL，但是之后可能会恢复原来的位置。 304 Not Modified：表示客户端发送了一个条件请求，并且服务器认为客户端请求的资源没有被修改，因此不需要返回资源的实体内容，只需要返回响应头信息即可。 404 Not Found：表示请求的资源不存在或无法被找到。 500 Internal Server Error：表示服务器在处理请求时出现了未知的错误或异常。 除了上述常见的 HTTP 状态码，HTTP 协议中还有很多其他状态码，每个状态码都有其特定的含义和用途。在编写 Web 应用程序时，了解 HTTP 状态码的含义和使用方法，可以帮助我们更好地处理 HTTP 请求，提高程序的可靠性和稳定性。\nGET 和 POST 请求 GET 和 POST 是 HTTP 协议中最常用的两种请求方法，它们有以下区别：\n参数传递方式：GET 请求将参数以 URL 参数的形式传递，而 POST 请求将参数包含在请求体中传递。\n安全性：GET 请求的参数会被包含在 URL 中，因此可能会被浏览器缓存、历史记录、代理服务器等记录下来，并且容易被攻击者截取、篡改或者伪造。POST 请求的参数则不会被包含在 URL 中，相对来说更加安全。\n请求体大小限制：GET 请求对请求体大小没有限制，但是浏览器对 URL 长度有限制；POST 请求对请求体大小有限制，一般情况下不会超过 2MB。\n应用场景：GET 请求适合请求数据，如获取页面、搜索等操作；POST 请求适合提交数据，如提交表单、上传文件等操作。\nHTTP 和 HTTPS HTTP（Hypertext Transfer Protocol）和 HTTPS（Hypertext Transfer Protocol Secure）都是用于在 Web 上进行数据传输的协议，它们的主要区别在于安全性：\n安全性：HTTP 是明文传输协议，数据在传输过程中没有加密，容易被窃听和篡改；HTTPS 利用 SSL/TLS 协议进行数据加密和身份认证，可以保证数据传输的安全性。\n端口号：HTTP 使用的端口号为 80，而 HTTPS 使用的端口号为 443。\n证书：HTTPS 需要使用数字证书对网站进行身份验证，证书由受信任的第三方机构颁发，可以保证网站的真实性和安全性；而 HTTP 没有身份验证机制，无法保证网站的真实性和安全性。\n性能：HTTPS 比 HTTP 的性能要差一些，因为 HTTPS 需要进行加密和解密操作，会增加服务器和客户端的处理负担，导致响应速度变慢。\nhttp 加密过程 HTTPS（Hypertext Transfer Protocol Secure）是一个用于安全传输数据的协议，它使用 SSL（Secure Sockets Layer）或 TLS（Transport Layer Security）协议来加密 Web 通信。以下是 HTTPS 的加密过程：\n客户端发起 HTTPS 请求，请求连接到服务器。\n服务器向客户端发送一个证书，证书中包含了服务器的公钥、证书的有效期、证书颁发机构等信息。\n客户端收到证书后，会验证证书的有效性，包括证书是否过期、证书颁发机构是否可信等。如果证书有效，客户端会生成一个随机数，用于后续的加密通信。\n客户端使用服务器的公钥加密随机数，并将加密后的随机数发送给服务器。\n服务器使用自己的私钥解密客户端发来的随机数，并使用该随机数作为对称加密算法的密钥，用于后续的数据加密。\n服务器使用对称加密算法对数据进行加密，并将加密后的数据发送给客户端。\n客户端使用之前生成的随机数作为对称加密算法的密钥，解密服务器发来的数据，从而得到原始数据。\n以上就是 HTTPS 的加密过程，通过使用 SSL 或 TLS 协议，可以确保数据在传输过程中的机密性、完整性和真实性。\n输入网址到出现网页的全过程 输入网址到浏览器中，到收到网页的整个过程大致可以分为以下步骤：\nDNS 解析：浏览器首先会解析输入的网址中的域名，将其转换为对应的 IP 地址。浏览器会先查找本地 DNS 缓存，如果没有找到匹配的 IP 地址，则会向 DNS 服务器发送请求，获取对应域名的 IP 地址。\n建立 TCP 连接：浏览器向服务器发送 TCP 连接请求，建立 TCP 连接。在这个过程中，浏览器和服务器会通过三次握手协议建立连接。\n发送 HTTP 请求：浏览器向服务器发送 HTTP 请求，请求获取特定资源，比如 HTML、CSS、JavaScript、图片等。\n服务器响应：服务器接收到浏览器的 HTTP 请求后，会返回相应的资源内容以及 HTTP 状态码。\n浏览器渲染：当浏览器接收到服务器返回的资源内容后，会根据 HTML、CSS 和 JavaScript 等文件进行解析，生成 DOM 和 CSSOM 树，并将其合并成渲染树。然后浏览器会根据渲染树进行布局和绘制，最终将网页内容显示在用户界面上。\n在这个过程中，涉及到的协议主要有：\nDNS 协议：用于域名解析，将域名转换为对应的 IP 地址。\nTCP 协议：用于在浏览器和服务器之间建立可靠的连接，确保数据的可靠传输。\nHTTP 协议：用于在浏览器和服务器之间传输资源内容，包括 HTML、CSS、JavaScript、图片等。\nHTTPS 协议：用于在 HTTP 协议的基础上添加 SSL/TLS 协议进行加密通信，提高数据传输的安全性。\nTCP 拥塞控制 b 站视频\n小林 coding\n拥塞控制是一种网络流量控制机制，它通过限制数据流的速度来防止网络拥塞和保持网络的稳定性。拥塞控制的几个常见机制包括：\n慢启动：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。相当于 2 的指数倍增长 。\n拥塞避免：每当收到一个 ACK 时，cwnd 增加 1/cwnd，变成了线性增长。\n快速重传：当发送方发现某个数据包没有收到确认时，它会重传该数据包。然而，如果发送方连续发送了多个数据包而没有收到确认，它会认为网络出现了拥塞，并立即减慢发送速率。幸运的是，由于 TCP 采用的是累计确认机制，即当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余 ACK（duplicate ACK）。\n如图所示，报文段1成功接收并被确认ACK 2，接收端的期待序号为2，当报文段2丢失，报文段3失序到来，与接收端的期望不匹配，接收端重复发送冗余ACK 2。 这样，如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK（其实是收到4个同样的ACK，第一个是正常的，后三个才是冗余的），发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出，大大提高了效率。这便是快速重传机制。 4. 快速恢复：当发送方减慢发送速率时，接收方会通知发送方可以增加发送速率。这种机制称为快速恢复，它可以帮助发送方更快地恢复正常的发送速率，而不是像慢启动一样重新开始。\n正如前面所说，进入快速恢复之前，cwnd 和 ssthresh 已被更新了： cwnd = cwnd/2 ，也就是设置为原来的一半; ssthresh = cwnd; 然后，进入快速恢复算法如下： 拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）； 重传丢失的数据包； 如果再收到重复的 ACK，那么 cwnd 增加 1； 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态； 流量控制和拥塞控制分别解决了什么问题 流量控制是防止接收端被发送端的数据包淹没，确保接收端处理得过来。\n拥塞控制是避免网络中的数据包太多，导致网络资源如路由器、链路等过载\nhttp 长连接和短连接区别 长连接（Long Connection）\n长连接在数据的传输结束后，仍然保持连接状态，可重复使用，直到客户端或服务器主动关闭。\n场景：实时应用（如在线聊天、即时通讯）、数据库连接、HTTP/2 中的服务。 短连接（Short Connection）\n短连接发送请求后，得到服务器响应就立刻断开。\n场景：HTTP/1.0 协议、邮件发送/接收、FTP 文件传输。\n哪些用 UDP 哪些用 TCP 应用层协议可以使用 TCP 或 UDP 进行数据传输，具体使用哪种传输协议，需要根据协议的特性和应用场景进行选择。下面是一些常见的应用层协议及其使用的传输协议：\n使用 TCP 传输的应用层协议：\nHTTP 协议：用于 Web 应用程序的数据传输。\nFTP 协议：用于文件传输，支持文件上传和下载等操作。\nSMTP 协议：用于电子邮件的传输。\nSSH 协议：用于安全远程登录和文件传输。\nTelnet 协议：用于远程登录主机进行命令行操作。\n使用 UDP 传输的应用层协议：\nDNS 协议：用于域名解析，将域名转换为 IP 地址。\nDHCP 协议：用于动态 IP 地址分配，自动分配和管理 IP 地址。\nTFTP 协议：用于简单文件传输，支持无连接传输方式。\nSNMP 协议：用于网络管理和监控，实现对网络设备的远程管理。\nRTP 协议：用于音视频数据的传输，支持实时传输和流媒体播放。\n需要注意的是，有些应用层协议同时支持 TCP 和 UDP 传输，如 DNS 协议和 FTP 协议等，可以根据实际情况进行选择。\nhttps ssl 连接的过程 HTTPS 加密过程简略如下：\n客户端发送 HTTPS 请求，请求头中的https字段设置为on。\n服务器返回数字证书，包含服务器的公钥、证书颁发机构的信息、证书有效期等。\n客户端验证证书合法性，确认无误后生成随机的会话密钥，并使用服务器的公钥将其加密后发送给服务器。\n服务器使用自己的私钥解密会话密钥，得到原始的会话密钥。\n双方使用会话密钥进行对称加密，保证通信过程中的数据安全性，并进行数字签名和身份认证，确保通信的可信性和完整性。\nhttp1.0 和 http1.1 和 http2.0 的差别，分别做了哪几点优化 HTTP 是一种应用层协议，常用于 Web 应用中，目前主要有 HTTP/1.0、HTTP/1.1 和 HTTP/2.0 三个版本。它们之间的主要差别及优化如下：\nHTTP/1.0 和 HTTP/1.1 的主要差别 HTTP 1.0\n单一请求响应模型，每个请求/响应都会断开连接。 HTTP 1.1\n持久连接：默认情况下，所有的连接都被认为是持久的，除非有明确的关闭。 管道化技术：在同一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了网络延迟。 增加更多的缓存控制策略。 支持内容协商，包括语言、编码等。 提供对资源的范围请求，方便实现文件的部分下载。 HTTP 2.0\n多路复用：单一 TCP 连接中可并行交换多个 HTTP 请求/响应。 首部压缩：对头信息进行压缩，减少数据传输量。 服务器推送：允许服务器未经客户端明确请求就发送数据到客户端，提高性能。\ntcp 粘包现象 TCP 粘包是因为 TCP 基于字节流，不保证消息边界\n解决 TCP 粘包现象的方法主要有以下几种：\n增加消息边界：在消息头部添加消息长度字段，接收方根据消息长度进行数据的切割。\n使用固定长度的消息：发送方将消息按照固定长度进行分割，接收方根据固定长度进行数据的切割。\n使用特殊字符作为消息分隔符：发送方在消息尾部添加特殊字符作为消息分隔符，接收方根据特殊字符进行数据的切割。\n使用应用层协议：在应用层协议中规定消息的格式和边界，从而避免粘包现象的发生。\nPOST 和 GET 请求 GET 和 POST 是 HTTP 协议中常用的两种请求方法，它们在数据传输、安全性、请求体大小等方面有所不同。\nGET 请求方法是用于从服务器获取数据的方法，该方法将请求参数附加在 URL 的末尾，以问号(?)的形式分隔 URL 和请求参数，多个请求参数之间以\u0026amp;符号分隔。因此，GET 请求方法的请求体大小有限制，通常不超过 2KB。\nPOST 请求方法是用于向服务器提交数据的方法，该方法将请求参数放在请求体中，请求体的格式由 Content-Type 头部指定。因为 POST 请求方法将请求参数放在请求体中，所以请求体的大小没有限制，可以传输较大的数据。\nGET 和 POST 请求方法在安全性方面也有所不同。由于 GET 请求方法将请求参数附加在 URL 的末尾，所以请求参数会暴露在 URL 中，容易被中间人攻击截获和篡改。而 POST 请求方法将请求参数放在请求体中，相对安全一些。\n幂等性：GET 请求方法具有幂等性，即多次请求返回的结果相同，不会对服务器产生影响。而 POST 请求方法不具有幂等性，多次请求可能会产生不同的结果，对服务器产生影响。\n总之，GET 和 POST 请求方法在数据传输、安全性、请求体大小等方面有所不同。一般来说，GET 请求方法用于从服务器获取数据，POST 请求方法用于向服务器提交数据。当需要传输大量数据或者涉及到敏感数据时，建议使用 POST 请求方法。\ntcp 如何保证可靠 TCP（Transmission Control Protocol）是一种面向连接的、可靠的传输协议，它通过以下机制来保证数据传输的可靠性：\n序列号与确认应答机制：每个 TCP 报文段都有一个唯一的序列号和确认应答号，用于保证数据的顺序性和完整性。发送端将数据分成若干个报文段发送，每个报文段都有一个序列号，接收端收到报文段后需向发送端发送确认应答，确认应答号为接收到的数据的下一个期望的序列号。如果发送端接收到确认应答，就认为该报文段已经成功传输，可以将该报文段从发送缓冲区中删除。\n超时重传机制：发送端在发送数据时会启动一个定时器，如果在指定时间内没有收到接收端的确认应答，发送端会判断该报文段丢失了，需要重新发送。接收端收到重复的报文段时，会丢弃该报文段，同时向发送端发送确认应答。\n滑动窗口机制：TCP 使用滑动窗口机制来实现流量控制和拥塞控制。发送端和接收端都有一个窗口大小，用于限制发送和接收数据的速率。发送端发送数据时，需要等待接收端发送的确认应答，确认应答中包含接收端当前窗口的大小，发送端根据窗口大小来调整发送数据的速率。\n拥塞控制\n校验和：校验和（checksum）是一种用于检测数据传输过程中是否发生错误的技术。在数据传输过程中，可能会出现各种各样的错误，比如说数据损坏、数据重复、数据丢失等，这些错误都可能导致数据传输失败或者数据被篡改。校验和技术可以通过计算数据的校验和值来检测这些错误，从而保证数据传输的可靠性。\n通过以上机制，TCP 可以保证数据传输的可靠性，并且在网络出现拥塞时可以进行拥塞控制，避免网络拥塞导致数据丢失或传输延迟增加。\n滑动窗口 小林 coding\nping 的过程 主要是 icmp Ping 是一种常用的网络诊断工具，用于测试主机之间的连通性。当我们使用 Ping 命令时，Ping 程序会执行以下步骤：\n发送 ICMP Echo Request 消息：Ping 程序向目标主机发送一个 ICMP Echo Request 消息，该消息包含一个随机的标识符和序列号。\n接收 ICMP Echo Reply 消息：目标主机收到 ICMP Echo Request 消息后，会向发送方返回一个 ICMP Echo Reply 消息，该消息包含与 Echo Request 消息相同的标识符和序列号。\n计算往返时间（RTT）：Ping 程序在接收到 Echo Reply 消息后，会计算从发送 Echo Request 消息到接收 Echo Reply 消息所需的时间，即往返时间（RTT）。\n显示结果：Ping 程序将计算得到的 RTT 值和其他一些统计信息显示在屏幕上。如果目标主机无法到达，Ping 程序会返回一个错误消息。\n需要注意的是，Ping 命令使用的是 ICMP 协议，而不是 TCP 或 UDP 协议。因此，Ping 命令可以用于测试主机之间的连通性，但不能用于测试 TCP 或 UDP 服务的可用性。此外，由于 ICMP 消息可以被防火墙和路由器过滤，因此在某些情况下，Ping 命令可能无法正常工作。\nmac 寻址和 ip 寻址的差异 mac 寻址在数据链路层，ip 寻址在网络层\n数据链路层的作用 1、封装成帧 2、流量控制 3、差错控制 4、mac 寻址 5、透明传输\n网络层的作用 管理数据包的传输和路由选择，将数据包从源节点传输到目的节点。 实现IP（Internet Protocol）协议，负责数据包的分组、传输和路由选择。\n提供差错控制和流量控制功能，确保数据包传输的可靠性和效率。\n实现路由选择算法，根据网络拓扑结构和路由策略选择最佳的路径将数据包传输到目的节点。\n实现地址转换（NAT，Network Address Translation）等功能，将内部私有地址转换为公网可用的地址，以实现网络连接与安全性的需求。\n子网掩码 子网掩码（subnet mask）是用于划分网络地址和主机地址的一个 32 位数值，用于告诉网络设备哪些位是网络地址，哪些位是主机地址。子网掩码通常与 IP 地址配合使用，用于指示网络中哪些位是网络地址，哪些位是主机地址。\n子网掩码的作用是将一个 IP 地址分成两部分：网络地址和主机地址。网络地址用于标识网络，而主机地址用于标识特定的主机。\n子网掩码的格式通常是四个 8 位二进制数，例如 255.255.255.0。这个子网掩码表示前 24 位是网络地址，后 8 位是主机地址。这意味着，对于该子网掩码的网络，可以有 256 个主机地址（2 的 8 次方），因为最后 8 位可以有 256 种不同的组合。\n在计算机网络中，子网掩码有助于划分网络和管理 IP 地址。通过使用子网掩码，网络管理员可以将一个大的 IP 地址空间分成多个子网，以便更有效地管理网络。例如，一个大的 IP 地址空间可以划分为多个小的子网，每个子网可以被分配给不同的部门或办公室，以便更好地管理网络流量和安全。\nUDP 和 TCP 的区别，适用场景 TCP 适用于对数据传输的可靠性要求较高的场景，如文件传输（ftp）、电子邮件（stmp）、网页浏览（http）等；UDP 适用于对数据传输的可靠性要求较低、数据传输速度要求较高的场景，如在线游戏、实时音视频、DNS 等。\n为什么会出现大量的 close_wait 状态，如何解决 TIME_WAIT 状态是因为频繁地建立和关闭连接，或者连接关闭不规范等。\n解决办法：\n调整 TCP 参数如 TIME_WAIT 时间。 优化程序设计，比如使用连接池。 使用 SO_REUSEADDR 共用端口。 使用负载均衡器分摊连接负载。少 time_wait 状态的出现。 交换机位于哪一层 交换机位于数据链层，负责在同一网络下中转发数据帧。它能够根据目标 MAC 地址来决定数据帧的转发路径，以实现同一网络内的通信。 路由器是一种网络设备，主要用于在不同的网络之间转发数据包。\n五层网络中的各层协议有啥 DNS 过程 以下是 DNS 解析 www.example 的过程：\n当用户在浏览器中输入 www.example 时，浏览器会向本地 DNS 服务器发送 DNS 解析请求。\n如果本地 DNS 服务器缓存了该域名的解析信息，它将直接返回该域名的 IP 地址。否则，它将向根域名服务器发送请求。\n根域名服务器将返回.com 顶级域名服务器的地址。\n本地 DNS 服务器随后向.com 顶级域名服务器发送请求，并返回该域名的权威域名服务器地址。\n本地 DNS 服务器向该权威域名服务器发送请求，并返回该域名的 IP 地址。\n本地 DNS 服务器将该 IP 地址缓存起来，并将其返回给用户的计算机或设备。\n用户的计算机或设备使用该 IP 地址与该域名的服务器进行通信，以获取网站的内容。\n","permalink":"https://chx9.github.io/posts/cs/network/","summary":"三次握手过程 四次挥手过程 为什么 TCP 要三次握手？ 最主要原因就是防止「历史连接」初始化了连接。 三次握手才可以同步双方的初始序列号 为什么 TCP 要四次挥手 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可","title":"Network"},{"content":"","permalink":"https://chx9.github.io/posts/read/read/","summary":"","title":"My Reading List"},{"content":" 👉友链格式 ","permalink":"https://chx9.github.io/links/","summary":"👉友链格式","title":"🤝友链"},{"content":"chx9\n","permalink":"https://chx9.github.io/about/","summary":"chx9","title":"🙋🏻‍♂️关于"}]