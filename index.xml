<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>chx9</title>
    <link>www.junshou.top/</link>
    <description>Recent content on chx9</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 11 Aug 2023 21:48:16 +0800</lastBuildDate><atom:link href="www.junshou.top/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>gdb</title>
      <link>www.junshou.top/posts/toolchain/gdb/</link>
      <pubDate>Fri, 11 Aug 2023 21:48:16 +0800</pubDate>
      
      <guid>www.junshou.top/posts/toolchain/gdb/</guid>
      <description>start命令 在GDB中，start 命令用于启动程序并停在程序的入口点处，等待你进行调试。它相当于设置一个断点在程序的 main 函数上并运行程序。这使你可以在程序开始执行之前检查变量、设置断点以及做其他调试操作。 以下是 start 命令的用法，其中 [args] 是传递给程序的命令行参数（ start [args] gdb启动的时候指定</description>
    </item>
    
    <item>
      <title>CMake</title>
      <link>www.junshou.top/posts/toolchain/cmake/</link>
      <pubDate>Fri, 11 Aug 2023 21:43:12 +0800</pubDate>
      
      <guid>www.junshou.top/posts/toolchain/cmake/</guid>
      <description>CMake介绍 CMake是一个跨平台的构建工具，它能够帮助开发者管理大型项目，处理各种依赖关系，实现多平台、多编译器下的统一构建。使用CMake，开发者可以摆脱繁琐的手动配置环境，专注于核心的代码实现，从而大大提高开发效率。 第一个CMake文件 在一个C++项目中，我们通常需要编写</description>
    </item>
    
    <item>
      <title>Docker</title>
      <link>www.junshou.top/posts/cs/docker/</link>
      <pubDate>Mon, 31 Jul 2023 11:43:25 +0800</pubDate>
      
      <guid>www.junshou.top/posts/cs/docker/</guid>
      <description>docker 面对对象 容器 :对象 镜像 :类 常用命令 docker run 每次都会新建一个 docker container，可以添加-it命令 docker run -d image: 在后台运行容器。 docker run -it image sh: 交互式地在前台运行容器（常用于调试）。 t: 在新容器内指定一个伪终端或终端。 i: 允许你对容器内的标准输入 (STDIN) 进行交互。 image后面的sh选项可以不填，默认会</description>
    </item>
    
    <item>
      <title>C&#43;&#43;</title>
      <link>www.junshou.top/posts/cs/cpp/</link>
      <pubDate>Sat, 29 Jul 2023 12:17:47 +0800</pubDate>
      
      <guid>www.junshou.top/posts/cs/cpp/</guid>
      <description>apple 多态介绍 定义：首先，可以解释一下什么是多态。多态（Polymorphism）是面向对象编程的一个重要特性，它允许我们使用父类的指针或引用来操作子类对象。这样，同一个函数或者操作符可以对不同类型的对象产生不同的行为。 两种形式：C++中的多态主要有两种形式：静态多态（或编译时多态）</description>
    </item>
    
    <item>
      <title>Webserver</title>
      <link>www.junshou.top/posts/cs/webserver/</link>
      <pubDate>Sat, 29 Jul 2023 11:06:43 +0800</pubDate>
      
      <guid>www.junshou.top/posts/cs/webserver/</guid>
      <description>1、采用 IO 复用技术 Epoll 和线程池实现多线程的 Reactor 高并发模型 IO 复用 IO 多路复用是现代操作系统中常用的一种网络编程技术。它允许一个进程同时监听多个文件描述符，从而可以同时处理多个网络连接，而无需为每个连接使用一个单独的线程。 常用的 IO 多路复用的三种方式是 select、poll 和 epoll。它们</description>
    </item>
    
    <item>
      <title>Mysql</title>
      <link>www.junshou.top/posts/cs/mysql/</link>
      <pubDate>Sat, 29 Jul 2023 11:06:20 +0800</pubDate>
      
      <guid>www.junshou.top/posts/cs/mysql/</guid>
      <description>脏读，幻读，不可重复读解决了什么问题 脏读、幻读、可重复读是数据库中常见的隔离级别问题，它们分别解决了以下问题： 脏读（Dirty Read）：当一个事务读取到另一个事务未提交的数据时，就产生了脏读。脏读可能导致数据的不一致性，因为读取到的数据可能会随时被其他事务修改或回滚。解决脏读的</description>
    </item>
    
    <item>
      <title>Operating System</title>
      <link>www.junshou.top/posts/cs/os/</link>
      <pubDate>Sat, 29 Jul 2023 11:05:53 +0800</pubDate>
      
      <guid>www.junshou.top/posts/cs/os/</guid>
      <description>进程和线程区别 1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序 2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。线程启动速度快，轻量级 进程</description>
    </item>
    
    <item>
      <title>Leetcode</title>
      <link>www.junshou.top/posts/cs/leetcode/</link>
      <pubDate>Sat, 29 Jul 2023 11:05:24 +0800</pubDate>
      
      <guid>www.junshou.top/posts/cs/leetcode/</guid>
      <description>141 环形链表 class Solution { public: bool hasCycle(ListNode *head) { auto fast = head; auto slow = head; while(fast &amp;amp;&amp;amp; fast-&amp;gt;next){ slow = slow-&amp;gt;next; fast = fast-&amp;gt;next-&amp;gt;next; if(slow == fast) return true; } return false; } }; 142 环形链表 https://leetcode.cn/problems/linked-list-cycle-ii/?favorite=2cktkvj 有一个链表，如果有环，返回环的入口处，没有则返回 方法一：哈希表 哈希表第一个重复的值，就是入口处 方法二：快慢指针 如果有环，快慢指针将会再某一点相遇，此时的慢指针和 head 与环入口点距离相等 class Solution { public:</description>
    </item>
    
    <item>
      <title>Network</title>
      <link>www.junshou.top/posts/cs/network/</link>
      <pubDate>Sat, 29 Jul 2023 11:04:35 +0800</pubDate>
      
      <guid>www.junshou.top/posts/cs/network/</guid>
      <description>三次握手过程 四次挥手过程 为什么 TCP 要三次握手？ 最主要原因就是防止「历史连接」初始化了连接。 三次握手才可以同步双方的初始序列号 为什么 TCP 要四次挥手 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可</description>
    </item>
    
    <item>
      <title>My Reading List</title>
      <link>www.junshou.top/posts/read/read/</link>
      <pubDate>Thu, 05 May 2022 00:18:06 +0800</pubDate>
      
      <guid>www.junshou.top/posts/read/read/</guid>
      <description></description>
    </item>
    
    <item>
      <title>🤝友链</title>
      <link>www.junshou.top/links/</link>
      <pubDate>Sat, 06 Nov 2021 15:15:53 +0800</pubDate>
      
      <guid>www.junshou.top/links/</guid>
      <description>👉友链格式</description>
    </item>
    
    <item>
      <title>🙋🏻‍♂️关于</title>
      <link>www.junshou.top/about/</link>
      <pubDate>Sat, 06 Nov 2021 14:57:28 +0800</pubDate>
      
      <guid>www.junshou.top/about/</guid>
      <description>chx9</description>
    </item>
    
    
    
  </channel>
</rss>
