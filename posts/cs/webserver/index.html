<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>webserver | chx9</title>
<meta name="keywords" content="">
<meta name="description" content="1、采用 IO 复用技术 Epoll 和线程池实现多线程的 Reactor 高并发模型 IO 复用 IO 多路复用是现代操作系统中常用的一种网络编程技术。它允许一个进程同时监听多个文件描述符，从而可以同时处理多个网络连接，而无需为每个连接使用一个单独的线程。 常用的 IO 多路复用的三种方式是 select、poll 和 epoll。它们">
<meta name="author" content="chx9">
<link rel="canonical" href="https://chx9.github.io/posts/cs/webserver/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://chx9.github.io/img/svin.webp">
<link rel="icon" type="image/png" sizes="16x16" href="https://chx9.github.io/img/svin.webp">
<link rel="icon" type="image/png" sizes="32x32" href="https://chx9.github.io/img/svin.webp">
<link rel="apple-touch-icon" href="https://chx9.github.io/img/svin.webp">
<link rel="mask-icon" href="https://chx9.github.io/img/svin.webp">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script defer src="https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="webserver" />
<meta property="og:description" content="1、采用 IO 复用技术 Epoll 和线程池实现多线程的 Reactor 高并发模型 IO 复用 IO 多路复用是现代操作系统中常用的一种网络编程技术。它允许一个进程同时监听多个文件描述符，从而可以同时处理多个网络连接，而无需为每个连接使用一个单独的线程。 常用的 IO 多路复用的三种方式是 select、poll 和 epoll。它们" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chx9.github.io/posts/cs/webserver/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-29T11:06:43+08:00" />
<meta property="article:modified_time" content="2023-07-29T11:06:43+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="webserver"/>
<meta name="twitter:description" content="1、采用 IO 复用技术 Epoll 和线程池实现多线程的 Reactor 高并发模型 IO 复用 IO 多路复用是现代操作系统中常用的一种网络编程技术。它允许一个进程同时监听多个文件描述符，从而可以同时处理多个网络连接，而无需为每个连接使用一个单独的线程。 常用的 IO 多路复用的三种方式是 select、poll 和 epoll。它们"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [

        {
          "@type": "ListItem",
          "position":  1 ,
          "name": "📚Articles",
          "item": "https://chx9.github.io/posts/"
        },

        {
          "@type": "ListItem",
          "position":  2 ,
          "name": "💻 Programming",
          "item": "https://chx9.github.io/posts/cs/"
        }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "webserver",
      "item": "https://chx9.github.io/posts/cs/webserver/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "webserver",
  "name": "webserver",
  "description": "1、采用 IO 复用技术 Epoll 和线程池实现多线程的 Reactor 高并发模型 IO 复用 IO 多路复用是现代操作系统中常用的一种网络编程技术。它允许一个进程同时监听多个文件描述符，从而可以同时处理多个网络连接，而无需为每个连接使用一个单独的线程。 常用的 IO 多路复用的三种方式是 select、poll 和 epoll。它们",
  "keywords": [
    ""
  ],
  "articleBody": "1、采用 IO 复用技术 Epoll 和线程池实现多线程的 Reactor 高并发模型 IO 复用 IO 多路复用是现代操作系统中常用的一种网络编程技术。它允许一个进程同时监听多个文件描述符，从而可以同时处理多个网络连接，而无需为每个连接使用一个单独的线程。\n常用的 IO 多路复用的三种方式是 select、poll 和 epoll。它们的实现方式不同，但都可以实现 IO 多路复用的功能。它们的区别如下：\nselect select 是最古老、最常见的 IO 多路复用方式之一。它使用一个文件描述符集合来监听多个文件描述符，当其中任何一个文件描述符变为可读或可写时，select 函数就会返回。\nselect 的一个缺点是它使用的是线性扫描算法，因此它的性能随着文件描述符数量的增加而逐渐降低。\npoll poll 是 select 的一种改进，它使用一个 pollfd 结构体数组来监听多个文件描述符。与 select 不同的是，pollfd 结构体数组是动态的，因此它可以监听更多的文件描述符。\npoll 的一个缺点是它仍然使用线性扫描算法，因此它的性能也会受到文件描述符数量的限制。\nepoll epoll 是 Linux 特有的一种 IO 多路复用方式。它使用一个 epollfd 结构体来管理多个文件描述符，并使用事件通知机制来通知应用程序哪些文件描述符已准备好进行读写操作。\nepoll 的优点是它使用了基于事件驱动的方式来通知应用程序，因此它的性能不会随着文件描述符数量的增加而下降。\nPoll 机制相较于 Select 机制中，解决了文件描述符数量上限为 1024 的缺陷。但另外两点缺陷依然存在：\n每次调用 poll，都需要把 fd 集合从用户态拷贝到内核态，fd 越多开销则越大； 每次调用 poll，都需要在内核遍历传递进来的所有 fd，这个开销在 fd 很多时也很大\nepoll 是 Linux 下的一种 I/O 事件通知机制，可以用于高效地处理大量的 socket 连接。它提供了三个主要的函数：\nepoll_create()：创建一个 epoll 实例，返回一个文件描述符。该函数的参数 size 指定 epoll 实例中最大的文件描述符数目，一般设置为需要监听的 socket 数。 epoll_ctl()：向 epoll 实例中添加或删除一个文件描述符，或者修改一个文件描述符的监听事件。该函数的参数 epfd 是 epoll 实例的文件描述符，op 指定操作类型，fd 是需要添加/删除/修改的文件描述符，event 指定要监听的事件类型。 epoll_wait()：等待文件描述符上的事件发生，当有事件发生时，该函数将返回一个结构体数组，每个结构体描述一个事件。该函数的参数 epfd 是 epoll 实例的文件描述符，events 是一个存放事件的数组，maxevents 指定最多返回的事件数目，timeout 指定等待的超时时间。如果 timeout 为-1，表示一直等待，直到有事件发生；如果 timeout 为 0，表示立即返回，不等待。 单 reactor 多线程高并发模型有什么缺陷，在什么场景下会触发，解决办法是什么？\n单 reactor 多线程高并发模型的缺陷在于：\n竞争条件：多个线程同时访问共享资源，容易出现竞争条件，导致数据不一致或者程序崩溃。 上下文切换：线程切换需要消耗时间，当线程数过多时，会导致过多的上下文切换，降低程序的性能。 瓶颈：单 reactor 模型只有一个事件循环，无法充分利用多核 CPU 的优势，无法处理更多的并发连接。 当并发连接数量增加时，单 reactor 多线程模型容易出现线程切换开销大、竞争条件等问题，导致性能下降，甚至出现程序崩溃等情况。\nRactor 模型和 Proactor 模型 Reactor 模型：\n在 Reactor 模型中，应用程序将某个对象（通常是一个 socket）和其对应的事件处理函数注册到事件多路分发器上。然后，事件多路分发器会阻塞等待操作系统的事件通知。当某个对象上发生了注册的事件（例如，数据已经准备好可以读取），事件多路分发器就会调用相应的处理函数进行处理。 因此，在 Reactor 模型中，所有 I/O 操作都由应用程序显示地触发。实际的 I/O 操作（例如读和写）是同步的，尽管事件分发是异步的。\nProactor 模型：\nProactor 模型与 Reactor 模型的主要区别在于，I/O 操作的启动和完成都是异步的。当应用程序想要执行一个 I/O 操作时，它只需要发起该操作即可，然后就可以立即返回继续执行其他任务。当操作系统完成该操作时，它会自动调用预先注册的回调函数。 因此，在 Proactor 模型中，应用程序无需关心具体的 I/O 操作，而只需要发起这些操作并处理它们的结果。\n对比：\n操作复杂性：Reactor 模型中，应用程序需要负责管理 I/O 操作的具体过程，这使得编程较为复杂。相反，在 Proactor 模型中，操作系统会自动完成 I/O 操作，并在操作结束时通知应用程序，这使得编程更为简单。\nI/O 操作的阻塞性：在 Reactor 模型中，I/O 操作本身是阻塞的，只有事件分发是异步的。这可能导致一些性能问题，特别是在处理大量并发请求时。相反，在 Proactor 模型中，所有的 I/O 操作都是非阻塞的，这使得它能够更好地支持大规模并发。\n应用场景：Reactor 模型更适合于需要立即响应事件但不需要执行大量 I/O 操作的情况，如 GUI 程序。而 Proactor 模型则更适合于需要处理大量并发 I/O 操作的情况，如网络服务器。\n总的来说，Proactor 模型解决了 Reactor 模型中的一些问题，提供了一种更简洁、更高效的异步 I/O 实现方式。然而，选择哪种模型取决于具体的应用场景和需求。\nepoll 触发模式 边缘触发 (Edge-triggered, ET) 与水平触发 (Level-triggered, LT) 的区别\n在 epoll 中，有两种事件触发模式：边缘触发和水平触发。\n边缘触发（ET）: 当被监控的 Socket 描述符上有可读事件发生时，服务器端只会从 epoll_wait 中苏醒一次。即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次。因此，我们的程序必须保证一次性读取完内核缓冲区的所有数据。 水平触发（LT）: 当被监控的 Socket 上有可读事件发生时，服务器端会不断地从 epoll_wait 中苏醒，直到内核缓冲区的数据被 read 函数完全读取。目的是告知我们有数据需要读取。 举例来说：\n边缘触发类似于你的快递到达一个快递箱，这个快递箱只会通过短信通知你一次。即使你没有取走快递，它也不会再发送第二条短信提醒你。 水平触发就像快递箱发现你的快递还未取走，于是会不停地发短信提醒你，直到你取走了快递。 总结下来：\n水平触发是只要满足事件条件（例如内核中有数据需要读），就一直反复通知用户。而边缘触发则是当第一次满足条件的时候才触发，之后不会再传递同样的事件。\n这种差异影响到两种模式的使用方式：\n在水平触发模式下，内核通知文件描述符可读写后，我们可以继续检查其状态，看它是否仍可读或可写。所以接到通知后，没有必要一次尽可能多地进行读写操作。 在边缘触发模式下，I/O 事件只会通知一次，而且我们无法知道能读写多少数据。所以收到通知后，应尽可能多地进行读写操作，避免错过读写机会。由于我们会循环读写文件描述符，如果文件描述符是阻塞的且没有数据可读写，进程会阻塞在那里，无法继续执行。因此，边缘触发模式常与非阻塞 I/O 配合使用，程序会持续执行 I/O 操作，直到系统调用（如 read 和 write）返回错误，错误类型为 EAGAIN 或 EWOULDBLOCK。 通常，边缘触发模式的效率高于水平触发模式，因为边缘触发模式可以减少 epoll_wait 的系统调用次数，降低系统调用的开销（涉及上下文切换）。\nepoll 底层是如何实现的 一颗红黑树，一张准备就绪句柄链表，少量的内核 cache，就帮我们解决了大并发下的 socket 处理问题。\n执行 epoll_create()时，创建了红黑树和就绪链表；\n执行 epoll_ctl()时，如果增加 socket 句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据；\n执行 epoll_wait()时立刻返回准备就绪链表里的数据即可。 红黑树维护事件表，事件驱动机制下的回调函数加入就绪链表，拷贝只拷贝就绪链表\n当某一进程调用 epoll_create 方法时，Linux 内核会创建一个 eventpoll 结构体，这个结构体中有两个成员与 epoll 的使用方式密切相关，如下所示：\ntruct eventpoll { ... /*红黑树的根节点，这棵树中存储着所有添加到epoll中的事件， 也就是这个epoll监控的事件*/ struct rb_root rbr; /*双向链表rdllist保存着将要通过epoll_wait返回给用户的、满足条件的事件*/ struct list_head rdllist; ... }; 我们在调用 epoll_create 时，内核除了帮我们在 epoll 文件系统里建了个 file 结点，在内核 cache 里建了个红黑树用于存储以后 epoll_ctl 传来的 socket 外，还会再建立一个 rdllist 双向链表，用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个 rdllist 双向链表里有没有数据即可。有数据就返回，没有数据就 sleep，等到 timeout 时间到后即使链表没数据也返回。所以，epoll_wait 非常高效。\n所有添加到 epoll 中的事件都会与设备(如网卡)驱动程序建立回调关系，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做 ep_poll_callback，它会把这样的事件放到上面的 rdllist 双向链表中。\n在 epoll 中对于每一个事件都会建立一个 epitem 结构体，如下所示：\nstruct epitem { ... //红黑树节点 struct rb_node rbn; //双向链表节点 struct list_head rdllink; //事件句柄等信息 struct epoll_filefd ffd; //指向其所属的eventepoll对象 struct eventpoll *ep; //期待的事件类型 struct epoll_event event; ... }; // 这里包含每一个事件对应着的信息。 2、利用状态机和正则解析 HTTP 报文请求，实现静态资源的处理 状态机一共有四个状态：REQUEST_LINE， HEADERS， BODY， FINISH，分别对应了 http 请求的三个内容，FINISH 是结束，程序通过 while 循环，将状态从 REQUEST_LINE→Headers→Body→Finish 转换。\nhttp 请求和响应的格式 请求格式：\n\u003cMethod\u003e \u003cRequest-URI\u003e \u003cHTTP-Version\u003e \u003cHeaders\u003e \u003cBody\u003e 响应格式\n\u003cHTTP-Version\u003e \u003cStatus-Code\u003e \u003cReason-Phrase\u003e \u003cHeaders\u003e \u003cBody\u003e 3、利用标准库容器封装 char，实现自动增长的缓冲区 缓冲区功能如果是固定的缓冲区，在存储小数据时会照成极大资源的浪费。自动增长的缓存区会根据每个客户端的请求响应数据大小，自适应的调整缓冲区大小。\n缓冲区场景\n从内核缓冲区中分散读取数据至缓冲区（in） HTTP 数据解析的时候，将缓冲区的数据读出（out） HTTP 生成响应数据的时候，会写入缓冲区（in） 将缓冲区中的数据写入内核缓冲区（out） 如何扩容：\n从内核缓冲区读数据采用的是分散读（readv），会定义一个长度为 2 的结构体 iovec 数组（0 存放缓冲区可写部分，1 存放一个临时 char 数组）。在读的时候会首先将 WritableBytes 空间占满，当还有数据需要写入的时候就需要扩容。扩容分为两种情况，因为在 HTTP 类解析缓冲区数据的时候，readPos_会不断增加，那么 PrependableBytes 就会不断增加，这块区域是空闲的，如果说 WritableBytes 和 PrependableBytes 的空间大小满组的话，那就只需要移动数据。那如果不满足的话，就要 resize 缓冲区的大小。\n分散写：\n写的内容也是被放在一个 2 个大小 iovec 数组（0 存放响应头，1 存放 html 文件）\n代码详解\nclass Buffer { public: Buffer(int initBuffSize = 1024); ~Buffer() = default; // 有多少字节的数据可以写 size_t WritableBytes() const; // 有多少字节的数据可以读 size_t ReadableBytes() const; // buffer头部有多少字节的数据空出来 size_t PrependableBytes() const; // 返回第一个可读字节的char地址 const char *Peek() const; // 确保WritableBytes小于len，如果不是，就调用MakeSpace_动态扩容 void EnsureWriteable(size_t len); // 写入结束，更新writePos_ void HasWritten(size_t len); // 写出，根据长度调整readPos_ void Retrieve(size_t len); // 写出，根据指针计算写出的长度，并调用Retrieve void RetrieveUntil(const char *end); // 重置缓冲区，在写入内核区缓存后来调用 void RetrieveAll(); std::string RetrieveAllToStr(); // 定位buffer内数据段末尾，在了http解析函数中使用 const char *BeginWriteConst() const; // 定位buffer内数据段首部 char *BeginWrite(); // 动态扩容 void Append(const std::string \u0026str); // 核心是这个，其他重载函数内部调用了这个 void Append(const char *str, size_t len); void Append(const void *data, size_t len); void Append(const Buffer \u0026buff); // 采用分散读，分散读的好处是减少系统调用次数，提高IO效率 ssize_t ReadFd(int fd, int *Errno); // 这个函数没有用，WriteFd写在了HttpConn::write中 ssize_t WriteFd(int fd, int *Errno); private: // 返回buffer头部指针 char *BeginPtr_(); const char *BeginPtr_() const; // 若PrependableBytes和WritableBytes大于len，整体数据往前移，若小于，那就要resize void MakeSpace_(size_t len); // 用动态数组封装的char缓冲区 std::vector\u003cchar\u003e buffer_; // 如果没有实现log的话，就不需要原子，因为每个线程独自占有各自的buffer std::atomic\u003cstd::size_t\u003e readPos_; std::atomic\u003cstd::size_t\u003e writePos_; }; Buffer 类中的成员变量包括一个动态数组封装的 char 缓冲区 buffer*，以及两个 std::atomicstd::size_t类型的变量 readPos*和 writePos_，分别表示当前缓冲区的读取位置和写入位置。 类中提供的主要接口包括：\nWritableBytes()、ReadableBytes()、PrependableBytes()：分别用于获取缓冲区中可以写入的字节数、可以读取的字节数和缓冲区头部留出来的字节数。 Peek()：返回缓冲区中第一个可读字节的 char 地址。 EnsureWriteable()：确保缓冲区中可以写入的字节数大于等于 len，如果不够则进行动态扩容。 HasWritten()：写入结束后更新 writePos_。 Retrieve()、RetrieveUntil()：用于将已读取的数据从缓冲区中移除。 RetrieveAll()、RetrieveAllToStr()：用于将缓冲区中所有数据移除并返回。 BeginWriteConst()、BeginWrite()：返回缓冲区中可写数据的起始地址。 Append()：用于向缓冲区中增加额外的数据。 ReadFd()：用于采用分散读方式从文件描述符 fd 中读取数据并写入缓冲区。 除此之外，类中还有一些私有函数，用于实现动态扩容、返回 buffer 头部指针等功能。 非阻塞模式下 read 返回值 \u003c 0 表示没有数据，= 0 表示连接断开，\u003e 0 表示接收到数据。\n4、基于小根堆实现定时器，关闭超时的非活动链接 功能:为每一个客户端设置一个定时器，用户关闭超时的非活动链接。\n实现:定义了一个定时器结构体，包括 id（服务端为每个客户端分配的文件描述符），过期时间，回调函数以及重载了一个比较操作符。实现了一个 HeapTimer 类，用于存储管理定时器。此外还设计了 Tick 和 GetNextTick 函数。\nTrik 函数用于更新计时器堆的状态，通过 while 循环来不断 pop 出超时的定时器节点。\nGetNextTrick 用于返回堆顶元素的到期时间戳与当前时间戳的差，如果堆为空，则返回-1。同时，结合这个返回到期时间戳的函数，可以减少epoll_wait系统调用次数，来提高效率。epoll_wait 有一个参数叫 timeout，设置为 0，会直接返回，如果是-1 就一直阻塞，如果大于 0，表示要最多等到 timeout 时间才返回。那么我们假设 timeout 这段时间内没有新的事件发生，就没有必要一直轮询。\n5、利用 RAII 机制实现数据库连接池，减少数据库建立和关闭的消耗 epoll 的零拷贝技术 在使用 epoll 进行网络编程时，零拷贝技术可以提高数据传输的效率，减少 CPU 的使用率和数据复制的开销。\n具体来说，epoll 的零拷贝技术可以通过以下两种方式实现：\nsendfile 系统调用 sendfile 系统调用可以将文件数据直接从内核缓冲区发送到网络中，而无需将数据从内核缓冲区复制到用户空间缓冲区。在使用 epoll 进行网络编程时，可以通过 sendfile 系统调用将文件数据直接发送到网络中，从而避免了数据复制的开销。这种方式称为 epoll 的“零拷贝”技术。\nmmap 系统调用 mmap 系统调用可以将文件映射到进程的地址空间中，从而使得应用程序可以直接访问文件数据，而无需进行读写操作。在使用 epoll 进行网络编程时，可以通过 mmap 系统调用将文件映射到进程的地址空间中，然后使用 send 系统调用将数据直接从内核缓冲区发送到网络中，从而避免了数据复制的开销。\n总的来说，epoll 的零拷贝技术可以将数据传输的效率提高到极致，减少 CPU 的使用率和数据复制的开销。这在高并发的网络编程中非常有用，可以显著提高系统的性能和稳定性。\n为什么要用线程池 使用线程池的主要原因有:\n避免频繁创建和销毁线程。在使用超时或存在较长的 Waiting 时间的应用中,如果每次都需要创建一个新的线程将造成较大的开销。线程池可以重用过期的空闲线程,从而避免线程创建的开销。\n提高线程的可用性。在线程池中,可以有效地管理所有重复使用的线程,从而可以更好地利用这些可用的工作线程。\n控制并发数量。通过调整线程池中包含的线程数量,可以控制同一时间内允许运行的最大线程数目。这对于避免过载控制非常有用。\n提高资源利用率。 multiplex 可以重用同一个线程来处理多个任务,使资源得以更好地利用,比如共享内存的分配和设备等。\n管理任务的进度。线程池允许通过设置最大线程数来限制任务的并行进行数,以使任务进展得以控制和管理。\n避免死锁和饥饿，线程池可以通过控制线程的调度和资源分配来避免这些问题的发生。\n需要使用线程池的主要场景有:\nCPU 密集型任务。运行于循环或占用较长时钟周期的任务最适合使用线程池。\nI/O 密集型任务。涉及大量 I/O 等待的任务,比如数据库查询,网络请求等也非常合适。\n服务端应用。提供服务的应用,需要处理大量客户端请求,使用线程池可以管理多个请求使用同一个线程。\nGUI 应用。从事件驱动线程处理 GUI 事件的应用也应该使用线程池,以避免频繁创建和销毁 UI 线程。\n总结来说,在以下情况下,使用线程池会更为合适:\n任务较少,执行时间较长的任务。\n存在较长时间的 I/O 等待的任务。\n需要控制并发数的场景。如避免过载。\n需要重用空闲的工作线程的情况。如处理密集的但较短期的请求等。\n线程池的核心参数 创建一个线程池需要考虑的关键信息有:\n核心线程数(corePoolSize):线程池中始终存在的基本大小的工作线程数目。这个值通常很小,默认值是 1。\n最大线程数(maximumPoolSize):线程池能容纳的最大线程数。即使处理请求需要更多的工作线程,这个值也不会超过这个上限值。\n允许线程阻塞的时间(keepAliveTime):当空闲的工作线程数超过核心大小时,允许适当的扩充。当没有新的任务到达指定的时间后,线程池会进行判断,如果当前空闲的工作线程数超过核心大小,且空闲时间超过 keepAliveTime,那么多余的线程会被销毁。单位是毫秒。默认值是 60 秒。\n阻塞队列(BlockingQueue):用来存储任务的阻塞队列。通常选择 LinkedBlockingQueue 或者 ArrayBlockingQueue。他们同时还支持超时特性,可以指定阻塞队列不满时的超时时间。\n续约策略(补充策略):用于在任务捶捶式增长时决定是否增加或减少工作线程数的策略。常用策略有:\nFIFO FIFO 队列策略,按照任务添加到阻塞队列的顺序依次处理。公平性最强。 LIFO 后入先出队列策略。 PriorityQueue 优先级队列,根据任务优先级依次处理。 LinkedBlockingQueue 链式阻塞队列,默认使用 FIFO 策略。 ArrayBlockingQueue 数组阻塞队列,同样使用 FIFO 策略。\n边缘出发和水平触发 水平触发(level-trggered)\n只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知， 当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知 边缘触发(edge-triggered)\n当文件描述符关联的读内核缓冲区由空转化为非空的时候，则发出可读信号进行通知， 当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知 两者的区别？ 水平触发是只要读缓冲区有数据，就会一直触发可读信号，而边缘触发仅仅在空变为非空的时候通知一次，举个例子：\n读缓冲区刚开始是空的 读缓冲区写入2KB数据 水平触发和边缘触发模式此时都会发出可读信号 收到信号通知后，读取了1kb的数据，读缓冲区还剩余1KB数据 水平触发会再次进行通知，而边缘触发不会再进行通知\n所以边缘触发需要一次性的把缓冲区的数据读完为止，也就是一直读，直到读到EGAIN(EGAIN说明缓冲区已经空了)为止，因为这一点，边缘触发需要设置文件句柄为非阻塞。\nET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。\n在Linux中，epoll是一种I/O多路复用技术，可以高效地处理大量并发连接。epoll有两种工作模式：LT（Level Trigger，水平触发）和ET（Edge Trigger，边缘触发）。下面我们分别来看一下这两种模式的区别和适用场景。\nLT模式 在LT模式下，只要输入/输出条件满足，epoll就会通知应用程序。例如，只要数据是可读的（即使已经读过），epoll就会通知应用程序。\n这种模式的好处是比较容易理解和编程，因为即使你忽略了一次可读、可写的通知，只要满足条件，epoll还会继续通知你。这对于编写简单的单线程程序来说非常有用。\nET模式 与LT模式不同，ET模式下，epoll只在输入/输出状态发生变化时通知应用程序。例如，当文件描述符从不可读状态变为可读状态时，epoll会通知应用程序。但是，如果你忽略了这个通知，那么即使后续数据仍然可读，epoll也不会再次通知你。因此，在ET模式下，你需要一直读/写数据，直到数据完全读完或写完。\nET模式的好处是，因为通知次数少，所以性能更高。但是，编程也更复杂，因为你需要处理完所有的数据，否则可能会错过后续的通知。\n因此，ET模式适用于高性能、大并发的场景，比如高性能的网络服务器。而LT模式则适用于简单的单线程程序，或者对性能要求不是特别高的场景。\n需要注意的是，不论是LT模式还是ET模式，你都需要非阻塞的文件描述符，否则你可能会在等待数据时阻塞，这样就失去了使用epoll的意义。\n什么是非阻塞的文件描述符 非阻塞文件描述符是一种与 I/O 操作相关的概念，它与阻塞文件描述符相对应。以下是它们的主要区别：\n阻塞文件描述符（Blocking File Descriptor）： 默认情况下，大多数文件描述符都是阻塞的，包括标准输入、标准输出、套接字等。 当使用阻塞文件描述符进行读取（例如 read 函数）或写入（例如 write 函数）操作时，如果没有数据可读或没有足够的空间来写入数据，程序将被阻塞，直到满足操作的条件为止。 阻塞文件描述符通常会导致程序在进行 I/O 操作时暂停执行，直到数据可用或操作完成。 非阻塞文件描述符（Non-blocking File Descriptor）： 非阻塞文件描述符是通过设置文件描述符的标志位（通常使用 fcntl 函数或 O_NONBLOCK 标志）来实现的。 当使用非阻塞文件描述符进行读取或写入操作时，如果没有数据可读或没有足够的空间来写入数据，操作不会阻塞程序，而是立即返回一个错误或特定的返回码（通常是 -1），同时设置全局变量 errno 来指示错误的原因。 使用非阻塞文件描述符可以使程序避免在 I/O 操作上无限期地阻塞，从而允许程序在等待数据变得可用时执行其他任务或采取其他措施。 非阻塞文件描述符通常用于异步编程、事件驱动编程和多路复用机制（如 select、poll、epoll）中，以实现同时处理多个文件描述符的 I/O 操作，而不会阻塞整个程序的执行。这种方式可以提高程序的响应性和性能，特别适用于需要同时处理多个并发连接的服务器应用程序。\nepoll wait的time_out参数 当 timeout 参数设置为 0 时： 如果 timeout 设置为 0，epoll_wait 函数将立即返回，不会等待任何事件的发生。 这意味着它会立即查询文件描述符状态，然后返回已经准备好的文件描述符数目（可能为0），而不会等待事件的发生。这通常用于非阻塞的轮询操作。 当 timeout 参数设置为 -1 时： 如果 timeout 设置为 -1，epoll_wait 函数将一直等待，直到有一个或多个文件描述符上的事件发生，或者出现错误才返回。 这种情况下，epoll_wait 不会超时，会一直阻塞等待事件的发生。这通常用于实现一种阻塞的事件循环，使程序能够实时响应事件。 通常情况下，你可以根据应用程序的需求选择合适的超时时间。如果你希望立即返回而不阻塞，可以将超时设置为 0。如果你希望一直等待事件的发生，可以将超时设置为 -1。如果你希望在一定的时间间隔后返回，可以将超时设置为一个正整数，表示等待的毫秒数。根据具体的情况，你可以在事件循环中使用不同的超时参数来实现不同的逻辑。\n",
  "wordCount" : "9328",
  "inLanguage": "en",
  "datePublished": "2023-07-29T11:06:43+08:00",
  "dateModified": "2023-07-29T11:06:43+08:00",
  "author":[{
    "@type": "Person",
    "name": "chx9"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://chx9.github.io/posts/cs/webserver/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "chx9",
    "logo": {
      "@type": "ImageObject",
      "url": "https://chx9.github.io/img/svin.webp"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://chx9.github.io/" accesskey="h" title="chx9 (Alt + H)">chx9</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://chx9.github.io/search" title="🔍 search (Alt &#43; /)" accesskey=/>
                <span>🔍 search</span>
                </a>
            </li>
            <li>
                <a href="https://chx9.github.io/" title="🏠 home">
                <span>🏠 home</span>
                </a>
            </li>
            <li>
                <a href="https://chx9.github.io/posts" title="📚 articles">
                <span>📚 articles</span>
                </a>
            </li>
            <li>
                <a href="https://chx9.github.io/tags" title="🧩 tags">
                <span>🧩 tags</span>
                </a>
            </li>
            <li>
                <a href="https://chx9.github.io/about" title="🙋🏻‍♂️ about">
                <span>🙋🏻‍♂️ about</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }
</style>

<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://chx9.github.io/">🏠 主页</a>&nbsp;»&nbsp;<a href="https://chx9.github.io/posts/">📚Articles</a>&nbsp;»&nbsp;<a href="https://chx9.github.io/posts/cs/">💻 Programming</a></div>
            <h1 class="post-title">
                webserver
            </h1>
            <div class="post-meta">

<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2023-07-29
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>9328字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>19分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>chx9
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
            </span>
        </span>
    </span>
</span>
<span style="opacity: 0.8;">
                    <span id="post_meta_style_7">
                        &nbsp;&nbsp;
                        <span class="fa fa-eye" ></span>
                        <span>
                            <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
                            &nbsp;&nbsp;
                        </span>
                    </span>
                    <span id="post_meta_style_8">
                        <span class="fa fa-commenting-o"></span>
                        <span>
                            <script src="https://cdn.staticfile.org/twikoo//twikoo.all.min.js"></script>
                            <script>
                                let url = document.documentURI
                                
                                let dnsUrl = "https://chx9.github.io/"
                                let urlSplit = url.split(dnsUrl)
                                let finalUrl = urlSplit[1]
                                if (finalUrl[0] !== '/') {
                                    finalUrl = '/'+finalUrl
                                }
                                twikoo.getCommentsCount({
                                    envId:  null , 
                                region:  null , 
                                urls: [ 
                                    
                                    finalUrl,
                                ],
                                    includeReply: false 
                                }).then(function (res) {
                                    let count = res[0].count
                                    const obj = document.getElementById("comment_count");
                                    obj.innerText = count
                                    
                                    
                                    
                                }).catch(function (err) {
                                    
                                    console.error(err);
                                });
                            </script>
                            <span id="comment_count"></span>
                        </span>
                    </span>
                </span>

</div>
        </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#1%e9%87%87%e7%94%a8-io-%e5%a4%8d%e7%94%a8%e6%8a%80%e6%9c%af-epoll-%e5%92%8c%e7%ba%bf%e7%a8%8b%e6%b1%a0%e5%ae%9e%e7%8e%b0%e5%a4%9a%e7%ba%bf%e7%a8%8b%e7%9a%84-reactor-%e9%ab%98%e5%b9%b6%e5%8f%91%e6%a8%a1%e5%9e%8b" aria-label="1、采用 IO 复用技术 Epoll 和线程池实现多线程的 Reactor 高并发模型">1、采用 IO 复用技术 Epoll 和线程池实现多线程的 Reactor 高并发模型</a><ul>
                        
                <li>
                    <a href="#io-%e5%a4%8d%e7%94%a8" aria-label="IO 复用">IO 复用</a></li>
                <li>
                    <a href="#select" aria-label="select">select</a></li>
                <li>
                    <a href="#poll" aria-label="poll">poll</a></li>
                <li>
                    <a href="#epoll" aria-label="epoll">epoll</a></li>
                <li>
                    <a href="#ractor-%e6%a8%a1%e5%9e%8b%e5%92%8c-proactor-%e6%a8%a1%e5%9e%8b" aria-label="Ractor 模型和 Proactor 模型">Ractor 模型和 Proactor 模型</a></li>
                <li>
                    <a href="#epoll-%e8%a7%a6%e5%8f%91%e6%a8%a1%e5%bc%8f" aria-label="epoll 触发模式">epoll 触发模式</a></li></ul>
                </li>
                <li>
                    <a href="#epoll-%e5%ba%95%e5%b1%82%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e7%9a%84" aria-label="epoll 底层是如何实现的">epoll 底层是如何实现的</a></li>
                <li>
                    <a href="#2%e5%88%a9%e7%94%a8%e7%8a%b6%e6%80%81%e6%9c%ba%e5%92%8c%e6%ad%a3%e5%88%99%e8%a7%a3%e6%9e%90-http-%e6%8a%a5%e6%96%87%e8%af%b7%e6%b1%82%e5%ae%9e%e7%8e%b0%e9%9d%99%e6%80%81%e8%b5%84%e6%ba%90%e7%9a%84%e5%a4%84%e7%90%86" aria-label="2、利用状态机和正则解析 HTTP 报文请求，实现静态资源的处理">2、利用状态机和正则解析 HTTP 报文请求，实现静态资源的处理</a><ul>
                        
                <li>
                    <a href="#http-%e8%af%b7%e6%b1%82%e5%92%8c%e5%93%8d%e5%ba%94%e7%9a%84%e6%a0%bc%e5%bc%8f" aria-label="http 请求和响应的格式">http 请求和响应的格式</a></li></ul>
                </li>
                <li>
                    <a href="#3%e5%88%a9%e7%94%a8%e6%a0%87%e5%87%86%e5%ba%93%e5%ae%b9%e5%99%a8%e5%b0%81%e8%a3%85-char%e5%ae%9e%e7%8e%b0%e8%87%aa%e5%8a%a8%e5%a2%9e%e9%95%bf%e7%9a%84%e7%bc%93%e5%86%b2%e5%8c%ba" aria-label="3、利用标准库容器封装 char，实现自动增长的缓冲区">3、利用标准库容器封装 char，实现自动增长的缓冲区</a></li>
                <li>
                    <a href="#4%e5%9f%ba%e4%ba%8e%e5%b0%8f%e6%a0%b9%e5%a0%86%e5%ae%9e%e7%8e%b0%e5%ae%9a%e6%97%b6%e5%99%a8%e5%85%b3%e9%97%ad%e8%b6%85%e6%97%b6%e7%9a%84%e9%9d%9e%e6%b4%bb%e5%8a%a8%e9%93%be%e6%8e%a5" aria-label="4、基于小根堆实现定时器，关闭超时的非活动链接">4、基于小根堆实现定时器，关闭超时的非活动链接</a></li>
                <li>
                    <a href="#5%e5%88%a9%e7%94%a8-raii-%e6%9c%ba%e5%88%b6%e5%ae%9e%e7%8e%b0%e6%95%b0%e6%8d%ae%e5%ba%93%e8%bf%9e%e6%8e%a5%e6%b1%a0%e5%87%8f%e5%b0%91%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bb%ba%e7%ab%8b%e5%92%8c%e5%85%b3%e9%97%ad%e7%9a%84%e6%b6%88%e8%80%97" aria-label="5、利用 RAII 机制实现数据库连接池，减少数据库建立和关闭的消耗">5、利用 RAII 机制实现数据库连接池，减少数据库建立和关闭的消耗</a></li>
                <li>
                    <a href="#epoll-%e7%9a%84%e9%9b%b6%e6%8b%b7%e8%b4%9d%e6%8a%80%e6%9c%af" aria-label="epoll 的零拷贝技术">epoll 的零拷贝技术</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e7%ba%bf%e7%a8%8b%e6%b1%a0" aria-label="为什么要用线程池">为什么要用线程池</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e6%a0%b8%e5%bf%83%e5%8f%82%e6%95%b0" aria-label="线程池的核心参数">线程池的核心参数</a></li>
                <li>
                    <a href="#%e8%be%b9%e7%bc%98%e5%87%ba%e5%8f%91%e5%92%8c%e6%b0%b4%e5%b9%b3%e8%a7%a6%e5%8f%91" aria-label="边缘出发和水平触发">边缘出发和水平触发</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e9%9d%9e%e9%98%bb%e5%a1%9e%e7%9a%84%e6%96%87%e4%bb%b6%e6%8f%8f%e8%bf%b0%e7%ac%a6" aria-label="什么是非阻塞的文件描述符">什么是非阻塞的文件描述符</a></li>
                <li>
                    <a href="#epoll-wait%e7%9a%84time_out%e5%8f%82%e6%95%b0" aria-label="epoll wait的time_out参数">epoll wait的time_out参数</a>
                </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        if (elements) {
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                    (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                    return element;
                }
            }) || activeElement

            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                if (element === activeElement){
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
                } else {
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
                }
            })
        }
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        <div class="post-content"><h1 id="1采用-io-复用技术-epoll-和线程池实现多线程的-reactor-高并发模型">1、采用 IO 复用技术 Epoll 和线程池实现多线程的 Reactor 高并发模型<a hidden class="anchor" aria-hidden="true" href="#1采用-io-复用技术-epoll-和线程池实现多线程的-reactor-高并发模型">#</a></h1>
<h2 id="io-复用">IO 复用<a hidden class="anchor" aria-hidden="true" href="#io-复用">#</a></h2>
<p>IO 多路复用是现代操作系统中常用的一种网络编程技术。它允许一个<strong>进程同时监听多个文件描述符</strong>，从而<strong>可以同时处理多个网络连接，而无需为每个连接使用一个单独的线程。</strong></p>
<p>常用的 IO 多路复用的三种方式是 select、poll 和 epoll。它们的实现方式不同，但都可以实现 IO 多路复用的功能。它们的区别如下：</p>
<h2 id="select">select<a hidden class="anchor" aria-hidden="true" href="#select">#</a></h2>
<p>select 是最古老、最常见的 IO 多路复用方式之一。它使用一个文件描述符集合来监听多个文件描述符，当其中任何一个文件描述符变为可读或可写时，select 函数就会返回。</p>
<p>select 的一个缺点是它使用的是线性扫描算法，因此它的性能随着文件描述符数量的增加而逐渐降低。</p>
<h2 id="poll">poll<a hidden class="anchor" aria-hidden="true" href="#poll">#</a></h2>
<p>poll 是 select 的一种改进，它使用一个 pollfd 结构体数组来监听多个文件描述符。与 select 不同的是，pollfd 结构体数组是动态的，因此它可以监听更多的文件描述符。</p>
<p>poll 的一个缺点是它仍然使用线性扫描算法，因此它的性能也会受到文件描述符数量的限制。</p>
<h2 id="epoll">epoll<a hidden class="anchor" aria-hidden="true" href="#epoll">#</a></h2>
<p>epoll 是 Linux 特有的一种 IO 多路复用方式。它使用一个 epollfd 结构体来管理多个文件描述符，并使用事件通知机制来通知应用程序哪些文件描述符已准备好进行读写操作。</p>
<p>epoll 的优点是它使用了基于事件驱动的方式来通知应用程序，因此它的性能不会随着文件描述符数量的增加而下降。</p>
<p>Poll 机制相较于 Select 机制中，解决了文件描述符数量上限为 1024 的缺陷。但另外两点缺陷依然存在：</p>
<p>每次调用 poll，都需要把 fd 集合从用户态拷贝到内核态，fd 越多开销则越大；
每次调用 poll，都需要在内核遍历传递进来的所有 fd，这个开销在 fd 很多时也很大</p>
<p>epoll 是 Linux 下的一种 I/O 事件通知机制，可以用于高效地处理大量的 socket 连接。它提供了三个主要的函数：</p>
<ol>
<li><code>epoll_create()</code>：创建一个 epoll 实例，返回一个文件描述符。该函数的参数 size 指定 epoll 实例中最大的文件描述符数目，一般设置为需要监听的 socket 数。</li>
<li><code>epoll_ctl()</code>：向 epoll 实例中添加或删除一个文件描述符，或者修改一个文件描述符的监听事件。该函数的参数 epfd 是 epoll 实例的文件描述符，op 指定操作类型，fd 是需要添加/删除/修改的文件描述符，event 指定要监听的事件类型。</li>
<li><code>epoll_wait()</code>：等待文件描述符上的事件发生，当有事件发生时，该函数将返回一个结构体数组，每个结构体描述一个事件。该函数的参数 epfd 是 epoll 实例的文件描述符，events 是一个存放事件的数组，maxevents 指定最多返回的事件数目，timeout 指定等待的超时时间。如果 timeout 为-1，表示一直等待，直到有事件发生；如果 timeout 为 0，表示立即返回，不等待。</li>
</ol>
<p>单 reactor 多线程高并发模型有什么缺陷，在什么场景下会触发，解决办法是什么？</p>
<p>单 reactor 多线程高并发模型的缺陷在于：</p>
<ol>
<li>竞争条件：多个线程同时访问共享资源，容易出现竞争条件，导致数据不一致或者程序崩溃。</li>
<li>上下文切换：线程切换需要消耗时间，当线程数过多时，会导致过多的上下文切换，降低程序的性能。</li>
<li>瓶颈：单 reactor 模型只有一个事件循环，无法充分利用多核 CPU 的优势，无法处理更多的并发连接。</li>
</ol>
<p>当并发连接数量增加时，单 reactor 多线程模型容易出现线程切换开销大、竞争条件等问题，导致性能下降，甚至出现程序崩溃等情况。</p>
<h2 id="ractor-模型和-proactor-模型">Ractor 模型和 Proactor 模型<a hidden class="anchor" aria-hidden="true" href="#ractor-模型和-proactor-模型">#</a></h2>
<p>Reactor 模型：</p>
<ul>
<li>在 Reactor 模型中，应用程序将某个对象（通常是一个 socket）和其对应的事件处理函数注册到事件多路分发器上。然后，事件多路分发器会阻塞等待操作系统的事件通知。当某个对象上发生了注册的事件（例如，数据已经准备好可以读取），事件多路分发器就会调用相应的处理函数进行处理。</li>
</ul>
<p>因此，在 Reactor 模型中，所有 I/O 操作都由应用程序显示地触发。实际的 I/O 操作（例如读和写）是同步的，尽管事件分发是异步的。</p>
<p>Proactor 模型：</p>
<ul>
<li>Proactor 模型与 Reactor 模型的主要区别在于，I/O 操作的启动和完成都是异步的。当应用程序想要执行一个 I/O 操作时，它只需要发起该操作即可，然后就可以立即返回继续执行其他任务。当操作系统完成该操作时，它会自动调用预先注册的回调函数。</li>
</ul>
<p>因此，在 Proactor 模型中，应用程序无需关心具体的 I/O 操作，而只需要发起这些操作并处理它们的结果。</p>
<p>对比：</p>
<ul>
<li>
<p>操作复杂性：Reactor 模型中，应用程序需要负责管理 I/O 操作的具体过程，这使得编程较为复杂。相反，在 Proactor 模型中，操作系统会自动完成 I/O 操作，并在操作结束时通知应用程序，这使得编程更为简单。</p>
</li>
<li>
<p>I/O 操作的阻塞性：在 Reactor 模型中，I/O 操作本身是阻塞的，只有事件分发是异步的。这可能导致一些性能问题，特别是在处理大量并发请求时。相反，在 Proactor 模型中，所有的 I/O 操作都是非阻塞的，这使得它能够更好地支持大规模并发。</p>
</li>
</ul>
<p>应用场景：Reactor 模型更适合于需要立即响应事件但不需要执行大量 I/O 操作的情况，如 GUI 程序。而 Proactor 模型则更适合于需要处理大量并发 I/O 操作的情况，如网络服务器。</p>
<p>总的来说，Proactor 模型解决了 Reactor 模型中的一些问题，提供了一种更简洁、更高效的异步 I/O 实现方式。然而，选择哪种模型取决于具体的应用场景和需求。</p>
<h2 id="epoll-触发模式">epoll 触发模式<a hidden class="anchor" aria-hidden="true" href="#epoll-触发模式">#</a></h2>
<ol>
<li>
<p><strong>边缘触发 (Edge-triggered, ET) 与水平触发 (Level-triggered, LT) 的区别</strong></p>
<p>在 epoll 中，有两种事件触发模式：边缘触发和水平触发。</p>
<ul>
<li>边缘触发（ET）: 当被监控的 Socket 描述符上有可读事件发生时，服务器端只会从 epoll_wait 中苏醒一次。即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次。因此，我们的程序必须保证一次性读取完内核缓冲区的所有数据。</li>
<li>水平触发（LT）: 当被监控的 Socket 上有可读事件发生时，服务器端会不断地从 epoll_wait 中苏醒，直到内核缓冲区的数据被 read 函数完全读取。目的是告知我们有数据需要读取。</li>
</ul>
<p>举例来说：</p>
<ul>
<li>边缘触发类似于你的快递到达一个快递箱，这个快递箱只会通过短信通知你一次。即使你没有取走快递，它也不会再发送第二条短信提醒你。</li>
<li>水平触发就像快递箱发现你的快递还未取走，于是会不停地发短信提醒你，直到你取走了快递。</li>
</ul>
<p>总结下来：</p>
<p>水平触发是只要满足事件条件（例如内核中有数据需要读），就一直反复通知用户。而边缘触发则是当第一次满足条件的时候才触发，之后不会再传递同样的事件。</p>
<p>这种差异影响到两种模式的使用方式：</p>
<ul>
<li>在水平触发模式下，内核通知文件描述符可读写后，我们可以继续检查其状态，看它是否仍可读或可写。所以接到通知后，没有必要一次尽可能多地进行读写操作。</li>
<li>在边缘触发模式下，I/O 事件只会通知一次，而且我们无法知道能读写多少数据。所以收到通知后，应尽可能多地进行读写操作，避免错过读写机会。由于我们会循环读写文件描述符，如果文件描述符是阻塞的且没有数据可读写，进程会阻塞在那里，无法继续执行。因此，边缘触发模式常与非阻塞 I/O 配合使用，程序会持续执行 I/O 操作，直到系统调用（如 read 和 write）返回错误，错误类型为 EAGAIN 或 EWOULDBLOCK。</li>
</ul>
<p>通常，边缘触发模式的效率高于水平触发模式，因为边缘触发模式可以减少 epoll_wait 的系统调用次数，降低系统调用的开销（涉及上下文切换）。</p>
</li>
</ol>
<h1 id="epoll-底层是如何实现的">epoll 底层是如何实现的<a hidden class="anchor" aria-hidden="true" href="#epoll-底层是如何实现的">#</a></h1>
<p>一颗红黑树，一张准备就绪句柄链表，少量的内核 cache，就帮我们解决了大并发下的 socket 处理问题。</p>
<p>执行 epoll_create()时，创建了红黑树和就绪链表；</p>
<p>执行 epoll_ctl()时，如果增加 socket 句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据；</p>
<p>执行 epoll_wait()时立刻返回准备就绪链表里的数据即可。
<img loading="lazy" src="epoll.png" alt="epoll.png"  />

红黑树维护事件表，事件驱动机制下的回调函数加入就绪链表，拷贝只拷贝就绪链表</p>
<p>当某一进程调用 epoll_create 方法时，Linux 内核会创建一个 eventpoll 结构体，这个结构体中有两个成员与 epoll 的使用方式密切相关，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>truct eventpoll {
</span></span><span style="display:flex;"><span>   ...
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">/*红黑树的根节点，这棵树中存储着所有添加到epoll中的事件，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   也就是这个epoll监控的事件*/</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">rb_root</span> rbr;
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">/*双向链表rdllist保存着将要通过epoll_wait返回给用户的、满足条件的事件*/</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">list_head</span> rdllist;
</span></span><span style="display:flex;"><span>   ...
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>我们在调用 epoll_create 时，内核除了帮我们在 epoll 文件系统里建了个 file 结点，在内核 cache 里建了个红黑树用于存储以后 epoll_ctl 传来的 socket 外，还会再建立一个 rdllist 双向链表，用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个 rdllist 双向链表里有没有数据即可。有数据就返回，没有数据就 sleep，等到 timeout 时间到后即使链表没数据也返回。所以，epoll_wait 非常高效。</p>
<p>所有添加到 epoll 中的事件都会与设备(如网卡)驱动程序建立回调关系，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做 ep_poll_callback，它会把这样的事件放到上面的 rdllist 双向链表中。</p>
<p>在 epoll 中对于每一个事件都会建立一个 epitem 结构体，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">epitem</span> {
</span></span><span style="display:flex;"><span>     ...
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">//红黑树节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">rb_node</span> rbn;
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">//双向链表节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">list_head</span> rdllink;
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">//事件句柄等信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">epoll_filefd</span> ffd;
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">//指向其所属的eventepoll对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">eventpoll</span> <span style="color:#f92672">*</span>ep;
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">//期待的事件类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">epoll_event</span> event;
</span></span><span style="display:flex;"><span>     ...
</span></span><span style="display:flex;"><span>}; <span style="color:#75715e">// 这里包含每一个事件对应着的信息。
</span></span></span></code></pre></div><h1 id="2利用状态机和正则解析-http-报文请求实现静态资源的处理">2、利用状态机和正则解析 HTTP 报文请求，实现静态资源的处理<a hidden class="anchor" aria-hidden="true" href="#2利用状态机和正则解析-http-报文请求实现静态资源的处理">#</a></h1>
<p>状态机一共有四个状态：REQUEST_LINE， HEADERS， BODY， FINISH，分别对应了 http 请求的三个内容，FINISH 是结束，程序通过 while 循环，将状态从 REQUEST_LINE→Headers→Body→Finish 转换。</p>
<h2 id="http-请求和响应的格式">http 请求和响应的格式<a hidden class="anchor" aria-hidden="true" href="#http-请求和响应的格式">#</a></h2>
<p>请求格式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>Method<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span>Request<span style="color:#f92672">-</span>URI<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span>HTTP<span style="color:#f92672">-</span>Version<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>Headers<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>Body<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><p>响应格式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-coq" data-lang="coq"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>HTTP<span style="color:#f92672">-</span>Version<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span>Status<span style="color:#f92672">-</span>Code<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span>Reason<span style="color:#f92672">-</span>Phrase<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>Headers<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>Body<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><h1 id="3利用标准库容器封装-char实现自动增长的缓冲区">3、利用标准库容器封装 char，实现自动增长的缓冲区<a hidden class="anchor" aria-hidden="true" href="#3利用标准库容器封装-char实现自动增长的缓冲区">#</a></h1>
<p><strong>缓冲区功能</strong>如果是固定的缓冲区，在存储小数据时会照成极大资源的浪费。自动增长的缓存区会根据每个客户端的请求响应数据大小，自适应的调整缓冲区大小。</p>
<p><strong>缓冲区场景</strong></p>
<ol>
<li>从内核缓冲区中分散读取数据至缓冲区（in）</li>
<li>HTTP 数据解析的时候，将缓冲区的数据读出（out）</li>
<li>HTTP 生成响应数据的时候，会写入缓冲区（in）</li>
<li>将缓冲区中的数据写入内核缓冲区（out）</li>
</ol>
<p><strong>如何扩容：</strong></p>
<p>从内核缓冲区读数据采用的是<strong>分散读（readv）</strong>，会定义一个长度为 2 的结构体 iovec 数组（0 存放缓冲区可写部分，1 存放一个临时 char 数组）。在读的时候会首先将 WritableBytes 空间占满，当还有数据需要写入的时候就需要扩容。扩容分为两种情况，因为在 HTTP 类解析缓冲区数据的时候，readPos_会不断增加，那么 PrependableBytes 就会不断增加，这块区域是空闲的，如果说 WritableBytes 和 PrependableBytes 的空间大小满组的话，那就只需要移动数据。那如果不满足的话，就要 resize 缓冲区的大小。</p>
<p><strong>分散写：</strong></p>
<p>写的内容也是被放在一个 2 个大小 iovec 数组（0 存放响应头，1 存放 html 文件）</p>
<ul>
<li>
<p>代码详解</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Buffer</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  Buffer(<span style="color:#66d9ef">int</span> initBuffSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">1024</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">~</span>Buffer() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 有多少字节的数据可以写
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  size_t <span style="color:#a6e22e">WritableBytes</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 有多少字节的数据可以读
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  size_t <span style="color:#a6e22e">ReadableBytes</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// buffer头部有多少字节的数据空出来
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  size_t <span style="color:#a6e22e">PrependableBytes</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 返回第一个可读字节的char地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Peek</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 确保WritableBytes小于len，如果不是，就调用MakeSpace_动态扩容
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">EnsureWriteable</span>(size_t len);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 写入结束，更新writePos_
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">HasWritten</span>(size_t len);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 写出，根据长度调整readPos_
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Retrieve</span>(size_t len);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 写出，根据指针计算写出的长度，并调用Retrieve
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">RetrieveUntil</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>end);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 重置缓冲区，在写入内核区缓存后来调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">RetrieveAll</span>();
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>string RetrieveAllToStr();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 定位buffer内数据段末尾，在了http解析函数中使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">BeginWriteConst</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 定位buffer内数据段首部
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">BeginWrite</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 动态扩容
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Append</span>(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string <span style="color:#f92672">&amp;</span>str);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 核心是这个，其他重载函数内部调用了这个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Append</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>str, size_t len);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Append</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data, size_t len);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Append</span>(<span style="color:#66d9ef">const</span> Buffer <span style="color:#f92672">&amp;</span>buff);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 采用分散读，分散读的好处是减少系统调用次数，提高IO效率
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ssize_t <span style="color:#a6e22e">ReadFd</span>(<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>Errno);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 这个函数没有用，WriteFd写在了HttpConn::write中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ssize_t <span style="color:#a6e22e">WriteFd</span>(<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>Errno);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 返回buffer头部指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>BeginPtr_();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">BeginPtr_</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 若PrependableBytes和WritableBytes大于len，整体数据往前移，若小于，那就要resize
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MakeSpace_</span>(size_t len);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 用动态数组封装的char缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> buffer_;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 如果没有实现log的话，就不需要原子，因为每个线程独自占有各自的buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>size_t<span style="color:#f92672">&gt;</span> readPos_;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>size_t<span style="color:#f92672">&gt;</span> writePos_;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Buffer 类中的成员变量包括一个动态数组封装的 char 缓冲区 buffer*，以及两个 std::atomic<a href="std::size_t">std::size_t</a>类型的变量 readPos*和 writePos_，分别表示当前缓冲区的读取位置和写入位置。
类中提供的主要接口包括：</p>
<ul>
<li>WritableBytes()、ReadableBytes()、PrependableBytes()：分别用于获取缓冲区中可以写入的字节数、可以读取的字节数和缓冲区头部留出来的字节数。</li>
<li>Peek()：返回缓冲区中第一个可读字节的 char 地址。</li>
<li>EnsureWriteable()：确保缓冲区中可以写入的字节数大于等于 len，如果不够则进行动态扩容。</li>
<li>HasWritten()：写入结束后更新 writePos_。</li>
<li>Retrieve()、RetrieveUntil()：用于将已读取的数据从缓冲区中移除。</li>
<li>RetrieveAll()、RetrieveAllToStr()：用于将缓冲区中所有数据移除并返回。</li>
<li>BeginWriteConst()、BeginWrite()：返回缓冲区中可写数据的起始地址。</li>
<li>Append()：用于向缓冲区中增加额外的数据。</li>
<li>ReadFd()：用于采用分散读方式从文件描述符 fd 中读取数据并写入缓冲区。
除此之外，类中还有一些私有函数，用于实现动态扩容、返回 buffer 头部指针等功能。</li>
</ul>
</li>
</ul>
<p>非阻塞模式下 read 返回值  &lt; 0 表示没有数据，= 0 表示连接断开，&gt; 0 表示接收到数据。</p>
<h1 id="4基于小根堆实现定时器关闭超时的非活动链接">4、基于小根堆实现定时器，关闭超时的非活动链接<a hidden class="anchor" aria-hidden="true" href="#4基于小根堆实现定时器关闭超时的非活动链接">#</a></h1>
<p>功能:为每一个客户端设置一个定时器，用户关闭超时的非活动链接。</p>
<p>实现:定义了一个定时器结构体，包括 id（服务端为每个客户端分配的文件描述符），过期时间，回调函数以及重载了一个比较操作符。实现了一个 HeapTimer 类，用于存储管理定时器。此外还设计了 Tick 和 GetNextTick 函数。</p>
<p>Trik 函数用于更新计时器堆的状态，通过 while 循环来不断 pop 出超时的定时器节点。</p>
<p>GetNextTrick 用于返回堆顶元素的到期时间戳与当前时间戳的差，如果堆为空，则返回-1。同时，结合这个返回到期时间戳的函数，可以减少<strong>epoll_wait</strong>系统调用次数，来提高效率。epoll_wait 有一个参数叫 timeout，设置为 0，会直接返回，如果是-1 就一直阻塞，如果大于 0，表示要最多等到 timeout 时间才返回。那么我们假设 timeout 这段时间内没有新的事件发生，就没有必要一直轮询。</p>
<h1 id="5利用-raii-机制实现数据库连接池减少数据库建立和关闭的消耗">5、利用 RAII 机制实现数据库连接池，减少数据库建立和关闭的消耗<a hidden class="anchor" aria-hidden="true" href="#5利用-raii-机制实现数据库连接池减少数据库建立和关闭的消耗">#</a></h1>
<h1 id="epoll-的零拷贝技术">epoll 的零拷贝技术<a hidden class="anchor" aria-hidden="true" href="#epoll-的零拷贝技术">#</a></h1>
<p>在使用 epoll 进行网络编程时，零拷贝技术可以提高数据传输的效率，减少 CPU 的使用率和数据复制的开销。</p>
<p>具体来说，epoll 的零拷贝技术可以通过以下两种方式实现：</p>
<ol>
<li>sendfile 系统调用</li>
</ol>
<p>sendfile 系统调用可以将文件数据直接从内核缓冲区发送到网络中，而无需将数据从内核缓冲区复制到用户空间缓冲区。在使用 epoll 进行网络编程时，可以通过 sendfile 系统调用将文件数据直接发送到网络中，从而避免了数据复制的开销。这种方式称为 epoll 的“零拷贝”技术。</p>
<ol start="2">
<li>mmap 系统调用</li>
</ol>
<p>mmap 系统调用可以将文件映射到进程的地址空间中，从而使得应用程序可以直接访问文件数据，而无需进行读写操作。在使用 epoll 进行网络编程时，可以通过 mmap 系统调用将文件映射到进程的地址空间中，然后使用 send 系统调用将数据直接从内核缓冲区发送到网络中，从而避免了数据复制的开销。</p>
<p>总的来说，epoll 的零拷贝技术可以将数据传输的效率提高到极致，减少 CPU 的使用率和数据复制的开销。这在高并发的网络编程中非常有用，可以显著提高系统的性能和稳定性。</p>
<h1 id="为什么要用线程池">为什么要用线程池<a hidden class="anchor" aria-hidden="true" href="#为什么要用线程池">#</a></h1>
<p>使用线程池的主要原因有:</p>
<ul>
<li>
<p>避免频繁创建和销毁线程。在使用超时或存在较长的 Waiting 时间的应用中,如果每次都需要创建一个新的线程将造成较大的开销。线程池可以重用过期的空闲线程,从而避免线程创建的开销。</p>
</li>
<li>
<p>提高线程的可用性。在线程池中,可以有效地管理所有重复使用的线程,从而可以更好地利用这些可用的工作线程。</p>
</li>
<li>
<p>控制并发数量。通过调整线程池中包含的线程数量,可以控制同一时间内允许运行的最大线程数目。这对于避免过载控制非常有用。</p>
</li>
<li>
<p>提高资源利用率。 multiplex 可以重用同一个线程来处理多个任务,使资源得以更好地利用,比如共享内存的分配和设备等。</p>
</li>
<li>
<p>管理任务的进度。线程池允许通过设置最大线程数来限制任务的并行进行数,以使任务进展得以控制和管理。</p>
</li>
<li>
<p>避免死锁和饥饿，线程池可以通过控制线程的调度和资源分配来避免这些问题的发生。</p>
</li>
</ul>
<p>需要使用线程池的主要场景有:</p>
<p>CPU 密集型任务。运行于循环或占用较长时钟周期的任务最适合使用线程池。</p>
<p>I/O 密集型任务。涉及大量 I/O 等待的任务,比如数据库查询,网络请求等也非常合适。</p>
<p>服务端应用。提供服务的应用,需要处理大量客户端请求,使用线程池可以管理多个请求使用同一个线程。</p>
<p>GUI 应用。从事件驱动线程处理 GUI 事件的应用也应该使用线程池,以避免频繁创建和销毁 UI 线程。</p>
<p>总结来说,在以下情况下,使用线程池会更为合适:</p>
<p>任务较少,执行时间较长的任务。</p>
<p>存在较长时间的 I/O 等待的任务。</p>
<p>需要控制并发数的场景。如避免过载。</p>
<p>需要重用空闲的工作线程的情况。如处理密集的但较短期的请求等。</p>
<h1 id="线程池的核心参数">线程池的核心参数<a hidden class="anchor" aria-hidden="true" href="#线程池的核心参数">#</a></h1>
<p>创建一个线程池需要考虑的关键信息有:</p>
<p>核心线程数(corePoolSize):线程池中始终存在的基本大小的工作线程数目。这个值通常很小,默认值是 1。</p>
<p>最大线程数(maximumPoolSize):线程池能容纳的最大线程数。即使处理请求需要更多的工作线程,这个值也不会超过这个上限值。</p>
<p>允许线程阻塞的时间(keepAliveTime):当空闲的工作线程数超过核心大小时,允许适当的扩充。当没有新的任务到达指定的时间后,线程池会进行判断,如果当前空闲的工作线程数超过核心大小,且空闲时间超过 keepAliveTime,那么多余的线程会被销毁。单位是毫秒。默认值是 60 秒。</p>
<p>阻塞队列(BlockingQueue):用来存储任务的阻塞队列。通常选择 LinkedBlockingQueue 或者 ArrayBlockingQueue。他们同时还支持超时特性,可以指定阻塞队列不满时的超时时间。</p>
<p>续约策略(补充策略):用于在任务捶捶式增长时决定是否增加或减少工作线程数的策略。常用策略有:</p>
<p>FIFO FIFO 队列策略,按照任务添加到阻塞队列的顺序依次处理。公平性最强。
LIFO 后入先出队列策略。
PriorityQueue 优先级队列,根据任务优先级依次处理。
LinkedBlockingQueue 链式阻塞队列,默认使用 FIFO 策略。
ArrayBlockingQueue 数组阻塞队列,同样使用 FIFO 策略。</p>
<h1 id="边缘出发和水平触发">边缘出发和水平触发<a hidden class="anchor" aria-hidden="true" href="#边缘出发和水平触发">#</a></h1>
<p>水平触发(level-trggered)</p>
<ul>
<li>只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知，</li>
<li>当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知</li>
</ul>
<p>边缘触发(edge-triggered)</p>
<ul>
<li>当文件描述符关联的读内核缓冲区由空转化为非空的时候，则发出可读信号进行通知，</li>
<li>当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知</li>
</ul>
<p>两者的区别？
水平触发是只要读缓冲区有数据，就会一直触发可读信号，而边缘触发仅仅在空变为非空的时候通知一次，举个例子：</p>
<p>读缓冲区刚开始是空的
读缓冲区写入2KB数据
水平触发和边缘触发模式此时都会发出可读信号
收到信号通知后，读取了1kb的数据，读缓冲区还剩余1KB数据
水平触发会再次进行通知，而边缘触发不会再进行通知</p>
<p>所以边缘触发需要一次性的把缓冲区的数据读完为止，也就是一直读，直到读到EGAIN(EGAIN说明缓冲区已经空了)为止，因为这一点，边缘触发需要设置文件句柄为非阻塞。</p>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<p>在Linux中，epoll是一种I/O多路复用技术，可以高效地处理大量并发连接。epoll有两种工作模式：LT（Level Trigger，水平触发）和ET（Edge Trigger，边缘触发）。下面我们分别来看一下这两种模式的区别和适用场景。</p>
<p>LT模式
在LT模式下，只要输入/输出条件满足，epoll就会通知应用程序。例如，只要数据是可读的（即使已经读过），epoll就会通知应用程序。</p>
<p>这种模式的好处是比较容易理解和编程，因为即使你忽略了一次可读、可写的通知，只要满足条件，epoll还会继续通知你。这对于编写简单的单线程程序来说非常有用。</p>
<p>ET模式
与LT模式不同，ET模式下，epoll只在输入/输出状态发生变化时通知应用程序。例如，当文件描述符从不可读状态变为可读状态时，epoll会通知应用程序。但是，如果你忽略了这个通知，那么即使后续数据仍然可读，epoll也不会再次通知你。因此，在ET模式下，你需要一直读/写数据，直到数据完全读完或写完。</p>
<p>ET模式的好处是，因为通知次数少，所以性能更高。但是，编程也更复杂，因为你需要处理完所有的数据，否则可能会错过后续的通知。</p>
<p>因此，ET模式适用于高性能、大并发的场景，比如高性能的网络服务器。而LT模式则适用于简单的单线程程序，或者对性能要求不是特别高的场景。</p>
<p>需要注意的是，不论是LT模式还是ET模式，你都需要非阻塞的文件描述符，否则你可能会在等待数据时阻塞，这样就失去了使用epoll的意义。</p>
<h1 id="什么是非阻塞的文件描述符">什么是非阻塞的文件描述符<a hidden class="anchor" aria-hidden="true" href="#什么是非阻塞的文件描述符">#</a></h1>
<p>非阻塞文件描述符是一种与 I/O 操作相关的概念，它与阻塞文件描述符相对应。以下是它们的主要区别：</p>
<ol>
<li>阻塞文件描述符（Blocking File Descriptor）：
<ul>
<li>默认情况下，大多数文件描述符都是阻塞的，包括标准输入、标准输出、套接字等。</li>
<li>当使用阻塞文件描述符进行读取（例如 <code>read</code> 函数）或写入（例如 <code>write</code> 函数）操作时，如果没有数据可读或没有足够的空间来写入数据，程序将被阻塞，直到满足操作的条件为止。</li>
<li>阻塞文件描述符通常会导致程序在进行 I/O 操作时暂停执行，直到数据可用或操作完成。</li>
</ul>
</li>
<li>非阻塞文件描述符（Non-blocking File Descriptor）：
<ul>
<li>非阻塞文件描述符是通过设置文件描述符的标志位（通常使用 <code>fcntl</code> 函数或 <code>O_NONBLOCK</code> 标志）来实现的。</li>
<li>当使用非阻塞文件描述符进行读取或写入操作时，如果没有数据可读或没有足够的空间来写入数据，操作不会阻塞程序，而是立即返回一个错误或特定的返回码（通常是 <code>-1</code>），同时设置全局变量 <code>errno</code> 来指示错误的原因。</li>
<li>使用非阻塞文件描述符可以使程序避免在 I/O 操作上无限期地阻塞，从而允许程序在等待数据变得可用时执行其他任务或采取其他措施。</li>
</ul>
</li>
</ol>
<p>非阻塞文件描述符通常用于异步编程、事件驱动编程和多路复用机制（如 <code>select</code>、<code>poll</code>、<code>epoll</code>）中，以实现同时处理多个文件描述符的 I/O 操作，而不会阻塞整个程序的执行。这种方式可以提高程序的响应性和性能，特别适用于需要同时处理多个并发连接的服务器应用程序。</p>
<h1 id="epoll-wait的time_out参数">epoll wait的time_out参数<a hidden class="anchor" aria-hidden="true" href="#epoll-wait的time_out参数">#</a></h1>
<ol>
<li>当 <code>timeout</code> 参数设置为 <code>0</code> 时：
<ul>
<li>如果 <code>timeout</code> 设置为 <code>0</code>，<code>epoll_wait</code> 函数将立即返回，不会等待任何事件的发生。</li>
<li>这意味着它会立即查询文件描述符状态，然后返回已经准备好的文件描述符数目（可能为0），而不会等待事件的发生。这通常用于非阻塞的轮询操作。</li>
</ul>
</li>
<li>当 <code>timeout</code> 参数设置为 <code>-1</code> 时：
<ul>
<li>如果 <code>timeout</code> 设置为 <code>-1</code>，<code>epoll_wait</code> 函数将一直等待，直到有一个或多个文件描述符上的事件发生，或者出现错误才返回。</li>
<li>这种情况下，<code>epoll_wait</code> 不会超时，会一直阻塞等待事件的发生。这通常用于实现一种阻塞的事件循环，使程序能够实时响应事件。</li>
</ul>
</li>
</ol>
<p>通常情况下，你可以根据应用程序的需求选择合适的超时时间。如果你希望立即返回而不阻塞，可以将超时设置为 <code>0</code>。如果你希望一直等待事件的发生，可以将超时设置为 <code>-1</code>。如果你希望在一定的时间间隔后返回，可以将超时设置为一个正整数，表示等待的毫秒数。根据具体的情况，你可以在事件循环中使用不同的超时参数来实现不同的逻辑。</p>


        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://chx9.github.io/posts/cs/cpp/">
    <span class="title">« 上一页</span>
    <br>
    <span>C&#43;&#43;</span>
  </a>
  <a class="next" href="https://chx9.github.io/posts/cs/mysql/">
    <span class="title">下一页 »</span>
    <br>
    <span>mysql</span>
  </a>
</nav>

        </footer>
    </div>

<style>
    .comments_details summary::marker {
        font-size: 20px;
        content: '👉展开评论';
        color: var(--content);
    }
    .comments_details[open] summary::marker{
        font-size: 20px;
        content: '👇关闭评论';
        color: var(--content);
    }
</style>


<div>
    <details class="comments_details">
        <summary style="cursor: pointer; margin: 50px 0 20px 0;width: 130px;">
            <span style="font-size: 20px;color: var(--content);">...</span>
        </summary>
        <div id="tcomment"></div>
    </details>
    <script src="https://cdn.staticfile.org/twikoo//twikoo.all.min.js">
    </script>
    <script>
        twikoo.init({
            envId:  null ,
        el: "#tcomment",
            lang: 'zh-CN',
            region:  null ,
        path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
        })
    </script>
</div>
</article>
</main>

<footer class="footer">
    <span>
        Copyright
        &copy;
        -2023
        <a href="https://chx9.github.io/" style="color:#939393;">chx9</a>
        All Rights Reserved
    </span>
    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;"></a>&nbsp;
    <span>
        <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null"
           style="display:inline-block;text-decoration:none;height:20px;color:#939393;">
            <img src="" style="float:left;margin: 0px 5px 0px 0px;"/>
            
        </a>
    </span>
    <span id="busuanzi_container">
        <span class="fa fa-user"></span> <span id="busuanzi_value_site_uv"></span>
        <span class="fa fa-eye"></span> <span id="busuanzi_value_site_pv"></span>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
</script>
<script>
    let mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        (function() {
            document.cookie = "change-themes" + "="+ escape ("false");
        })()

        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    });
</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() 
                let textData = window.getSelection().toString() 
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
                
                
                
                
                
                
                
                
                
                
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;
        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '📄复制';

        function copyingDone() {
            copybutton.innerText = '👌🏻已复制!';
            setTimeout(() => {
                copybutton.innerText = '📄复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent 
                
                
                
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {}
            selection.removeRange(range);
        });

        let language = codeblock.className.replaceAll("language-", "")
        let macTool = document.createElement("div")
        let macTool1 = document.createElement("div")
        let macTool2 = document.createElement("div")
        let macTool3 = document.createElement("div")
        let languageType = document.createElement("div")
        languageType.innerText = language
        
        
        
        
        languageType.setAttribute('class', 'language-type')
        macTool.appendChild(macTool1)
        macTool.appendChild(macTool2)
        macTool.appendChild(macTool3)
        macTool.appendChild(languageType)

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
            container.appendChild(macTool)
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        }
    });
</script>
</body>

</html>
