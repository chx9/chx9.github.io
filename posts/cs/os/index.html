<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Operating System | chx9</title>
<meta name="keywords" content="">
<meta name="description" content="进程和线程区别 1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序 2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。线程启动速度快，轻量级 进程">
<meta name="author" content="chx9">
<link rel="canonical" href="/posts/cs/os/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="img/svin.webp">
<link rel="icon" type="image/png" sizes="16x16" href="img/svin.webp">
<link rel="icon" type="image/png" sizes="32x32" href="img/svin.webp">
<link rel="apple-touch-icon" href="img/svin.webp">
<link rel="mask-icon" href="img/svin.webp">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script defer src="https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="Operating System" />
<meta property="og:description" content="进程和线程区别 1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序 2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。线程启动速度快，轻量级 进程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/cs/os/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-29T11:05:53+08:00" />
<meta property="article:modified_time" content="2023-07-29T11:05:53+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Operating System"/>
<meta name="twitter:description" content="进程和线程区别 1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序 2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。线程启动速度快，轻量级 进程"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [

        {
          "@type": "ListItem",
          "position":  2 ,
          "name": "📚Articles",
          "item": "/posts/"
        },

        {
          "@type": "ListItem",
          "position":  3 ,
          "name": "💻 Programming Basics",
          "item": "/posts/cs/"
        }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Operating System",
      "item": "/posts/cs/os/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Operating System",
  "name": "Operating System",
  "description": "进程和线程区别 1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序 2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。线程启动速度快，轻量级 进程",
  "keywords": [
    ""
  ],
  "articleBody": "进程和线程区别 1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序\n2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。线程启动速度快，轻量级\n进程的资源：\n独立的内存空间（虚拟地址空间） 系统资源，如打开的文件、信号处理器等 线程的资源:\n程序计数器：用于指令读取，函数调用，指令跳转 寄存器：用于保存线程的上下文信息。 栈 协程 协程是用户态的轻量级线程，线程内部调度的基本单位，都是运行在用户态，拥有自己的寄存器上下文和栈 c++的协程库: boost coroutine, libco\n线程由操作系统管理，切换需要操作系统内核，耗费时间和资源，协程切换是程序员自己控制 线程之间通信通过共享内存或者传递消息，而协程之间直接通过函数调用或者共享变量 线程可以通过多个 cpu 实现并行，但是协程只在一个线程中 线程创建、销毁需要操作系统接入，而协程在用户空间内完成 协程适用于 高并的网络编程，异步 io 操作，高并发网络编程，**短时间的计算密集型，**线程：cpu 密集型 多个线程情况下 CPU 利用率不高 1、同步和通信不高效(死锁，数据竞争)\n2、线程过多：竞争过于激烈； 线程数过少：CPU 核心限制\n3、io 密集型\nepoll 的底层实现 红黑树用来管理所有的文件描述符\n内核中的事件表：存储所有就绪的文件描述符\n内核中的回调函数：内核调用回调函数处理处理所有就绪的文件描述符 同步模型的优点：\n同步 io 和异步 io 的优缺点 同步 io 优点：\n编程简单 可靠性高（阻塞） 同步模型的缺点：\n性能低（阻塞） 异步模型的优点： 高性能 编程复杂 异步模型的缺点：\n可靠性低（可能会出现操作未完成就返回结果，需要判断错误） 互斥锁、读写锁、自旋锁 互斥锁，最基本的同步机制，保护临界区资源访问\n读写锁，允许多个线程同时读共享资源，但是只允许一个锁读取共享资源，读写锁的实现通常是基于互斥锁和条件变量实现的。\n自旋锁是一种轻量级同步机制，当自旋锁被占用时，线程不会进入阻塞状态，而是一直循环等待，适用于锁占用短的场景，锁占用长的\n加锁的方式 阻塞锁，一直等待资源 自旋锁，一直循环等待 乐观锁，假设读取共享资源的时候不会修改它，如果被修改了，就重新尝试 信号量能保证线程同步吗？ 信号量可以用来保证线程同步，但最好与锁一起使用来保证线程互斥。信号量是一种计数器，用来保护共享资源。当一个线程想要访问共享资源时，它必须先获取信号量，然后才能访问共享资源。如果信号量的计数器为 0，则线程必须等待，直到有另一个线程释放信号量。这样可以确保多个线程不会同时访问共享资源，从而保证线程同步。\n在使用信号量时，需要注意一些问题。首先，信号量只能保证线程同步，不能保证线程互斥。如果多个线程都可以获得信号量，则它们可以同时访问共享资源。因此，最好与锁一起使用来保证线程互斥。其次，信号量可能会产生死锁问题。当多个线程互相等待对方释放信号量时，就会发生死锁。因此，在使用信号量时，需要仔细考虑并发情况，以确保线程安全和性能。\nlinux 下递归删除某个目录下以 cpp 为结尾的文件 find /path/to/directory -type f -name \"*.cpp\" -delete 如果不加 -type f，find 命令会查找目录中的所有类型的文件，包括普通文件、目录、符号链接等，可能会误删一些非文件类型的内容。加上 -type f 可以限定只查找普通文件，避免误删其他类型的内容。\n死锁的四个条件 互斥条件：一个资源每次只能被一个进程使用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 如果一个系统中存在上述四个条件，就会出现死锁的情况，死锁的解决方法通常需要采用多种方法，如锁机制的优化、资源分配算法的改进等。\n内核态和用户态 内核态（Kernel Mode）和用户态（User Mode） 是操作系统设计中的两种运行级别或模式，用于区分进程对硬件资源的访问权限。\n内核态（Kernel Mode）\n在内核态下，代码有权访问系统的任何资源，不受任何保护和限制。它可以直接执行任意 CPU 指令，可以访问任何物理内存地址，也可以访问和操作所有的硬件设备。 由于其高权限，内核态主要被操作系统内核、设备驱动程序等使用。 错误的操作可能导致整个系统崩溃或者数据丢失。 用户态（User Mode） 在用户态下，代码执行在一个受保护的环境中，只能访问一部分范围的内存，不能直接访问硬件设备，对 CPU 指令集的使用也有所限制。 当一个用户程序需要进行一项系统调用（如读写文件，发送网络数据）时，它会切换到内核态，由内核代为完成，然后再切换回用户态。 这种机制能够保护系统的稳定性和安全性，防止用户程序的错误操作影响整个系统。 linux 常用命令 下面列举一些常用的 Linux 命令：\nls：列出目录下的文件和子目录。 cd：切换当前目录。 pwd：显示当前所在目录的路径。 mkdir：创建一个新目录。 rmdir：删除一个空目录。 rm：删除文件或目录。 cp：复制文件或目录。 mv：移动或重命名文件或目录。 cat：查看文件内容。 grep：在文件或输入流中查找匹配的文本。 tail：查看文件的末尾内容。 head：查看文件的开头内容。 find：在指定目录下查找文件。 chmod：修改文件或目录的权限。 chown：修改文件或目录的所有者。 ps：查看当前系统进程。 top：查看当前系统资源占用情况。 tar：打包和解压缩文件。 ssh：远程登录到另一台计算机。 scp：在本地和远程计算机之间复制文件。 df：查看磁盘空间使用情况。 free：查看系统内存使用情况。 uname：查看系统信息。 ifconfig：查看网络接口信息。 ping：测试网络连接。 traceroute：查看网络路由情况。 netstat：显示网络连接、路由表和网络接口等信息。 iptables：管理系统防火墙规则。 systemctl：管理系统服务。 ps aux：显示所有进程的详细信息。 kill：终止指定进程。 nohup：让进程在后台运行。 screen：在一个终端窗口中打开多个终端会话。 wget：下载文件。 curl：向服务器发送请求并显示响应。 tar：压缩和解压缩文件。 gzip：压缩和解压缩文件。 zip：压缩和解压缩文件。 ssh-keygen：生成 SSH 密钥对。 linux 中查询进程占用 cpu 的情况 在 Linux 系统中，可以使用 top 命令来查看系统中占用 CPU 最多的进程，具体操作如下：\n打开终端并输入 top 命令。 top 命令会实时显示系统资源使用情况，包括 CPU、内存、进程等。在进程列表中，可以看到各个进程的 CPU 使用情况以及其他相关信息。 进程列表默认按照 CPU 使用率排序，可以通过按下“P”键，然后再按下“Enter”键，将进程列表按照 CPU 使用率从高到低排序。\n打开终端并输入 ps aux 命令。 ps 命令会列出当前系统中所有的进程，包括进程的 PID、CPU 占用率、内存使用情况等。 若要按照 CPU 使用率排序，可以使用 ps aux –sort=-%cpu 命令。\n0 拷贝 小林 coding\n普通拷贝 内存映射 mmap sendfile 零拷贝（Zero Copy）是一种提高数据传输效率和性能的技术，其基本思想是在数据传输过程中减少数据拷贝和内存复制操作，从而减少 CPU 的开销和系统资源的占用，提高数据传输的效率和性能。\n在传统的数据传输方式中，数据通常需要从应用程序的缓冲区复制到内核空间的缓冲区，然后再从内核空间的缓冲区复制到网络设备的缓冲区，最后再从网络设备的缓冲区复制到目标主机的内核空间缓冲区，最后再从目标主机的内核空间缓冲区复制到目标应用程序的缓冲区。这样的数据传输方式需要经过多次数据拷贝和内存复制操作，耗费大量的 CPU 时间和系统资源，降低了数据传输的效率和性能。\n零拷贝技术可以通过使用 DMA（Direct Memory Access）技术和共享内存等技术，将数据从应用程序的缓冲区直接传输到网络设备的缓冲区，从而避免了数据拷贝和内存复制操作。这样就可以大大减少 CPU 的开销和系统资源的占用，提高数据传输的效率和性能。\n在使用零拷贝技术时，需要注意以下几点：\n零拷贝技术需要硬件和操作系统的支持，不是所有的硬件和操作系统都支持零拷贝技术。 零拷贝技术需要应用程序和网络设备之间的协作，需要对数据传输进行特殊处理。 零拷贝技术可能会增加代码的复杂度和难度，需要谨慎使用。 总之，零拷贝技术可以提高数据传输的效率和性能，但需要硬件和操作系统的支持，并且需要谨慎使用。\n页调度/置换算法 页调度（Page Replacement）是操作系统中的一个重要概念，用于管理内存中的虚拟页（Virtual Page），当内存中的页框（Page Frame）不足时，需要将某些页从内存中换出（Swap Out），并将新的页换入（Swap In），以便为新的进程或线程腾出空间。\nFIFO：最先进入内存的页面最先被替换。 Optimal：理论上最佳，替换未来最长时间不会被访问的页面，但实际难以实现。 LRU：替换最近最少使用的页面，需要记录页面使用历史。 LFU：替换最不常使用的页面，基于访问频率。 Clock：循环队列置换，是 LRU 的高效实现，广泛用于操作系统。 NUR：最近未使用，是对 LRU 的一种近似实现。 Random：随机选择一个页面替换。\n如何优化生产者消费者模型 使用适当的数据结构：例如，使用支持并发的阻塞队列可以简化编程，提高效率。\n合理设置缓冲区大小：如果缓冲区过小，可能导致生产者频繁阻塞；若过大，可能浪费内存资源。\n优化线程数量：生产者和消费者的线程数量应根据系统的处理能力进行调整。过多线程可能导致上下文切换开销增加，过少则不能充分利用系统资源。\n使用异步处理：避免生产者和消费者之间的直接等待关系，提高吞吐量。\n采用批处理：批量生产和消费数据可以减少线程间同步的次数，提高处理速度。\n考虑优先级：对于有优先级需求的场景，可以设置优先级队列以满足业务需求。\n避免频繁 GC：如果生产者和消费者频繁创建和销毁对象，可能引发频繁的垃圾收集，影响性能。可以通过对象池等方式复用对象。\n评估并优化锁的使用：确保必要且适当的锁定以减少竞争，但也要避免引入不必要的锁。\nDMA 技术（page cache） 是 DMA 的基本实现过程：\n请求 DMA 传输：当设备需要读写内存时，它会发出 DMA 传输的请求。\nDMA 控制器接管总线：一旦 CPU 接到 DMA 请求，并且在完成当前指令后，它会释放总线并将其交给 DMA 控制器。\n执行数据传输：DMA 控制器将数据从内存中读取并发送给设备，或者从设备读取数据并将其写入内存。在此过程中，CPU 无需参与数据的读写操作，可以执行其他任务。\n传输完成：DMA 控制器在传输完成后，会向 CPU 发出中断信号，通知 CPU 数据已经传输完成。\nCPU 重新接管总线：在处理完 DMA 传输完成的中断后，CPU 再次接管总线，恢复正常的指令执行。\n分段和分页 分段 程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。 通过段号和偏移量确定物理地址 不足之处：\n内存碎片的问题（外部内存）。 内存交换的效率低。 分页 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小\n页表是存储在内存里的，内存管理单元 （MMU） 就做将虚拟内存地址转换成物理地址的工作。\n提高内存的利用率，没有外部碎片 但会产生内碎片（一个页可能填充不满）。 而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。\n如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。\nTLB,页表缓存\n如何优化读 优化读操作可以从多个角度进行：\n使用缓存：将常用数据或最近使用的数据存储在内存中，可以大大提高读取速度。\n预读（Prefetching）：如果能预测到未来会读取哪些数据，可以提前将这些数据加载到缓存中。\n数据分区：将数据分布在不同的磁盘上，可以并行地读取数据，提高读取速度。\n索引：对于数据库等系统，使用索引可以快速定位到数据，减少磁盘 I/O 操作。\n数据压缩：压缩数据可以减少读取的数据量，但需要注意解压缩可能带来的额外计算开销。\n批量读取：一次读取大块的数据比多次读取小块的数据更高效。\n合理排列数据：尽可能地使顺序访问的数据在物理硬盘上连续存放（例如，利用文件系统的预留空间功能）。\n虚拟内存 虚拟内存是一种内存管理技术，它使得应用程序认为它们自己拥有连续可用的内存（一个连续完整的地址空间），而实际上，它们的物理内存被切割成了多个块，这些块在物理内存和硬盘之间动态地交换。\n以下是虚拟内存的基本原理和特点：\n地址转换：操作系统通过页表将虚拟地址（程序中使用的地址）映射为物理地址（实际内存硬件的地址）。这样，程序可以在一个连续的地址空间中运行，即使物理内存是离散分布的。\n按需加载和置换：当程序访问某个地址时，如果对应的页面不在物理内存中（发生缺页中断），操作系统会选择一个页面置换出内存，将需要的页面从硬盘载入内存。这样，只有需要用到的页面才被加载，节省了内存资源。\n内存保护：每个程序都在其自己的虚拟地址空间中运行，无法访问其他程序的地址空间，增强了系统的稳定性和安全性。\n内存共享和映射文件：虚拟内存技术使得多个进程可以共享物理内存或映射同一个文件到其虚拟内存，方便了进程间的通信和文件操作。\n虚拟内存大大提高了内存的使用效率，简化了程序的编写，是现代操作系统的重要组成部分。\nkill -9 和 kill -15 的区别？ kill 命令在 Linux 中被用来终止或发送信号给进程。-9 和-15 是具体的信号编号，分别对应 SIGKILL 和 SIGTERM 信号。\nkill -9 (SIGKILL) SIGKILL 信号会强制结束进程，进程无法忽略这个信号。当你发送 SIGKILL 信号后，操作系统会立刻停止进程。由于进程没有机会进行清理（例如关闭打开的文件或网络连接），所以可能会导致数据丢失或其他问题。 kill -15 (SIGTERM) SIGTERM 是默认的 kill 信号。与 SIGKILL 不同，进程能够捕捉到 SIGTERM 信号，并决定如何响应。大多数进程会在接收到 SIGTERM 后进行一些清理工作，然后优雅地结束。如果进程忽略了 SIGTERM 信号或者无法正常结束，则可以使用 SIGKILL 来强制结束。 僵尸进程和孤儿进程 僵尸进程是已终止但父进程未回收其状态信息的进程。解决方法：父进程应调用 wait()获取子进程状态，或者将这些进程的父进程更改为 init。\n孤儿进程是父进程结束后仍在运行的进程。处理方式：被 init 进程自动接管，无需特别处理。\n自旋锁和互斥锁 自旋锁（Spinlock）：\n用于保护短时期的临界区。当无法获取锁时，线程会一直在循环中尝试获取锁（忙等待即\"自旋\"），而不是睡眠。 更适合于锁保护代码执行时间非常短的情况，因为它避免了上下文切换的开销。 互斥锁（Mutex）：\n当无法获得锁时，线程会进入睡眠状态，直到有其他线程释放锁唤醒它。 如果被保护的代码可能需要长时间执行或等待其他资源，使用互斥锁将更有效，因为它能让出 CPU 给其他线程使用。 sed 和 awk 的区别 sed：\n主要用于文件中的文本替换。\n提供了基于行的处理方式，例如删除行、插入行或替换行。 常用于简单的文本转换和操作。 awk： 更强大的文本处理工具，提供了编程语言的特性，如变量、循环和条件判断。\n可以处理多个文件。 主要设计用来处理具有明确定义格式和字段的文本。 history 命令 history: 显示先前执行过的命令列表。 history n: 显示最近的 n 个命令。 !n: 重复执行历史中的第 n 个命令。 !!: 重复执行上一个命令。 !-n: 重复执行倒数第 n 个命令。 !string: 运行以指定字符串开始的最后一个命令。 !?string?: 运行包含指定字符串的最后一个命令。 history -c: 清除历史记录。 history -d offset: 删除历史中的特定条目。 Bash shell 允许通过 HISTCONTROL 和 HISTIGNORE 环境变量来控制history命令的行为：\nHISTCONTROL可以设置为：\nignorespace：以空格开头的命令不会保存到历史记录中。 ignoredups：连续的重复命令只会保存一次。 ignoreboth：同时应用上述两种规则。 HISTIGNORE允许您指定一个模式列表，匹配的命令不会保存到历史记录中。例如，HISTIGNORE='ls💿pwd'会忽略 ls、cd\nfind 命令 find命令用于在 Linux 文件系统中搜索和定位文件的列表，此命令可以根据多种条件如名称、类型、大小等来查找文件。\nfind /dir/ -name filename: 在/dir/目录及其子目录中查找名为 filename 的文件。 find /dir/ -iname filename: 同上，但忽略大小写。 find . -type f: 在当前目录及其子目录中查找所有普通文件。 find . -type d: 在当前目录及其子目录中查找所有目录。 find /dir/ -user username: 查找/dir/目录及其子目录中所有者为 username 的文件。 find /dir/ -mmin n: 查找/dir/目录及其子目录中在 n 分钟前被修改的文件。 find /dir/ -size +10M: 查找/dir/目录及其子目录中大于 10MB 的文件。 你还可以通过-exec 选项与其他命令结合使用，对搜索结果执行操作： 8. find /dir/ -name '*.txt' -exec rm {} \\;: 在/dir/目录及其子目录中查找所有.txt 文件并删除之。\nmmap mmap() 是一种在进程的虚拟地址空间内映射文件或设备的方法，它是 Unix 和 Linux 系统提供的系统调用。mmap() 的全称是“memory map”，即内存映射。\n当你使用 mmap() 映射一个文件时，你实际上创建了一个新的内存区域，并将文件的内容放到这个内存区域中。此时，不需要再使用 read() 或 write() 这类系统调用来操作文件，而是直接通过内存操作就可以对文件进行读写。\nmmap() 函数原型如下：\nvoid *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset); addr：指定映射区的起始地址，通常设置为 NULL，表示由系统自动选择地址。 length：映射区的长度。以字节为单位，不足一内存页按一内存页处理。 prot：期望的内存保护标志，可以为 PROT_NONE、PROT_READ、PROT_WRITE、PROT_EXEC，或者他们的组合。 flags：指定映射对象的类型，必选项是 MAP_SHARED（共享）与 MAP_PRIVATE（私有），还可以与 MAP_FIXED 组合。 fd：要映射的文件描述符。 offset：文件映射的偏移量，通常设置为 0，表示从文件最前方开始对应。 mmap() 返回一个指向映射区域开始处的指针。\nmmap() 映射的内存区域在进程退出时会被自动解除映射，当然，也可以显式地调用 munmap() 来解除映射。\n通常情况下，mmap() 用于处理大文件和实现共享内存。\nmerge 和 rebase 的区别 Merge（合并）：\n保留原始分支的历史，不改变提交顺序。 创建一个新的合并提交，将两个或多个分支的更改合并到一起。 可能会产生较为复杂的提交历史，因为每个分支的提交都会保留。 Rebase（变基）：\n将当前分支的更改移动到另一个分支的基础上，形成一个线性历史。 不会创建新的合并提交，使得提交历史更为简洁。 可能会改写提交历史，因此需要谨慎使用，尤其是在公共分支上。 进程和线程 1、线程启动速度快，轻量级\n2、线程的系统开销小\n3、线程使用有一定难度，需要处理数据一致性问题\n4、同一线程共享的有堆、全局变量、静态变量、指针，引用、文件等，而独自占有栈\n#include #include #include // 全局变量 int globalVar = 10; // 静态变量 static int staticVar = 20; // 在堆上分配内存 int* heapVar = new int(30); void threadFunc(std::ofstream\u0026 outFile) { // 修改全局变量 ++globalVar; // 修改静态变量 ++staticVar; // 修改堆变量 ++(*heapVar); outFile \u003c\u003c \"Thread ID: \" \u003c\u003c std::this_thread::get_id() \u003c\u003c std::endl; outFile \u003c\u003c \"Global variable: \" \u003c\u003c globalVar \u003c\u003c std::endl; outFile \u003c\u003c \"Static variable: \" \u003c\u003c staticVar \u003c\u003c std::endl; outFile \u003c\u003c \"Heap variable: \" \u003c\u003c *heapVar \u003c\u003c std::endl; outFile \u003c\u003c \"---------------------------\" \u003c\u003c std::endl; } int main() { std::ofstream outFile(\"shared.txt\"); if (!outFile) { std::cerr \u003c\u003c \"Error opening file.\" \u003c\u003c std::endl; return -1; } std::thread t1(threadFunc, std::ref(outFile)); std::thread t2(threadFunc, std::ref(outFile)); t1.join(); t2.join(); delete heapVar; // 记得删除堆内存 outFile.close(); return 0; } ",
  "wordCount" : "7735",
  "inLanguage": "en",
  "datePublished": "2023-07-29T11:05:53+08:00",
  "dateModified": "2023-07-29T11:05:53+08:00",
  "author":[{
    "@type": "Person",
    "name": "chx9"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/posts/cs/os/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "chx9",
    "logo": {
      "@type": "ImageObject",
      "url": "img/svin.webp"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    (function () {
        let  arr,reg = new RegExp("(^| )"+"change-themes"+"=([^;]*)(;|$)");
        if(arr = document.cookie.match(reg)) {
        } else {
            if (new Date().getHours() >= 19 || new Date().getHours() < 6) {
                document.body.classList.add('dark');
                localStorage.setItem("pref-theme", 'dark');
            } else {
                document.body.classList.remove('dark');
                localStorage.setItem("pref-theme", 'light');
            }
        }
    })()

    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="" accesskey="h" title="chx9 (Alt + H)">chx9</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="search" title="🔍 search (Alt &#43; /)" accesskey=/>
                <span>🔍 search</span>
                </a>
            </li>
            <li>
                <a href="/" title="🏠 home">
                <span>🏠 home</span>
                </a>
            </li>
            <li>
                <a href="posts" title="📚 articles">
                <span>📚 articles</span>
                </a>
            </li>
            <li>
                <a href="tags" title="🧩 tags">
                <span>🧩 tags</span>
                </a>
            </li>
            <li>
                <a href="about" title="🙋🏻‍♂️ about">
                <span>🙋🏻‍♂️ about</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }
</style>

<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="">🏠 主页</a>&nbsp;»&nbsp;<a href="/posts/">📚Articles</a>&nbsp;»&nbsp;<a href="/posts/cs/">💻 Programming Basics</a></div>
            <h1 class="post-title">
                Operating System
            </h1>
            <div class="post-meta">

<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2023-07-29
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>7735字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>16分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>chx9
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
            </span>
        </span>
    </span>
</span>
<span style="opacity: 0.8;">
                    <span id="post_meta_style_7">
                        &nbsp;&nbsp;
                        <span class="fa fa-eye" ></span>
                        <span>
                            <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
                            &nbsp;&nbsp;
                        </span>
                    </span>
                    <span id="post_meta_style_8">
                        <span class="fa fa-commenting-o"></span>
                        <span>
                            <script src="https://cdn.staticfile.org/twikoo//twikoo.all.min.js"></script>
                            <script>
                                let url = document.documentURI
                                
                                let dnsUrl = ""
                                let urlSplit = url.split(dnsUrl)
                                let finalUrl = urlSplit[1]
                                if (finalUrl[0] !== '/') {
                                    finalUrl = '/'+finalUrl
                                }
                                twikoo.getCommentsCount({
                                    envId:  null , 
                                region:  null , 
                                urls: [ 
                                    
                                    finalUrl,
                                ],
                                    includeReply: false 
                                }).then(function (res) {
                                    let count = res[0].count
                                    const obj = document.getElementById("comment_count");
                                    obj.innerText = count
                                    
                                    
                                    
                                }).catch(function (err) {
                                    
                                    console.error(err);
                                });
                            </script>
                            <span id="comment_count"></span>
                        </span>
                    </span>
                </span>

</div>
        </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b%e5%92%8c%e7%ba%bf%e7%a8%8b%e5%8c%ba%e5%88%ab" aria-label="进程和线程区别">进程和线程区别</a></li>
                <li>
                    <a href="#%e5%8d%8f%e7%a8%8b" aria-label="协程">协程</a></li>
                <li>
                    <a href="#%e5%a4%9a%e4%b8%aa%e7%ba%bf%e7%a8%8b%e6%83%85%e5%86%b5%e4%b8%8b-cpu-%e5%88%a9%e7%94%a8%e7%8e%87%e4%b8%8d%e9%ab%98" aria-label="多个线程情况下 CPU 利用率不高">多个线程情况下 CPU 利用率不高</a></li>
                <li>
                    <a href="#epoll-%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0" aria-label="epoll 的底层实现">epoll 的底层实现</a></li>
                <li>
                    <a href="#%e5%90%8c%e6%ad%a5-io-%e5%92%8c%e5%bc%82%e6%ad%a5-io-%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9" aria-label="同步 io 和异步 io 的优缺点">同步 io 和异步 io 的优缺点</a></li>
                <li>
                    <a href="#%e4%ba%92%e6%96%a5%e9%94%81%e8%af%bb%e5%86%99%e9%94%81%e8%87%aa%e6%97%8b%e9%94%81" aria-label="互斥锁、读写锁、自旋锁">互斥锁、读写锁、自旋锁</a></li>
                <li>
                    <a href="#%e5%8a%a0%e9%94%81%e7%9a%84%e6%96%b9%e5%bc%8f" aria-label="加锁的方式">加锁的方式</a></li>
                <li>
                    <a href="#%e4%bf%a1%e5%8f%b7%e9%87%8f%e8%83%bd%e4%bf%9d%e8%af%81%e7%ba%bf%e7%a8%8b%e5%90%8c%e6%ad%a5%e5%90%97" aria-label="信号量能保证线程同步吗？">信号量能保证线程同步吗？</a></li>
                <li>
                    <a href="#linux-%e4%b8%8b%e9%80%92%e5%bd%92%e5%88%a0%e9%99%a4%e6%9f%90%e4%b8%aa%e7%9b%ae%e5%bd%95%e4%b8%8b%e4%bb%a5-cpp-%e4%b8%ba%e7%bb%93%e5%b0%be%e7%9a%84%e6%96%87%e4%bb%b6" aria-label="linux 下递归删除某个目录下以 cpp 为结尾的文件">linux 下递归删除某个目录下以 cpp 为结尾的文件</a></li>
                <li>
                    <a href="#%e6%ad%bb%e9%94%81%e7%9a%84%e5%9b%9b%e4%b8%aa%e6%9d%a1%e4%bb%b6" aria-label="死锁的四个条件">死锁的四个条件</a></li>
                <li>
                    <a href="#%e5%86%85%e6%a0%b8%e6%80%81%e5%92%8c%e7%94%a8%e6%88%b7%e6%80%81" aria-label="内核态和用户态">内核态和用户态</a></li>
                <li>
                    <a href="#linux-%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4" aria-label="linux 常用命令">linux 常用命令</a></li>
                <li>
                    <a href="#linux-%e4%b8%ad%e6%9f%a5%e8%af%a2%e8%bf%9b%e7%a8%8b%e5%8d%a0%e7%94%a8-cpu-%e7%9a%84%e6%83%85%e5%86%b5" aria-label="linux 中查询进程占用 cpu 的情况">linux 中查询进程占用 cpu 的情况</a></li>
                <li>
                    <a href="#0-%e6%8b%b7%e8%b4%9d" aria-label="0 拷贝">0 拷贝</a></li>
                <li>
                    <a href="#%e9%a1%b5%e8%b0%83%e5%ba%a6%e7%bd%ae%e6%8d%a2%e7%ae%97%e6%b3%95" aria-label="页调度/置换算法">页调度/置换算法</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e4%bc%98%e5%8c%96%e7%94%9f%e4%ba%a7%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85%e6%a8%a1%e5%9e%8b" aria-label="如何优化生产者消费者模型">如何优化生产者消费者模型</a></li>
                <li>
                    <a href="#dma-%e6%8a%80%e6%9c%afpage-cache" aria-label="DMA 技术（page cache）">DMA 技术（page cache）</a></li>
                <li>
                    <a href="#%e5%88%86%e6%ae%b5%e5%92%8c%e5%88%86%e9%a1%b5" aria-label="分段和分页">分段和分页</a><ul>
                        
                <li>
                    <a href="#%e5%88%86%e6%ae%b5" aria-label="分段">分段</a></li>
                <li>
                    <a href="#%e5%88%86%e9%a1%b5" aria-label="分页">分页</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e4%bc%98%e5%8c%96%e8%af%bb" aria-label="如何优化读">如何优化读</a></li>
                <li>
                    <a href="#%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98" aria-label="虚拟内存">虚拟内存</a></li>
                <li>
                    <a href="#kill--9-%e5%92%8c-kill--15-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="kill -9 和 kill -15 的区别？">kill -9 和 kill -15 的区别？</a></li>
                <li>
                    <a href="#%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b%e5%92%8c%e5%ad%a4%e5%84%bf%e8%bf%9b%e7%a8%8b" aria-label="僵尸进程和孤儿进程">僵尸进程和孤儿进程</a></li>
                <li>
                    <a href="#%e8%87%aa%e6%97%8b%e9%94%81%e5%92%8c%e4%ba%92%e6%96%a5%e9%94%81" aria-label="自旋锁和互斥锁">自旋锁和互斥锁</a></li>
                <li>
                    <a href="#sed-%e5%92%8c-awk-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="sed 和 awk 的区别">sed 和 awk 的区别</a></li>
                <li>
                    <a href="#history-%e5%91%bd%e4%bb%a4" aria-label="history 命令">history 命令</a></li>
                <li>
                    <a href="#find-%e5%91%bd%e4%bb%a4" aria-label="find 命令">find 命令</a></li>
                <li>
                    <a href="#mmap" aria-label="mmap">mmap</a></li>
                <li>
                    <a href="#merge-%e5%92%8c-rebase-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="merge 和 rebase 的区别">merge 和 rebase 的区别</a></li>
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b%e5%92%8c%e7%ba%bf%e7%a8%8b" aria-label="进程和线程">进程和线程</a>
                </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        if (elements) {
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                    (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                    return element;
                }
            }) || activeElement

            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                if (element === activeElement){
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
                } else {
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
                }
            })
        }
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        <div class="post-content"><h1 id="进程和线程区别">进程和线程区别<a hidden class="anchor" aria-hidden="true" href="#进程和线程区别">#</a></h1>
<p>1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序</p>
<p>2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。线程启动速度快，轻量级</p>
<p>进程的资源：</p>
<ul>
<li>独立的内存空间（虚拟地址空间）</li>
<li>系统资源，如打开的文件、信号处理器等</li>
</ul>
<p>线程的资源:</p>
<ul>
<li>程序计数器：用于指令读取，函数调用，指令跳转</li>
<li>寄存器：用于保存线程的上下文信息。</li>
<li>栈</li>
</ul>
<h1 id="协程">协程<a hidden class="anchor" aria-hidden="true" href="#协程">#</a></h1>
<p>协程是用户态的轻量级线程，线程内部调度的基本单位，都是运行在用户态，拥有自己的寄存器上下文和栈
c++的协程库: boost coroutine, libco</p>
<ul>
<li>线程由操作系统管理，切换需要操作系统内核，耗费时间和资源，协程切换是程序员自己控制</li>
<li>线程之间通信通过共享内存或者传递消息，而协程之间直接通过函数调用或者共享变量</li>
<li>线程可以通过多个 cpu 实现并行，但是协程只在一个线程中</li>
<li>线程创建、销毁需要操作系统接入，而协程在用户空间内完成</li>
<li>协程适用于 高并的网络编程，异步 io 操作，高并发网络编程，**短时间的计算密集型，**线程：cpu 密集型</li>
</ul>
<h1 id="多个线程情况下-cpu-利用率不高">多个线程情况下 CPU 利用率不高<a hidden class="anchor" aria-hidden="true" href="#多个线程情况下-cpu-利用率不高">#</a></h1>
<p>1、同步和通信不高效(死锁，数据竞争)</p>
<p>2、线程过多：竞争过于激烈； 线程数过少：CPU 核心限制</p>
<p>3、io 密集型</p>
<h1 id="epoll-的底层实现">epoll 的底层实现<a hidden class="anchor" aria-hidden="true" href="#epoll-的底层实现">#</a></h1>
<p>红黑树用来管理所有的文件描述符</p>
<p>内核中的事件表：存储所有就绪的文件描述符</p>
<p>内核中的回调函数：内核调用回调函数处理处理所有就绪的文件描述符
同步模型的优点：</p>
<h1 id="同步-io-和异步-io-的优缺点">同步 io 和异步 io 的优缺点<a hidden class="anchor" aria-hidden="true" href="#同步-io-和异步-io-的优缺点">#</a></h1>
<p>同步 io 优点：</p>
<ul>
<li>编程简单</li>
<li>可靠性高（阻塞）</li>
</ul>
<p>同步模型的缺点：</p>
<ul>
<li>性能低（阻塞）
异步模型的优点：</li>
<li>高性能</li>
<li>编程复杂</li>
</ul>
<p>异步模型的缺点：</p>
<ul>
<li>可靠性低（可能会出现操作未完成就返回结果，需要判断错误）</li>
</ul>
<h1 id="互斥锁读写锁自旋锁">互斥锁、读写锁、自旋锁<a hidden class="anchor" aria-hidden="true" href="#互斥锁读写锁自旋锁">#</a></h1>
<p>互斥锁，最基本的同步机制，保护临界区资源访问</p>
<p>读写锁，允许多个线程同时读共享资源，但是只允许一个锁读取共享资源，读写锁的实现通常是基于互斥锁和条件变量实现的。</p>
<p>自旋锁是一种轻量级同步机制，当自旋锁被占用时，线程不会进入阻塞状态，而是一直循环等待，适用于锁占用短的场景，锁占用长的</p>
<h1 id="加锁的方式">加锁的方式<a hidden class="anchor" aria-hidden="true" href="#加锁的方式">#</a></h1>
<ul>
<li>阻塞锁，一直等待资源</li>
<li>自旋锁，一直循环等待</li>
<li>乐观锁，假设读取共享资源的时候不会修改它，如果被修改了，就重新尝试</li>
</ul>
<h1 id="信号量能保证线程同步吗">信号量能保证线程同步吗？<a hidden class="anchor" aria-hidden="true" href="#信号量能保证线程同步吗">#</a></h1>
<p>信号量可以用来保证线程同步，但最好与锁一起使用来保证线程互斥。信号量是一种计数器，用来保护共享资源。当一个线程想要访问共享资源时，它必须先获取信号量，然后才能访问共享资源。如果信号量的计数器为 0，则线程必须等待，直到有另一个线程释放信号量。这样可以确保多个线程不会同时访问共享资源，从而保证线程同步。</p>
<p>在使用信号量时，需要注意一些问题。首先，<strong>信号量只能保证线程同步，不能保证线程互斥</strong>。如果多个线程都可以获得信号量，则它们可以同时访问共享资源。因此，最好与锁一起使用来保证线程互斥。其次，信号量可能会产生死锁问题。当多个线程互相等待对方释放信号量时，就会发生死锁。因此，在使用信号量时，需要仔细考虑并发情况，以确保线程安全和性能。</p>
<h1 id="linux-下递归删除某个目录下以-cpp-为结尾的文件">linux 下递归删除某个目录下以 cpp 为结尾的文件<a hidden class="anchor" aria-hidden="true" href="#linux-下递归删除某个目录下以-cpp-为结尾的文件">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>find /path/to/directory -type f -name <span style="color:#e6db74">&#34;*.cpp&#34;</span> -delete
</span></span></code></pre></div><p>如果不加 -type f，find 命令会查找目录中的所有类型的文件，包括普通文件、目录、符号链接等，可能会误删一些非文件类型的内容。加上 -type f 可以限定只查找普通文件，避免误删其他类型的内容。</p>
<h1 id="死锁的四个条件">死锁的四个条件<a hidden class="anchor" aria-hidden="true" href="#死锁的四个条件">#</a></h1>
<ol>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p>如果一个系统中存在上述四个条件，就会出现死锁的情况，死锁的解决方法通常需要采用多种方法，如锁机制的优化、资源分配算法的改进等。</p>
<h1 id="内核态和用户态">内核态和用户态<a hidden class="anchor" aria-hidden="true" href="#内核态和用户态">#</a></h1>
<p>内核态（Kernel Mode）和用户态（User Mode） 是操作系统设计中的两种运行级别或模式，用于区分进程对硬件资源的访问权限。</p>
<p>内核态（Kernel Mode）</p>
<ul>
<li>在内核态下，代码有权访问系统的任何资源，不受任何保护和限制。它可以直接执行任意 CPU 指令，可以访问任何物理内存地址，也可以访问和操作所有的硬件设备。</li>
<li>由于其高权限，内核态主要被操作系统内核、设备驱动程序等使用。</li>
<li>错误的操作可能导致整个系统崩溃或者数据丢失。
用户态（User Mode）</li>
<li>在用户态下，代码执行在一个受保护的环境中，只能访问一部分范围的内存，不能直接访问硬件设备，对 CPU 指令集的使用也有所限制。</li>
<li>当一个用户程序需要进行一项系统调用（如读写文件，发送网络数据）时，它会切换到内核态，由内核代为完成，然后再切换回用户态。</li>
<li>这种机制能够保护系统的稳定性和安全性，防止用户程序的错误操作影响整个系统。</li>
</ul>
<h1 id="linux-常用命令">linux 常用命令<a hidden class="anchor" aria-hidden="true" href="#linux-常用命令">#</a></h1>
<p>下面列举一些常用的 Linux 命令：</p>
<ol>
<li>ls：列出目录下的文件和子目录。</li>
<li>cd：切换当前目录。</li>
<li>pwd：显示当前所在目录的路径。</li>
<li>mkdir：创建一个新目录。</li>
<li>rmdir：删除一个空目录。</li>
<li>rm：删除文件或目录。</li>
<li>cp：复制文件或目录。</li>
<li>mv：移动或重命名文件或目录。</li>
<li>cat：查看文件内容。</li>
<li>grep：在文件或输入流中查找匹配的文本。</li>
<li>tail：查看文件的末尾内容。</li>
<li>head：查看文件的开头内容。</li>
<li>find：在指定目录下查找文件。</li>
<li>chmod：修改文件或目录的权限。</li>
<li>chown：修改文件或目录的所有者。</li>
<li>ps：查看当前系统进程。</li>
<li>top：查看当前系统资源占用情况。</li>
<li>tar：打包和解压缩文件。</li>
<li>ssh：远程登录到另一台计算机。</li>
<li>scp：在本地和远程计算机之间复制文件。</li>
<li>df：查看磁盘空间使用情况。</li>
<li>free：查看系统内存使用情况。</li>
<li>uname：查看系统信息。</li>
<li>ifconfig：查看网络接口信息。</li>
<li>ping：测试网络连接。</li>
<li>traceroute：查看网络路由情况。</li>
<li>netstat：显示网络连接、路由表和网络接口等信息。</li>
<li>iptables：管理系统防火墙规则。</li>
<li>systemctl：管理系统服务。</li>
<li>ps aux：显示所有进程的详细信息。</li>
<li>kill：终止指定进程。</li>
<li>nohup：让进程在后台运行。</li>
<li>screen：在一个终端窗口中打开多个终端会话。</li>
<li>wget：下载文件。</li>
<li>curl：向服务器发送请求并显示响应。</li>
<li>tar：压缩和解压缩文件。</li>
<li>gzip：压缩和解压缩文件。</li>
<li>zip：压缩和解压缩文件。</li>
<li>ssh-keygen：生成 SSH 密钥对。</li>
</ol>
<h1 id="linux-中查询进程占用-cpu-的情况">linux 中查询进程占用 cpu 的情况<a hidden class="anchor" aria-hidden="true" href="#linux-中查询进程占用-cpu-的情况">#</a></h1>
<p>在 Linux 系统中，可以使用 top 命令来查看系统中占用 CPU 最多的进程，具体操作如下：</p>
<p>打开终端并输入 top 命令。
top 命令会实时显示系统资源使用情况，包括 CPU、内存、进程等。在进程列表中，可以看到各个进程的 CPU 使用情况以及其他相关信息。
进程列表默认按照 CPU 使用率排序，可以通过按下“P”键，然后再按下“Enter”键，将进程列表按照 CPU 使用率从高到低排序。</p>
<p>打开终端并输入 ps aux 命令。
ps 命令会列出当前系统中所有的进程，包括进程的 PID、CPU 占用率、内存使用情况等。
若要按照 CPU 使用率排序，可以使用 ps aux &ndash;sort=-%cpu 命令。</p>
<h1 id="0-拷贝">0 拷贝<a hidden class="anchor" aria-hidden="true" href="#0-拷贝">#</a></h1>
<p><a href="https://www.cnblogs.com/xiaolincoding/p/13719610.html">小林 coding</a></p>
<p>普通拷贝
<img loading="lazy" src="normal_copy.png" alt="normal_copy"  />

内存映射 mmap
<img loading="lazy" src="mmap.png" alt="mmap"  />

sendfile
<img loading="lazy" src="send_file.png" alt="sendfile"  />
</p>
<p>零拷贝（Zero Copy）是一种提高数据传输效率和性能的技术，其基本思想是在数据传输过程中减少数据拷贝和内存复制操作，从而减少 CPU 的开销和系统资源的占用，提高数据传输的效率和性能。</p>
<p>在传统的数据传输方式中，数据通常需要从应用程序的缓冲区复制到内核空间的缓冲区，然后再从内核空间的缓冲区复制到网络设备的缓冲区，最后再从网络设备的缓冲区复制到目标主机的内核空间缓冲区，最后再从目标主机的内核空间缓冲区复制到目标应用程序的缓冲区。这样的数据传输方式需要经过多次数据拷贝和内存复制操作，耗费大量的 CPU 时间和系统资源，降低了数据传输的效率和性能。</p>
<p>零拷贝技术可以通过使用 DMA（Direct Memory Access）技术和共享内存等技术，将数据从应用程序的缓冲区直接传输到网络设备的缓冲区，从而避免了数据拷贝和内存复制操作。这样就可以大大减少 CPU 的开销和系统资源的占用，提高数据传输的效率和性能。</p>
<p>在使用零拷贝技术时，需要注意以下几点：</p>
<ol>
<li>零拷贝技术需要硬件和操作系统的支持，不是所有的硬件和操作系统都支持零拷贝技术。</li>
<li>零拷贝技术需要应用程序和网络设备之间的协作，需要对数据传输进行特殊处理。</li>
<li>零拷贝技术可能会增加代码的复杂度和难度，需要谨慎使用。</li>
</ol>
<p>总之，零拷贝技术可以提高数据传输的效率和性能，但需要硬件和操作系统的支持，并且需要谨慎使用。</p>
<h1 id="页调度置换算法">页调度/置换算法<a hidden class="anchor" aria-hidden="true" href="#页调度置换算法">#</a></h1>
<p>页调度（Page Replacement）是操作系统中的一个重要概念，用于管理内存中的虚拟页（Virtual Page），当内存中的页框（Page Frame）不足时，需要将某些页从内存中换出（Swap Out），并将新的页换入（Swap In），以便为新的进程或线程腾出空间。</p>
<p>FIFO：最先进入内存的页面最先被替换。
Optimal：理论上最佳，替换未来最长时间不会被访问的页面，但实际难以实现。
LRU：替换最近最少使用的页面，需要记录页面使用历史。
LFU：替换最不常使用的页面，基于访问频率。
Clock：循环队列置换，是 LRU 的高效实现，广泛用于操作系统。
NUR：最近未使用，是对 LRU 的一种近似实现。
Random：随机选择一个页面替换。</p>
<h1 id="如何优化生产者消费者模型">如何优化生产者消费者模型<a hidden class="anchor" aria-hidden="true" href="#如何优化生产者消费者模型">#</a></h1>
<ul>
<li>
<p>使用适当的数据结构：例如，使用支持并发的阻塞队列可以简化编程，提高效率。</p>
</li>
<li>
<p>合理设置缓冲区大小：如果缓冲区过小，可能导致生产者频繁阻塞；若过大，可能浪费内存资源。</p>
</li>
<li>
<p>优化线程数量：生产者和消费者的线程数量应根据系统的处理能力进行调整。过多线程可能导致上下文切换开销增加，过少则不能充分利用系统资源。</p>
</li>
<li>
<p>使用异步处理：避免生产者和消费者之间的直接等待关系，提高吞吐量。</p>
</li>
<li>
<p>采用批处理：批量生产和消费数据可以减少线程间同步的次数，提高处理速度。</p>
</li>
<li>
<p>考虑优先级：对于有优先级需求的场景，可以设置优先级队列以满足业务需求。</p>
</li>
<li>
<p>避免频繁 GC：如果生产者和消费者频繁创建和销毁对象，可能引发频繁的垃圾收集，影响性能。可以通过对象池等方式复用对象。</p>
</li>
<li>
<p>评估并优化锁的使用：确保必要且适当的锁定以减少竞争，但也要避免引入不必要的锁。</p>
</li>
</ul>
<h1 id="dma-技术page-cache">DMA 技术（page cache）<a hidden class="anchor" aria-hidden="true" href="#dma-技术page-cache">#</a></h1>
<p>是 DMA 的基本实现过程：</p>
<ol>
<li>
<p>请求 DMA 传输：当设备需要读写内存时，它会发出 DMA 传输的请求。</p>
</li>
<li>
<p>DMA 控制器接管总线：一旦 CPU 接到 DMA 请求，并且在完成当前指令后，它会释放总线并将其交给 DMA 控制器。</p>
</li>
<li>
<p>执行数据传输：DMA 控制器将数据从内存中读取并发送给设备，或者从设备读取数据并将其写入内存。在此过程中，CPU 无需参与数据的读写操作，可以执行其他任务。</p>
</li>
<li>
<p>传输完成：DMA 控制器在传输完成后，会向 CPU 发出中断信号，通知 CPU 数据已经传输完成。</p>
</li>
<li>
<p>CPU 重新接管总线：在处理完 DMA 传输完成的中断后，CPU 再次接管总线，恢复正常的指令执行。</p>
</li>
</ol>
<h1 id="分段和分页">分段和分页<a hidden class="anchor" aria-hidden="true" href="#分段和分页">#</a></h1>
<h2 id="分段">分段<a hidden class="anchor" aria-hidden="true" href="#分段">#</a></h2>
<p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。
通过段号和偏移量确定物理地址
不足之处：</p>
<ul>
<li>内存碎片的问题（外部内存）。</li>
<li>内存交换的效率低。</li>
</ul>
<h2 id="分页">分页<a hidden class="anchor" aria-hidden="true" href="#分页">#</a></h2>
<p>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</p>
<p>页表是存储在内存里的，<strong>内存管理单元 （MMU）</strong> 就做将虚拟内存地址转换成物理地址的工作。</p>
<ul>
<li>提高内存的利用率，没有外部碎片</li>
<li>但会产生内碎片（一个页可能填充不满）。</li>
</ul>
<p>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p>
<p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。</p>
<p>TLB,页表缓存</p>
<p><img loading="lazy" src="ye_duan.png" alt="分页和分段"  />
</p>
<h1 id="如何优化读">如何优化读<a hidden class="anchor" aria-hidden="true" href="#如何优化读">#</a></h1>
<p>优化读操作可以从多个角度进行：</p>
<ol>
<li>
<p>使用缓存：将常用数据或最近使用的数据存储在内存中，可以大大提高读取速度。</p>
</li>
<li>
<p>预读（Prefetching）：如果能预测到未来会读取哪些数据，可以提前将这些数据加载到缓存中。</p>
</li>
<li>
<p>数据分区：将数据分布在不同的磁盘上，可以并行地读取数据，提高读取速度。</p>
</li>
<li>
<p>索引：对于数据库等系统，使用索引可以快速定位到数据，减少磁盘 I/O 操作。</p>
</li>
<li>
<p>数据压缩：压缩数据可以减少读取的数据量，但需要注意解压缩可能带来的额外计算开销。</p>
</li>
<li>
<p>批量读取：一次读取大块的数据比多次读取小块的数据更高效。</p>
</li>
<li>
<p>合理排列数据：尽可能地使顺序访问的数据在物理硬盘上连续存放（例如，利用文件系统的预留空间功能）。</p>
</li>
</ol>
<h1 id="虚拟内存">虚拟内存<a hidden class="anchor" aria-hidden="true" href="#虚拟内存">#</a></h1>
<p>虚拟内存是一种内存管理技术，它使得应用程序认为它们自己拥有连续可用的内存（一个连续完整的地址空间），而实际上，它们的物理内存被切割成了多个块，这些块在物理内存和硬盘之间动态地交换。</p>
<p>以下是虚拟内存的基本原理和特点：</p>
<p>地址转换：操作系统通过页表将虚拟地址（程序中使用的地址）映射为物理地址（实际内存硬件的地址）。这样，程序可以在一个连续的地址空间中运行，即使物理内存是离散分布的。</p>
<p>按需加载和置换：当程序访问某个地址时，如果对应的页面不在物理内存中（发生缺页中断），操作系统会选择一个页面置换出内存，将需要的页面从硬盘载入内存。这样，只有需要用到的页面才被加载，节省了内存资源。</p>
<p>内存保护：每个程序都在其自己的虚拟地址空间中运行，无法访问其他程序的地址空间，增强了系统的稳定性和安全性。</p>
<p>内存共享和映射文件：虚拟内存技术使得多个进程可以共享物理内存或映射同一个文件到其虚拟内存，方便了进程间的通信和文件操作。</p>
<p>虚拟内存大大提高了内存的使用效率，简化了程序的编写，是现代操作系统的重要组成部分。</p>
<h1 id="kill--9-和-kill--15-的区别">kill -9 和 kill -15 的区别？<a hidden class="anchor" aria-hidden="true" href="#kill--9-和-kill--15-的区别">#</a></h1>
<p>kill 命令在 Linux 中被用来终止或发送信号给进程。-9 和-15 是具体的信号编号，分别对应 SIGKILL 和 SIGTERM 信号。</p>
<ol>
<li>kill -9 (SIGKILL)</li>
</ol>
<ul>
<li>SIGKILL 信号会强制结束进程，进程无法忽略这个信号。当你发送 SIGKILL 信号后，操作系统会立刻停止进程。由于进程没有机会进行清理（例如关闭打开的文件或网络连接），所以可能会导致数据丢失或其他问题。</li>
</ul>
<ol start="2">
<li>kill -15 (SIGTERM)</li>
</ol>
<ul>
<li>SIGTERM 是默认的 kill 信号。与 SIGKILL 不同，进程能够捕捉到 SIGTERM 信号，并决定如何响应。大多数进程会在接收到 SIGTERM 后进行一些清理工作，然后优雅地结束。如果进程忽略了 SIGTERM 信号或者无法正常结束，则可以使用 SIGKILL 来强制结束。</li>
</ul>
<h1 id="僵尸进程和孤儿进程">僵尸进程和孤儿进程<a hidden class="anchor" aria-hidden="true" href="#僵尸进程和孤儿进程">#</a></h1>
<p>僵尸进程是已终止但父进程未回收其状态信息的进程。解决方法：父进程应调用 wait()获取子进程状态，或者将这些进程的父进程更改为 init。</p>
<p>孤儿进程是父进程结束后仍在运行的进程。处理方式：被 init 进程自动接管，无需特别处理。</p>
<h1 id="自旋锁和互斥锁">自旋锁和互斥锁<a hidden class="anchor" aria-hidden="true" href="#自旋锁和互斥锁">#</a></h1>
<p>自旋锁（Spinlock）：</p>
<ul>
<li>用于保护短时期的临界区。当无法获取锁时，线程会一直在循环中尝试获取锁（忙等待即&quot;自旋&quot;），而不是睡眠。</li>
<li>更适合于锁保护代码执行时间非常短的情况，因为它避免了上下文切换的开销。</li>
</ul>
<p>互斥锁（Mutex）：</p>
<ul>
<li>当无法获得锁时，线程会进入睡眠状态，直到有其他线程释放锁唤醒它。</li>
<li>如果被保护的代码可能需要长时间执行或等待其他资源，使用互斥锁将更有效，因为它能让出 CPU 给其他线程使用。</li>
</ul>
<h1 id="sed-和-awk-的区别">sed 和 awk 的区别<a hidden class="anchor" aria-hidden="true" href="#sed-和-awk-的区别">#</a></h1>
<p>sed：</p>
<p>主要用于文件中的文本替换。</p>
<ul>
<li>提供了基于行的处理方式，例如删除行、插入行或替换行。</li>
<li>常用于简单的文本转换和操作。
awk：</li>
</ul>
<p>更强大的文本处理工具，提供了编程语言的特性，如变量、循环和条件判断。</p>
<ul>
<li>可以处理多个文件。</li>
<li>主要设计用来处理具有明确定义格式和字段的文本。</li>
</ul>
<h1 id="history-命令">history 命令<a hidden class="anchor" aria-hidden="true" href="#history-命令">#</a></h1>
<ol>
<li><code>history</code>: 显示先前执行过的命令列表。</li>
<li><code>history n</code>: 显示最近的 n 个命令。</li>
<li><code>!n</code>: 重复执行历史中的第 n 个命令。</li>
<li><code>!!</code>: 重复执行上一个命令。</li>
<li><code>!-n</code>: 重复执行倒数第 n 个命令。</li>
<li><code>!string</code>: 运行以指定字符串开始的最后一个命令。</li>
<li><code>!?string?</code>: 运行包含指定字符串的最后一个命令。</li>
<li><code>history -c</code>: 清除历史记录。</li>
<li><code>history -d offset</code>: 删除历史中的特定条目。</li>
</ol>
<p>Bash shell 允许通过 HISTCONTROL 和 HISTIGNORE 环境变量来控制<code>history</code>命令的行为：</p>
<ul>
<li>
<p><code>HISTCONTROL</code>可以设置为：</p>
<ul>
<li><code>ignorespace</code>：以空格开头的命令不会保存到历史记录中。</li>
<li><code>ignoredups</code>：连续的重复命令只会保存一次。</li>
<li><code>ignoreboth</code>：同时应用上述两种规则。</li>
</ul>
</li>
<li>
<p><code>HISTIGNORE</code>允许您指定一个模式列表，匹配的命令不会保存到历史记录中。例如，<code>HISTIGNORE='ls💿pwd'</code>会忽略 ls、cd</p>
</li>
</ul>
<h1 id="find-命令">find 命令<a hidden class="anchor" aria-hidden="true" href="#find-命令">#</a></h1>
<p><code>find</code>命令用于在 Linux 文件系统中搜索和定位文件的列表，此命令可以根据多种条件如名称、类型、大小等来查找文件。</p>
<ol>
<li><code>find /dir/ -name filename</code>: 在/dir/目录及其子目录中查找名为 filename 的文件。</li>
<li><code>find /dir/ -iname filename</code>: 同上，但忽略大小写。</li>
<li><code>find . -type f</code>: 在当前目录及其子目录中查找所有普通文件。</li>
<li><code>find . -type d</code>: 在当前目录及其子目录中查找所有目录。</li>
<li><code>find /dir/ -user username</code>: 查找/dir/目录及其子目录中所有者为 username 的文件。</li>
<li><code>find /dir/ -mmin n</code>: 查找/dir/目录及其子目录中在 n 分钟前被修改的文件。</li>
<li><code>find /dir/ -size +10M</code>: 查找/dir/目录及其子目录中大于 10MB 的文件。</li>
</ol>
<p>你还可以通过-exec 选项与其他命令结合使用，对搜索结果执行操作： 8. <code>find /dir/ -name '*.txt' -exec rm {} \;</code>: 在/dir/目录及其子目录中查找所有.txt 文件并删除之。</p>
<h1 id="mmap">mmap<a hidden class="anchor" aria-hidden="true" href="#mmap">#</a></h1>
<p><code>mmap()</code> 是一种在进程的虚拟地址空间内映射文件或设备的方法，它是 Unix 和 Linux 系统提供的系统调用。<code>mmap()</code> 的全称是“memory map”，即内存映射。</p>
<p>当你使用 <code>mmap()</code> 映射一个文件时，你实际上创建了一个新的内存区域，并将文件的内容放到这个内存区域中。此时，不需要再使用 <code>read()</code> 或 <code>write()</code> 这类系统调用来操作文件，而是直接通过内存操作就可以对文件进行读写。</p>
<p><code>mmap()</code> 函数原型如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mmap</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, size_t length, <span style="color:#66d9ef">int</span> prot, <span style="color:#66d9ef">int</span> flags,<span style="color:#66d9ef">int</span> fd, off_t offset);
</span></span></code></pre></div><ul>
<li><code>addr</code>：指定映射区的起始地址，通常设置为 NULL，表示由系统自动选择地址。</li>
<li><code>length</code>：映射区的长度。以字节为单位，不足一内存页按一内存页处理。</li>
<li><code>prot</code>：期望的内存保护标志，可以为 <code>PROT_NONE、PROT_READ、PROT_WRITE、PROT_EXEC</code>，或者他们的组合。</li>
<li><code>flags</code>：指定映射对象的类型，必选项是 <code>MAP_SHARED</code>（共享）与 <code>MAP_PRIVATE</code>（私有），还可以与 <code>MAP_FIXED</code> 组合。</li>
<li><code>fd</code>：要映射的文件描述符。</li>
<li><code>offset</code>：文件映射的偏移量，通常设置为 0，表示从文件最前方开始对应。</li>
</ul>
<p><code>mmap()</code> 返回一个指向映射区域开始处的指针。</p>
<p><code>mmap()</code> 映射的内存区域在进程退出时会被自动解除映射，当然，也可以显式地调用 <code>munmap()</code> 来解除映射。</p>
<p>通常情况下，<code>mmap()</code> 用于处理大文件和实现共享内存。</p>
<h1 id="merge-和-rebase-的区别">merge 和 rebase 的区别<a hidden class="anchor" aria-hidden="true" href="#merge-和-rebase-的区别">#</a></h1>
<p>Merge（合并）：</p>
<ol>
<li>保留原始分支的历史，不改变提交顺序。</li>
<li>创建一个新的合并提交，将两个或多个分支的更改合并到一起。</li>
<li>可能会产生较为复杂的提交历史，因为每个分支的提交都会保留。</li>
</ol>
<p>Rebase（变基）：</p>
<ol>
<li>将当前分支的更改移动到另一个分支的基础上，形成一个线性历史。</li>
<li>不会创建新的合并提交，使得提交历史更为简洁。</li>
<li>可能会改写提交历史，因此需要谨慎使用，尤其是在公共分支上。</li>
</ol>
<h1 id="进程和线程">进程和线程<a hidden class="anchor" aria-hidden="true" href="#进程和线程">#</a></h1>
<p>1、线程启动速度快，轻量级</p>
<p>2、线程的系统开销小</p>
<p>3、线程使用有一定难度，需要处理数据一致性问题</p>
<p>4、同一线程共享的有堆、全局变量、静态变量、指针，引用、文件等，而独自占有栈</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fstream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 全局变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> globalVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 静态变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> staticVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 在堆上分配内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> heapVar <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">30</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">threadFunc</span>(std<span style="color:#f92672">::</span>ofstream<span style="color:#f92672">&amp;</span> outFile) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 修改全局变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">++</span>globalVar;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 修改静态变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">++</span>staticVar;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 修改堆变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">++</span>(<span style="color:#f92672">*</span>heapVar);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    outFile <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Thread ID: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    outFile <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Global variable: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> globalVar <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    outFile <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Static variable: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> staticVar <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    outFile <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Heap variable: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>heapVar <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    outFile <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;---------------------------&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ofstream outFile(<span style="color:#e6db74">&#34;shared.txt&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>outFile) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cerr <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Error opening file.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t1(threadFunc, std<span style="color:#f92672">::</span>ref(outFile));
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t2(threadFunc, std<span style="color:#f92672">::</span>ref(outFile));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    t1.join();
</span></span><span style="display:flex;"><span>    t2.join();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">delete</span> heapVar; <span style="color:#75715e">// 记得删除堆内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    outFile.close();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>

        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="/posts/cs/mysql/">
    <span class="title">« 上一页</span>
    <br>
    <span>Mysql</span>
  </a>
  <a class="next" href="/posts/cs/leetcode/">
    <span class="title">下一页 »</span>
    <br>
    <span>Leetcode</span>
  </a>
</nav>

        </footer>
    </div>

<style>
    .comments_details summary::marker {
        font-size: 20px;
        content: '👉展开评论';
        color: var(--content);
    }
    .comments_details[open] summary::marker{
        font-size: 20px;
        content: '👇关闭评论';
        color: var(--content);
    }
</style>


<div>
    <details class="comments_details">
        <summary style="cursor: pointer; margin: 50px 0 20px 0;width: 130px;">
            <span style="font-size: 20px;color: var(--content);">...</span>
        </summary>
        <div id="tcomment"></div>
    </details>
    <script src="https://cdn.staticfile.org/twikoo//twikoo.all.min.js">
    </script>
    <script>
        twikoo.init({
            envId:  null ,
        el: "#tcomment",
            lang: 'zh-CN',
            region:  null ,
        path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
        })
    </script>
</div>
</article>
</main>

<footer class="footer">
    <span>
        Copyright
        &copy;
        -2023
        <a href="" style="color:#939393;">chx9</a>
        All Rights Reserved
    </span>
    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;"></a>&nbsp;
    <span>
        <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null"
           style="display:inline-block;text-decoration:none;height:20px;color:#939393;">
            <img src="" style="float:left;margin: 0px 5px 0px 0px;"/>
            
        </a>
    </span>
    <span id="busuanzi_container">
        <span class="fa fa-user"></span> <span id="busuanzi_value_site_uv"></span>
        <span class="fa fa-eye"></span> <span id="busuanzi_value_site_pv"></span>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
</script>
<script>
    let mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        (function() {
            document.cookie = "change-themes" + "="+ escape ("false");
        })()

        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    });
</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() 
                let textData = window.getSelection().toString() 
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
                
                
                
                
                
                
                
                
                
                
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;
        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '📄复制';

        function copyingDone() {
            copybutton.innerText = '👌🏻已复制!';
            setTimeout(() => {
                copybutton.innerText = '📄复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent 
                
                
                
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {}
            selection.removeRange(range);
        });

        let language = codeblock.className.replaceAll("language-", "")
        let macTool = document.createElement("div")
        let macTool1 = document.createElement("div")
        let macTool2 = document.createElement("div")
        let macTool3 = document.createElement("div")
        let languageType = document.createElement("div")
        languageType.innerText = language
        
        
        
        
        languageType.setAttribute('class', 'language-type')
        macTool.appendChild(macTool1)
        macTool.appendChild(macTool2)
        macTool.appendChild(macTool3)
        macTool.appendChild(languageType)

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
            container.appendChild(macTool)
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        }
    });
</script>
</body>

</html>
