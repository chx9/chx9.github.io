<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>network | chx9</title>
<meta name="keywords" content="">
<meta name="description" content="三次握手过程 四次挥手过程 为什么 TCP 要三次握手？ 最主要原因就是防止「历史连接」初始化了连接。 三次握手才可以同步双方的初始序列号 为什么 TCP 要四次挥手 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可">
<meta name="author" content="chx9">
<link rel="canonical" href="https://chx9.github.io/posts/cs/network/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://chx9.github.io/img/svin.webp">
<link rel="icon" type="image/png" sizes="16x16" href="https://chx9.github.io/img/svin.webp">
<link rel="icon" type="image/png" sizes="32x32" href="https://chx9.github.io/img/svin.webp">
<link rel="apple-touch-icon" href="https://chx9.github.io/img/svin.webp">
<link rel="mask-icon" href="https://chx9.github.io/img/svin.webp">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script defer src="https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="network" />
<meta property="og:description" content="三次握手过程 四次挥手过程 为什么 TCP 要三次握手？ 最主要原因就是防止「历史连接」初始化了连接。 三次握手才可以同步双方的初始序列号 为什么 TCP 要四次挥手 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chx9.github.io/posts/cs/network/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-29T11:04:35+08:00" />
<meta property="article:modified_time" content="2023-07-29T11:04:35+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="network"/>
<meta name="twitter:description" content="三次握手过程 四次挥手过程 为什么 TCP 要三次握手？ 最主要原因就是防止「历史连接」初始化了连接。 三次握手才可以同步双方的初始序列号 为什么 TCP 要四次挥手 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [

        {
          "@type": "ListItem",
          "position":  1 ,
          "name": "📚Articles",
          "item": "https://chx9.github.io/posts/"
        },

        {
          "@type": "ListItem",
          "position":  2 ,
          "name": "💻 Programming",
          "item": "https://chx9.github.io/posts/cs/"
        }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "network",
      "item": "https://chx9.github.io/posts/cs/network/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "network",
  "name": "network",
  "description": "三次握手过程 四次挥手过程 为什么 TCP 要三次握手？ 最主要原因就是防止「历史连接」初始化了连接。 三次握手才可以同步双方的初始序列号 为什么 TCP 要四次挥手 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可",
  "keywords": [
    ""
  ],
  "articleBody": "三次握手过程 四次挥手过程 为什么 TCP 要三次握手？ 最主要原因就是防止「历史连接」初始化了连接。 三次握手才可以同步双方的初始序列号 为什么 TCP 要四次挥手 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。 TCP 三次握手失败会发生什么 第一次握手失败 客户端重传 SYN 包，直到连接成功或者超时（每次等待两倍时间） 如果服务器无法响应，那么会发送 RST 包，表示拒绝连接 第二次握手失败 客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是客户端就会触发超时重传机制，重传 SYN 报文。 服务端这边会触发超时重传机制，重传 SYN-ACK 报文。 第三次握手失败 因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。 注意，ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文\n列举常用的 HTTP 状态码 HTTP 状态码是指在 HTTP 协议中，服务器向客户端返回的响应状态码。HTTP 状态码由三位数字组成，第一位数字表示响应类型，后两位数字没有具体分类作用。常见的 HTTP 状态码如下：\n1xx：信息响应类，表示服务器已接收到客户端的请求，需要进一步处理。 2xx：成功响应类，表示服务器已成功地接收到客户端的请求并返回响应结果。 3xx：重定向响应类，表示客户端需要进一步操作才能完成请求，如重定向到其他 URL。 4xx：客户端错误响应类，表示客户端请求存在错误或无法被服务器处理。 5xx：服务器错误响应类，表示服务器在处理请求时出现了错误或异常。 以下是常见的 HTTP 状态码及其含义：\n200 OK：表示请求被成功处理，并返回响应结果。 301 Moved Permanently：表示请求的资源已经被永久移动到新的位置，客户端需要使用新的 URL。 302 Found：表示请求的资源已经被暂时移动到新的位置，客户端需要使用新的 URL，但是之后可能会恢复原来的位置。 304 Not Modified：表示客户端发送了一个条件请求，并且服务器认为客户端请求的资源没有被修改，因此不需要返回资源的实体内容，只需要返回响应头信息即可。 400 Bad Request ：请求报文中存在语法错误。 403 Forbidden ：请求被拒绝。 404 Not Found：表示请求的资源不存在或无法被找到。 500 Internal Server Error：表示服务器在处理请求时出现了未知的错误或异常。 除了上述常见的 HTTP 状态码，HTTP 协议中还有很多其他状态码，每个状态码都有其特定的含义和用途。在编写 Web 应用程序时，了解 HTTP 状态码的含义和使用方法，可以帮助我们更好地处理 HTTP 请求，提高程序的可靠性和稳定性。\nGET 和 POST 请求 get是获取数据，post是修改数\nHTTP 和 HTTPS HTTP（Hypertext Transfer Protocol）和 HTTPS（Hypertext Transfer Protocol Secure）都是用于在 Web 上进行数据传输的协议，它们的主要区别在于安全性：\n安全性：HTTP 是明文传输协议，数据在传输过程中没有加密，容易被窃听和篡改；HTTPS 利用 SSL/TLS 协议进行数据加密和身份认证，可以保证数据传输的安全性。\n端口号：HTTP 使用的端口号为 80，而 HTTPS 使用的端口号为 443。\n证书：HTTPS 需要使用数字证书对网站进行身份验证，证书由受信任的第三方机构颁发，可以保证网站的真实性和安全性；而 HTTP 没有身份验证机制，无法保证网站的真实性和安全性。\n性能：HTTPS 比 HTTP 的性能要差一些，因为 HTTPS 需要进行加密和解密操作，会增加服务器和客户端的处理负担，导致响应速度变慢。\nhttp 加密过程 HTTPS（Hypertext Transfer Protocol Secure）是一个用于安全传输数据的协议，它使用 SSL（Secure Sockets Layer）或 TLS（Transport Layer Security）协议来加密 Web 通信。以下是 HTTPS 的加密过程：\n客户端发起 HTTPS 请求，请求连接到服务器。\n服务器向客户端发送一个证书，证书中包含了服务器的公钥、证书的有效期、证书颁发机构等信息。\n客户端收到证书后，会验证证书的有效性，包括证书是否过期、证书颁发机构是否可信等。如果证书有效，客户端会生成一个随机数，用于后续的加密通信。\n客户端使用服务器的公钥加密随机数，并将加密后的随机数发送给服务器。\n服务器使用自己的私钥解密客户端发来的随机数，并使用该随机数作为对称加密算法的密钥，用于后续的数据加密。\n服务器使用对称加密算法对数据进行加密，并将加密后的数据发送给客户端。\n客户端使用之前生成的随机数作为对称加密算法的密钥，解密服务器发来的数据，从而得到原始数据。\n以上就是 HTTPS 的加密过程，通过使用 SSL 或 TLS 协议，可以确保数据在传输过程中的机密性、完整性和真实性。\n输入网址到出现网页的全过程 输入网址到浏览器中，到收到网页的整个过程大致可以分为以下步骤：\nDNS 解析：浏览器首先会解析输入的网址中的域名，将其转换为对应的 IP 地址。浏览器会先查找本地 DNS 缓存，如果没有找到匹配的 IP 地址，则会向 DNS 服务器发送请求，获取对应域名的 IP 地址。\n建立 TCP 连接：浏览器向服务器发送 TCP 连接请求，建立 TCP 连接。在这个过程中，浏览器和服务器会通过三次握手协议建立连接。\n发送 HTTP 请求：浏览器向服务器发送 HTTP 请求，请求获取特定资源，比如 HTML、CSS、JavaScript、图片等。\n服务器响应：服务器接收到浏览器的 HTTP 请求后，会返回相应的资源内容以及 HTTP 状态码。\n浏览器渲染：当浏览器接收到服务器返回的资源内容后，会根据 HTML、CSS 和 JavaScript 等文件进行解析，生成 DOM 和 CSSOM 树，并将其合并成渲染树。然后浏览器会根据渲染树进行布局和绘制，最终将网页内容显示在用户界面上。\n在这个过程中，涉及到的协议主要有：\nDNS 协议：用于域名解析，将域名转换为对应的 IP 地址。\nTCP 协议：用于在浏览器和服务器之间建立可靠的连接，确保数据的可靠传输。\nHTTP 协议：用于在浏览器和服务器之间传输资源内容，包括 HTML、CSS、JavaScript、图片等。\nHTTPS 协议：用于在 HTTP 协议的基础上添加 SSL/TLS 协议进行加密通信，提高数据传输的安全性。\nTCP 拥塞控制 b 站视频\n小林 coding\n拥塞控制是一种网络流量控制机制，它通过限制数据流的速度来防止网络拥塞和保持网络的稳定性。拥塞控制的几个常见机制包括：\n慢启动：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。相当于 2 的指数倍增长 。\n拥塞避免：每当收到一个 ACK 时，cwnd 增加 1/cwnd，变成了线性增长。\n快速重传：当发送方发现某个数据包没有收到确认时，它会重传该数据包。然而，如果发送方连续发送了多个数据包而没有收到确认，它会认为网络出现了拥塞，并立即减慢发送速率。幸运的是，由于 TCP 采用的是累计确认机制，即当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余 ACK（duplicate ACK）。\n如图所示，报文段1成功接收并被确认ACK 2，接收端的期待序号为2，当报文段2丢失，报文段3失序到来，与接收端的期望不匹配，接收端重复发送冗余ACK 2。 这样，如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK（其实是收到4个同样的ACK，第一个是正常的，后三个才是冗余的），发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出，大大提高了效率。这便是快速重传机制。 4. 快速恢复：当发送方减慢发送速率时，接收方会通知发送方可以增加发送速率。这种机制称为快速恢复，它可以帮助发送方更快地恢复正常的发送速率，而不是像慢启动一样重新开始。\n正如前面所说，进入快速恢复之前，cwnd 和 ssthresh 已被更新了： cwnd = cwnd/2 ，也就是设置为原来的一半; ssthresh = cwnd; 然后，进入快速恢复算法如下： 拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）； 重传丢失的数据包； 如果再收到重复的 ACK，那么 cwnd 增加 1； 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态； 流量控制和拥塞控制分别解决了什么问题 流量控制是防止接收端被发送端的数据包淹没，确保接收端处理得过来。\n拥塞控制是避免网络中的数据包太多，导致网络资源如路由器、链路等过载\nhttp 长连接和短连接区别 长连接（Long Connection）\n长连接在数据的传输结束后，仍然保持连接状态，可重复使用，直到客户端或服务器主动关闭。\n场景：实时应用（如在线聊天、即时通讯）、数据库连接、HTTP/2 中的服务。 短连接（Short Connection）\n短连接发送请求后，得到服务器响应就立刻断开。\n场景：HTTP/1.0 协议、邮件发送/接收、FTP 文件传输。\n哪些用 UDP 哪些用 TCP 应用层协议可以使用 TCP 或 UDP 进行数据传输，具体使用哪种传输协议，需要根据协议的特性和应用场景进行选择。下面是一些常见的应用层协议及其使用的传输协议：\n使用 TCP 传输的应用层协议：\nHTTP 协议：用于 Web 应用程序的数据传输。\nFTP 协议：用于文件传输，支持文件上传和下载等操作。\nSMTP 协议：用于电子邮件的传输。\nSSH 协议：用于安全远程登录和文件传输。\nTelnet 协议：用于远程登录主机进行命令行操作。\n使用 UDP 传输的应用层协议：\nDNS 协议：用于域名解析，将域名转换为 IP 地址。\nDHCP 协议：用于动态 IP 地址分配，自动分配和管理 IP 地址。\nTFTP 协议：用于简单文件传输，支持无连接传输方式。\nSNMP 协议：用于网络管理和监控，实现对网络设备的远程管理。\nRTP 协议：用于音视频数据的传输，支持实时传输和流媒体播放。\n需要注意的是，有些应用层协议同时支持 TCP 和 UDP 传输，如 DNS 协议和 FTP 协议等，可以根据实际情况进行选择。\nhttps ssl 连接的过程 HTTPS 加密过程简略如下：\n客户端发送 HTTPS 请求，请求头中的https字段设置为on。\n服务器返回数字证书，包含服务器的公钥、证书颁发机构的信息、证书有效期等。\n客户端验证证书合法性，确认无误后生成随机的会话密钥，并使用服务器的公钥将其加密后发送给服务器。\n服务器使用自己的私钥解密会话密钥，得到原始的会话密钥。\n双方使用会话密钥进行对称加密，保证通信过程中的数据安全性，并进行数字签名和身份认证，确保通信的可信性和完整性。\nhttp1.0 和 http1.1 和 http2.0 的差别，分别做了哪几点优化 HTTP 1.0 是一种无状态，无连接的应用层协议。浏览器每次请求都需要与服务器建立一个TCP 连接，服务器处理完成以后立即断开 TCP 连接(无连接),服务器不跟踪也每个客户单，也不记录过去的请求(无状态) 。\nHTTP 1.1 支持长连接和请求的流水线处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了网络延迟 。\nHTTP 2.0 是基于二进制流的，可以分解为独立的帧，交错发送，从而提高了网络传输效率。\nHTTP/3 是最新的版本，它使用了 QUIC 协议来提高网络传输效率。\nHTTP 是一种应用层协议，常用于 Web 应用中，目前主要有 HTTP/1.0、HTTP/1.1 和 HTTP/2.0 三个版本。它们之间的主要差别及优化如下：\nHTTP/1.0 和 HTTP/1.1 的主要差别 HTTP 1.0\n单一请求响应模型，每个请求/响应都会断开连接。 HTTP 1.1\n持久连接：默认情况下，所有的连接都被认为是持久的，除非有明确的关闭。\n管道化技术：在同一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了网络延迟。(复用 tcp 连接)\n增加更多的缓存控制策略。\nHTTP 2.0\n多路复用：单一 TCP 连接中可并行交换多个 HTTP 请求/响应。\n首部压缩：对头信息进行压缩，减少数据传输量。\n服务器推送：允许服务器未经客户端明确请求就发送数据到客户端，提高性能。\nHTTP 3.0\nQUIC 协议来提高网络传输效率。\nhttp 请求和报文有哪些字段 请求 请求行：Request Line 请求头：Request Headers 请求体：Request Body 相应 状态行：Status Line 响应头：Response Headers 响应体：Response Body tcp 粘包现象 为什么会有粘包现象 TCP粘包问题是指发送方发送的若干个包数据到达接收方时，被接收方读取为一个数据包。\nTCP 粘包是因为 TCP 基于字节流，不保证消息边界\n因为TCP默认会使用Nagle算法，此算法会导致粘包问题。 只有上一个分组得到确认，才会发送下一个分组； 收集多个小分组，在一个确认到来时一起发送。 TCP连接复用：在高并发环境下，同一个TCP连接可能会被多个请求复用，从而可能导致不同请求的数据包混杂在一起。 数据包过大：如果发送的数据包大于TCP的最大报文段长度（MSS - Maximum Segment Size），就需要对数据包进行分片。这个过程可能造成接收方处理来自同一数据包的分片时出现粘包 接收方不及时接收缓冲区的包：如果接收方不能及时处理其接收缓冲区的数据，新到达的数据包可能会与已存在的数据包混合，形成一个大的数据块，从而产生粘包。 解决 TCP 粘包现象的方法主要有以下几种： 增加消息边界：在消息头部添加消息长度字段，接收方根据消息长度进行数据的切割。\n使用固定长度的消息：发送方将消息按照固定长度进行分割，接收方根据固定长度进行数据的切割。\n使用特殊字符作为消息分隔符：发送方在消息尾部添加特殊字符作为消息分隔符，接收方根据特殊字符进行数据的切割。\n使用应用层协议：在应用层协议中规定消息的格式和边界，从而避免粘包现象的发生。\nNagle算法问题导致的，需要结合应用场景适当关闭该算法\nPOST 和 GET 请求 get是获取数据，post是修改数据\nget把请求的数据放在url上， 以?分割URL和传输数据，参数之间以\u0026相连，所以get不太安全。而post把数据放在HTTP的包体内（request body 相对安全）\nget提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。\nGET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。\nGET请求会被浏览器主动缓存，而POST不会，除非手动设置。\n本质区别：GET是幂等的，而POST不是幂等的\n这里的幂等性：幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。\n正因为它们有这样的区别，所以不应该且不能用get请求做数据的增删改这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）\ntcp 如何保证可靠 TCP（Transmission Control Protocol）是一种面向连接的、可靠的传输协议，它通过以下机制来保证数据传输的可靠性：\n序列号与确认应答机制：每个 TCP 报文段都有一个唯一的序列号和确认应答号，用于保证数据的顺序性和完整性。发送端将数据分成若干个报文段发送，每个报文段都有一个序列号，接收端收到报文段后需向发送端发送确认应答，确认应答号为接收到的数据的下一个期望的序列号。如果发送端接收到确认应答，就认为该报文段已经成功传输，可以将该报文段从发送缓冲区中删除。\n超时重传机制：发送端在发送数据时会启动一个定时器，如果在指定时间内没有收到接收端的确认应答，发送端会判断该报文段丢失了，需要重新发送。接收端收到重复的报文段时，会丢弃该报文段，同时向发送端发送确认应答。\n滑动窗口机制：TCP 使用滑动窗口机制来实现流量控制和拥塞控制。发送端和接收端都有一个窗口大小，用于限制发送和接收数据的速率。发送端发送数据时，需要等待接收端发送的确认应答，确认应答中包含接收端当前窗口的大小，发送端根据窗口大小来调整发送数据的速率。\n拥塞控制\n校验和：校验和（checksum）是一种用于检测数据传输过程中是否发生错误的技术。在数据传输过程中，可能会出现各种各样的错误，比如说数据损坏、数据重复、数据丢失等，这些错误都可能导致数据传输失败或者数据被篡改。校验和技术可以通过计算数据的校验和值来检测这些错误，从而保证数据传输的可靠性。\n通过以上机制，TCP 可以保证数据传输的可靠性，并且在网络出现拥塞时可以进行拥塞控制，避免网络拥塞导致数据丢失或传输延迟增加。\n滑动窗口 小林 coding\nping 的过程 主要是 icmp Ping 是一种常用的网络诊断工具，用于测试主机之间的连通性。当我们使用 Ping 命令时，Ping 程序会执行以下步骤：\n发送 ICMP Echo Request 消息：Ping 程序向目标主机发送一个 ICMP Echo Request 消息，该消息包含一个随机的标识符和序列号。\n接收 ICMP Echo Reply 消息：目标主机收到 ICMP Echo Request 消息后，会向发送方返回一个 ICMP Echo Reply 消息，该消息包含与 Echo Request 消息相同的标识符和序列号。\n计算往返时间（RTT）：Ping 程序在接收到 Echo Reply 消息后，会计算从发送 Echo Request 消息到接收 Echo Reply 消息所需的时间，即往返时间（RTT）。\n显示结果：Ping 程序将计算得到的 RTT 值和其他一些统计信息显示在屏幕上。如果目标主机无法到达，Ping 程序会返回一个错误消息。\n需要注意的是，Ping 命令使用的是 ICMP 协议，而不是 TCP 或 UDP 协议。因此，Ping 命令可以用于测试主机之间的连通性，但不能用于测试 TCP 或 UDP 服务的可用性。此外，由于 ICMP 消息可以被防火墙和路由器过滤，因此在某些情况下，Ping 命令可能无法正常工作。\nmac 寻址和 ip 寻址的差异 mac 寻址在数据链路层，ip 寻址在网络层\n数据链路层的作用 1、封装成帧 2、流量控制 3、差错控制 4、mac 寻址 5、透明传输\n网络层的作用 管理数据包的传输和路由选择，将数据包从源节点传输到目的节点。 实现IP（Internet Protocol）协议，负责数据包的分组、传输和路由选择。\n提供差错控制和流量控制功能，确保数据包传输的可靠性和效率。\n实现路由选择算法，根据网络拓扑结构和路由策略选择最佳的路径将数据包传输到目的节点。\n实现地址转换（NAT，Network Address Translation）等功能，将内部私有地址转换为公网可用的地址，以实现网络连接与安全性的需求。\n子网掩码 子网掩码（subnet mask）是用于划分网络地址和主机地址的一个 32 位数值，用于告诉网络设备哪些位是网络地址，哪些位是主机地址。子网掩码通常与 IP 地址配合使用，用于指示网络中哪些位是网络地址，哪些位是主机地址。\n子网掩码的作用是将一个 IP 地址分成两部分：网络地址和主机地址。网络地址用于标识网络，而主机地址用于标识特定的主机。\n子网掩码的格式通常是四个 8 位二进制数，例如 255.255.255.0。这个子网掩码表示前 24 位是网络地址，后 8 位是主机地址。这意味着，对于该子网掩码的网络，可以有 256 个主机地址（2 的 8 次方），因为最后 8 位可以有 256 种不同的组合。\n在计算机网络中，子网掩码有助于划分网络和管理 IP 地址。通过使用子网掩码，网络管理员可以将一个大的 IP 地址空间分成多个子网，以便更有效地管理网络。例如，一个大的 IP 地址空间可以划分为多个小的子网，每个子网可以被分配给不同的部门或办公室，以便更好地管理网络流量和安全。\nUDP 和 TCP 的区别，适用场景 1.TCP 是面向连接的协议，建立和释放连接需要进行三次握手和四次挥手。UDP 是面向无连接的协议，无需进行三次握手和四次挥手。说明 udp 比 TCP 实时性更强。\n2.TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。\n3.TCP 连接的可靠性强，UDP 的可靠性不强。\n4.TCP 只能一对一，UDP 支持一对多和多对多。\n5.TCP 的头部开销比 UDP 大。TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。UDP 首部只有 8 个字节，并且是固定不变的，开销较小。\nTCP 适用于对数据传输的可靠性要求较高的场景，如文件传输（ftp）、电子邮件（stmp）、网页浏览（http）等；UDP 适用于对数据传输的可靠性要求较低、数据传输速度要求较高的场景，如在线游戏、实时音视频、DNS 等。\n为什么会出现大量的 close_wait 状态，如何解决 TIME_WAIT 状态是因为频繁地建立和关闭连接，或者连接关闭不规范等。\n解决办法：\n调整 TCP 参数如 TIME_WAIT 时间。 优化程序设计，比如使用连接池。 使用 SO_REUSEADDR 共用端口。 使用负载均衡器分摊连接负载。少 time_wait 状态的出现。 交换机位于哪一层 交换机位于数据链层，负责在同一网络下中转发数据帧。它能够根据目标 MAC 地址来决定数据帧的转发路径，以实现同一网络内的通信。 路由器是一种网络设备，主要用于在不同的网络之间转发数据包。\n五层网络中的各层协议有啥 DNS 过程 以下是 DNS 解析 www.example 的过程：\n当用户在浏览器中输入 www.example 时，浏览器会向本地 DNS 服务器发送 DNS 解析请求。\n如果本地 DNS 服务器缓存了该域名的解析信息，它将直接返回该域名的 IP 地址。否则，它将向根域名服务器发送请求。\n根域名服务器将返回.com 顶级域名服务器的地址。\n本地 DNS 服务器随后向.com 顶级域名服务器发送请求，并返回该域名的权威域名服务器地址。\n本地 DNS 服务器向该权威域名服务器发送请求，并返回该域名的 IP 地址。\n本地 DNS 服务器将该 IP 地址缓存起来，并将其返回给用户的计算机或设备。\n用户的计算机或设备使用该 IP 地址与该域名的服务器进行通信，以获取网站的内容。\n为什么三次握手，两次不行吗 弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。\n第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。 第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。 因此，需要三次握手才能确认双方的接收与发送能力是否正常。 试想如果是用两次握手，则会出现下面这种情况：\n如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。\nhttps 加密是对称的还是不对称的 HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。\n流量控制如何实现的 流量控制是使用滑动窗口来实现的。接收方确认报文中的窗口字段可以用来控制发送方窗口的大小。\n如果窗户的值为 0，则发送方停止发送数据，但是发送方会定期的向接收方发送窗口探测报文以得到窗口的大小。\n补充\nTCP 传输协议中，流量控制是使用滑动窗口（Sliding Window）来实现的。滑动窗口是一种基于数据流的、动态调整的、可变大小的窗口，它通过协商双方的接收窗口和发送窗口大小，控制数据的传输速率。\n在 TCP 协议中，每个数据包都有一个序号，接收方通过序号来确认是否收到了正确的数据包。发送方将数据分成若干个数据段(数据段\"是指传输的基本单位。当应用程序向 TCP 层发送大量数据时，TCP 会将这些数据分割为适合网络传输的大小，每一部分被称为一个\"数据段\"。)，每个数据段的大小不超过发送窗口的大小，然后将这些数据段发送给接收方。接收方会确认已经收到的数据，同时告诉发送方自己的接收窗口大小。发送方根据接收方的窗口大小，动态调整自己的发送窗口大小，从而控制数据的传输速率。\n滑动窗口的大小是可以动态调整的，它可以根据网络状况和双方的能力来自适应地调整，从而实现流量控制的功能。如果接收方的接收窗口变小，发送方会相应地减小自己的发送窗口，以避免过多的数据堆积在网络中导致拥塞。如果接收方的接收窗口变大，发送方会相应地增加自己的发送窗口，以提高数据传输速率。\nclose_wait time_wait fin_wait2 fin_wait2 还有数据接收能力，但是没有数据发送能力 close_wait 还有数据要发送就进入这状态 time_wait 又叫 2MSL 等待状态。防止最后一次 ack 没有接收到，在这个阶段中，同一个 socket 不能再被使用 流量控制 目的是接收方通过 TCP 头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。\nTCP 是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。\n发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的 TCP 报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。 接收窗：用来标记可以接收的数据大小。 TCP 是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收部分。\n发送窗内数据只有当接收到接收端某段发送数据的 ACK 响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。\\\nSession和cookie应该如何去选择 Session和Cookie都是用来跟踪浏览器用户身份的会话技术，但它们之间有一些关键的区别：\n存储位置：\nCookie数据存放在客户端（浏览器）。 Session数据存放在服务器。 生命周期：\nCookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 Session默认情况下，仅在浏览器运行期间存在，关闭浏览器则Session结束。开发者也可以设置Session的失效时间。 存储大小：\nCookie的大小受限制。它依赖于浏览器的不同可能有所不同，一般为4KB左右。 Session没有大小限制，可以存储较大量的数据。 安全性：\nCookie存储在客户端，相对容易被篡改，比较不安全。 Session存储在服务器端，相对较安全。 跨域问题：\nCookie只能在同源的情况下共享。 Session由于存储在服务器上，可以在多个不同域名的页面间共享。 Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；\nCookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；\n对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。\nJWT token是什么？ JWT Token是一种用于身份验证和授权的安全令牌，包含了用户的信息和数字签名，可以在多个系统间共享。\nJWT由三部分组成：头部(Header)、载荷(Payload)和签名(Signature)。其中:\n头部包含令牌类型、算法、发行者、受众和有效期等信息； 载荷包含用户信息； 签名则是对整个JWT进行加密签名，以保证其安全性。 Token是一个用于访问资源的凭证，它包含了身份验证信息和关联的元数据。\nudp如何实现可靠传输 最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。\n1、添加seq/ack机制，确保数据发送到对端\n2、添加发送和接收缓冲区，主要是用户超时重传。\n3、添加超时重传机制。 详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。\n#TCP一次可以发一个数据包还是几个数据包\n流式服务，每次发生一个数据，他会底层进行切分\n",
  "wordCount" : "11173",
  "inLanguage": "en",
  "datePublished": "2023-07-29T11:04:35+08:00",
  "dateModified": "2023-07-29T11:04:35+08:00",
  "author":[{
    "@type": "Person",
    "name": "chx9"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://chx9.github.io/posts/cs/network/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "chx9",
    "logo": {
      "@type": "ImageObject",
      "url": "https://chx9.github.io/img/svin.webp"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://chx9.github.io/" accesskey="h" title="chx9 (Alt + H)">chx9</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://chx9.github.io/search" title="🔍 search (Alt &#43; /)" accesskey=/>
                <span>🔍 search</span>
                </a>
            </li>
            <li>
                <a href="https://chx9.github.io/" title="🏠 home">
                <span>🏠 home</span>
                </a>
            </li>
            <li>
                <a href="https://chx9.github.io/posts" title="📚 articles">
                <span>📚 articles</span>
                </a>
            </li>
            <li>
                <a href="https://chx9.github.io/tags" title="🧩 tags">
                <span>🧩 tags</span>
                </a>
            </li>
            <li>
                <a href="https://chx9.github.io/about" title="🙋🏻‍♂️ about">
                <span>🙋🏻‍♂️ about</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }
</style>

<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://chx9.github.io/">🏠 主页</a>&nbsp;»&nbsp;<a href="https://chx9.github.io/posts/">📚Articles</a>&nbsp;»&nbsp;<a href="https://chx9.github.io/posts/cs/">💻 Programming</a></div>
            <h1 class="post-title">
                network
            </h1>
            <div class="post-meta">

<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2023-07-29
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>11173字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>23分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>chx9
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
            </span>
        </span>
    </span>
</span>
<span style="opacity: 0.8;">
                    <span id="post_meta_style_7">
                        &nbsp;&nbsp;
                        <span class="fa fa-eye" ></span>
                        <span>
                            <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
                            &nbsp;&nbsp;
                        </span>
                    </span>
                    <span id="post_meta_style_8">
                        <span class="fa fa-commenting-o"></span>
                        <span>
                            <script src="https://cdn.staticfile.org/twikoo//twikoo.all.min.js"></script>
                            <script>
                                let url = document.documentURI
                                
                                let dnsUrl = "https://chx9.github.io/"
                                let urlSplit = url.split(dnsUrl)
                                let finalUrl = urlSplit[1]
                                if (finalUrl[0] !== '/') {
                                    finalUrl = '/'+finalUrl
                                }
                                twikoo.getCommentsCount({
                                    envId:  null , 
                                region:  null , 
                                urls: [ 
                                    
                                    finalUrl,
                                ],
                                    includeReply: false 
                                }).then(function (res) {
                                    let count = res[0].count
                                    const obj = document.getElementById("comment_count");
                                    obj.innerText = count
                                    
                                    
                                    
                                }).catch(function (err) {
                                    
                                    console.error(err);
                                });
                            </script>
                            <span id="comment_count"></span>
                        </span>
                    </span>
                </span>

</div>
        </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e8%bf%87%e7%a8%8b" aria-label="三次握手过程">三次握手过程</a></li>
                <li>
                    <a href="#%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b%e8%bf%87%e7%a8%8b" aria-label="四次挥手过程">四次挥手过程</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88-tcp-%e8%a6%81%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b" aria-label="为什么 TCP 要三次握手？">为什么 TCP 要三次握手？</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88-tcp-%e8%a6%81%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b" aria-label="为什么 TCP 要四次挥手">为什么 TCP 要四次挥手</a></li>
                <li>
                    <a href="#tcp-%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%a4%b1%e8%b4%a5%e4%bc%9a%e5%8f%91%e7%94%9f%e4%bb%80%e4%b9%88" aria-label="TCP 三次握手失败会发生什么">TCP 三次握手失败会发生什么</a><ul>
                        
                <li>
                    <a href="#%e7%ac%ac%e4%b8%80%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%a4%b1%e8%b4%a5" aria-label="第一次握手失败">第一次握手失败</a></li>
                <li>
                    <a href="#%e7%ac%ac%e4%ba%8c%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%a4%b1%e8%b4%a5" aria-label="第二次握手失败">第二次握手失败</a></li>
                <li>
                    <a href="#%e7%ac%ac%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%a4%b1%e8%b4%a5" aria-label="第三次握手失败">第三次握手失败</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%88%97%e4%b8%be%e5%b8%b8%e7%94%a8%e7%9a%84-http-%e7%8a%b6%e6%80%81%e7%a0%81" aria-label="列举常用的 HTTP 状态码">列举常用的 HTTP 状态码</a></li>
                <li>
                    <a href="#get-%e5%92%8c-post-%e8%af%b7%e6%b1%82" aria-label="GET 和 POST 请求">GET 和 POST 请求</a></li>
                <li>
                    <a href="#http-%e5%92%8c-https" aria-label="HTTP 和 HTTPS">HTTP 和 HTTPS</a></li>
                <li>
                    <a href="#http-%e5%8a%a0%e5%af%86%e8%bf%87%e7%a8%8b" aria-label="http 加密过程">http 加密过程</a></li>
                <li>
                    <a href="#%e8%be%93%e5%85%a5%e7%bd%91%e5%9d%80%e5%88%b0%e5%87%ba%e7%8e%b0%e7%bd%91%e9%a1%b5%e7%9a%84%e5%85%a8%e8%bf%87%e7%a8%8b" aria-label="输入网址到出现网页的全过程">输入网址到出现网页的全过程</a></li>
                <li>
                    <a href="#tcp-%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6" aria-label="TCP 拥塞控制">TCP 拥塞控制</a></li>
                <li>
                    <a href="#%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6%e5%92%8c%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6%e5%88%86%e5%88%ab%e8%a7%a3%e5%86%b3%e4%ba%86%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98" aria-label="流量控制和拥塞控制分别解决了什么问题">流量控制和拥塞控制分别解决了什么问题</a></li>
                <li>
                    <a href="#http-%e9%95%bf%e8%bf%9e%e6%8e%a5%e5%92%8c%e7%9f%ad%e8%bf%9e%e6%8e%a5%e5%8c%ba%e5%88%ab" aria-label="http 长连接和短连接区别">http 长连接和短连接区别</a></li>
                <li>
                    <a href="#%e5%93%aa%e4%ba%9b%e7%94%a8-udp-%e5%93%aa%e4%ba%9b%e7%94%a8-tcp" aria-label="哪些用 UDP 哪些用 TCP">哪些用 UDP 哪些用 TCP</a></li>
                <li>
                    <a href="#https-ssl-%e8%bf%9e%e6%8e%a5%e7%9a%84%e8%bf%87%e7%a8%8b" aria-label="https ssl 连接的过程">https ssl 连接的过程</a></li>
                <li>
                    <a href="#http10-%e5%92%8c-http11-%e5%92%8c-http20-%e7%9a%84%e5%b7%ae%e5%88%ab%e5%88%86%e5%88%ab%e5%81%9a%e4%ba%86%e5%93%aa%e5%87%a0%e7%82%b9%e4%bc%98%e5%8c%96" aria-label="http1.0 和 http1.1 和 http2.0 的差别，分别做了哪几点优化">http1.0 和 http1.1 和 http2.0 的差别，分别做了哪几点优化</a></li>
                <li>
                    <a href="#http-%e8%af%b7%e6%b1%82%e5%92%8c%e6%8a%a5%e6%96%87%e6%9c%89%e5%93%aa%e4%ba%9b%e5%ad%97%e6%ae%b5" aria-label="http 请求和报文有哪些字段">http 请求和报文有哪些字段</a></li>
                <li>
                    <a href="#tcp-%e7%b2%98%e5%8c%85%e7%8e%b0%e8%b1%a1" aria-label="tcp 粘包现象">tcp 粘包现象</a><ul>
                        
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e6%9c%89%e7%b2%98%e5%8c%85%e7%8e%b0%e8%b1%a1" aria-label="为什么会有粘包现象">为什么会有粘包现象</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-tcp-%e7%b2%98%e5%8c%85%e7%8e%b0%e8%b1%a1%e7%9a%84%e6%96%b9%e6%b3%95%e4%b8%bb%e8%a6%81%e6%9c%89%e4%bb%a5%e4%b8%8b%e5%87%a0%e7%a7%8d" aria-label="解决 TCP 粘包现象的方法主要有以下几种：">解决 TCP 粘包现象的方法主要有以下几种：</a></li></ul>
                </li>
                <li>
                    <a href="#post-%e5%92%8c-get-%e8%af%b7%e6%b1%82" aria-label="POST 和 GET 请求">POST 和 GET 请求</a></li>
                <li>
                    <a href="#tcp-%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e5%8f%af%e9%9d%a0" aria-label="tcp 如何保证可靠">tcp 如何保证可靠</a></li>
                <li>
                    <a href="#%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3" aria-label="滑动窗口">滑动窗口</a></li>
                <li>
                    <a href="#ping-%e7%9a%84%e8%bf%87%e7%a8%8b" aria-label="ping 的过程">ping 的过程</a></li>
                <li>
                    <a href="#mac-%e5%af%bb%e5%9d%80%e5%92%8c-ip-%e5%af%bb%e5%9d%80%e7%9a%84%e5%b7%ae%e5%bc%82" aria-label="mac 寻址和 ip 寻址的差异">mac 寻址和 ip 寻址的差异</a></li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e5%b1%82%e7%9a%84%e4%bd%9c%e7%94%a8" aria-label="数据链路层的作用">数据链路层的作用</a></li>
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c%e5%b1%82%e7%9a%84%e4%bd%9c%e7%94%a8" aria-label="网络层的作用">网络层的作用</a></li>
                <li>
                    <a href="#%e5%ad%90%e7%bd%91%e6%8e%a9%e7%a0%81" aria-label="子网掩码">子网掩码</a></li>
                <li>
                    <a href="#udp-%e5%92%8c-tcp-%e7%9a%84%e5%8c%ba%e5%88%ab%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="UDP 和 TCP 的区别，适用场景">UDP 和 TCP 的区别，适用场景</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e5%87%ba%e7%8e%b0%e5%a4%a7%e9%87%8f%e7%9a%84-close_wait-%e7%8a%b6%e6%80%81%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3" aria-label="为什么会出现大量的 close_wait 状态，如何解决">为什么会出现大量的 close_wait 状态，如何解决</a></li>
                <li>
                    <a href="#%e4%ba%a4%e6%8d%a2%e6%9c%ba%e4%bd%8d%e4%ba%8e%e5%93%aa%e4%b8%80%e5%b1%82" aria-label="交换机位于哪一层">交换机位于哪一层</a></li>
                <li>
                    <a href="#%e4%ba%94%e5%b1%82%e7%bd%91%e7%bb%9c%e4%b8%ad%e7%9a%84%e5%90%84%e5%b1%82%e5%8d%8f%e8%ae%ae%e6%9c%89%e5%95%a5" aria-label="五层网络中的各层协议有啥">五层网络中的各层协议有啥</a></li>
                <li>
                    <a href="#dns-%e8%bf%87%e7%a8%8b" aria-label="DNS 过程">DNS 过程</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e4%b8%a4%e6%ac%a1%e4%b8%8d%e8%a1%8c%e5%90%97" aria-label="为什么三次握手，两次不行吗">为什么三次握手，两次不行吗</a></li>
                <li>
                    <a href="#https-%e5%8a%a0%e5%af%86%e6%98%af%e5%af%b9%e7%a7%b0%e7%9a%84%e8%bf%98%e6%98%af%e4%b8%8d%e5%af%b9%e7%a7%b0%e7%9a%84" aria-label="https 加密是对称的还是不对称的">https 加密是对称的还是不对称的</a></li>
                <li>
                    <a href="#%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e7%9a%84" aria-label="流量控制如何实现的">流量控制如何实现的</a></li>
                <li>
                    <a href="#close_wait-time_wait-fin_wait2" aria-label="close_wait time_wait fin_wait2">close_wait time_wait fin_wait2</a></li>
                <li>
                    <a href="#%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6" aria-label="流量控制">流量控制</a></li>
                <li>
                    <a href="#session%e5%92%8ccookie%e5%ba%94%e8%af%a5%e5%a6%82%e4%bd%95%e5%8e%bb%e9%80%89%e6%8b%a9" aria-label="Session和cookie应该如何去选择">Session和cookie应该如何去选择</a></li>
                <li>
                    <a href="#jwt-token%e6%98%af%e4%bb%80%e4%b9%88" aria-label="JWT token是什么？">JWT token是什么？</a></li>
                <li>
                    <a href="#udp%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93" aria-label="udp如何实现可靠传输">udp如何实现可靠传输</a>
                </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        if (elements) {
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                    (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                    return element;
                }
            }) || activeElement

            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                if (element === activeElement){
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
                } else {
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
                }
            })
        }
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        <div class="post-content"><h1 id="三次握手过程">三次握手过程<a hidden class="anchor" aria-hidden="true" href="#三次握手过程">#</a></h1>
<p><img loading="lazy" src="handshake.awebp" alt="handshake"  />
</p>
<h1 id="四次挥手过程">四次挥手过程<a hidden class="anchor" aria-hidden="true" href="#四次挥手过程">#</a></h1>
<p><img loading="lazy" src="fairwell.awebp" alt="fairwell"  />
</p>
<h1 id="为什么-tcp-要三次握手">为什么 TCP 要三次握手？<a hidden class="anchor" aria-hidden="true" href="#为什么-tcp-要三次握手">#</a></h1>
<ul>
<li>最主要原因就是防止「历史连接」初始化了连接。</li>
<li>三次握手才可以同步双方的初始序列号
<!-- ![image](why3_1.png) -->
<img src="why3_1.png" alt="alt text" height="700"/>
<img src="why3_2.png" alt="alt text" height="600"/>
</li>
</ul>
<h1 id="为什么-tcp-要四次挥手">为什么 TCP 要四次挥手<a hidden class="anchor" aria-hidden="true" href="#为什么-tcp-要四次挥手">#</a></h1>
<ul>
<li>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<h1 id="tcp-三次握手失败会发生什么">TCP 三次握手失败会发生什么<a hidden class="anchor" aria-hidden="true" href="#tcp-三次握手失败会发生什么">#</a></h1>
<h2 id="第一次握手失败">第一次握手失败<a hidden class="anchor" aria-hidden="true" href="#第一次握手失败">#</a></h2>
<ul>
<li>客户端重传 SYN 包，直到连接成功或者超时（每次等待两倍时间）</li>
<li>如果服务器无法响应，那么会发送 RST 包，表示拒绝连接</li>
</ul>
<h2 id="第二次握手失败">第二次握手失败<a hidden class="anchor" aria-hidden="true" href="#第二次握手失败">#</a></h2>
<ul>
<li>客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是客户端就会触发超时重传机制，重传 SYN 报文。</li>
<li>服务端这边会触发超时重传机制，重传 SYN-ACK 报文。</li>
</ul>
<h2 id="第三次握手失败">第三次握手失败<a hidden class="anchor" aria-hidden="true" href="#第三次握手失败">#</a></h2>
<p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。
注意，ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</p>
<h1 id="列举常用的-http-状态码">列举常用的 HTTP 状态码<a hidden class="anchor" aria-hidden="true" href="#列举常用的-http-状态码">#</a></h1>
<p>HTTP 状态码是指在 HTTP 协议中，服务器向客户端返回的响应状态码。HTTP 状态码由三位数字组成，第一位数字表示响应类型，后两位数字没有具体分类作用。常见的 HTTP 状态码如下：</p>
<ul>
<li>1xx：信息响应类，表示服务器已接收到客户端的请求，需要进一步处理。</li>
<li>2xx：成功响应类，表示服务器已成功地接收到客户端的请求并返回响应结果。</li>
<li>3xx：重定向响应类，表示客户端需要进一步操作才能完成请求，如重定向到其他 URL。</li>
<li>4xx：客户端错误响应类，表示客户端请求存在错误或无法被服务器处理。</li>
<li>5xx：服务器错误响应类，表示服务器在处理请求时出现了错误或异常。</li>
</ul>
<p>以下是常见的 HTTP 状态码及其含义：</p>
<ul>
<li>200 OK：表示请求被成功处理，并返回响应结果。</li>
<li>301 Moved Permanently：表示请求的资源已经被永久移动到新的位置，客户端需要使用新的 URL。</li>
<li>302 Found：表示请求的资源已经被暂时移动到新的位置，客户端需要使用新的 URL，但是之后可能会恢复原来的位置。</li>
<li>304 Not Modified：表示客户端发送了一个条件请求，并且服务器认为客户端请求的资源没有被修改，因此不需要返回资源的实体内容，只需要返回响应头信息即可。</li>
<li>400 Bad Request ：请求报文中存在语法错误。</li>
<li>403 Forbidden ：请求被拒绝。</li>
<li>404 Not Found：表示请求的资源不存在或无法被找到。</li>
<li>500 Internal Server Error：表示服务器在处理请求时出现了未知的错误或异常。</li>
</ul>
<p>除了上述常见的 HTTP 状态码，HTTP 协议中还有很多其他状态码，每个状态码都有其特定的含义和用途。在编写 Web 应用程序时，了解 HTTP 状态码的含义和使用方法，可以帮助我们更好地处理 HTTP 请求，提高程序的可靠性和稳定性。</p>
<h1 id="get-和-post-请求">GET 和 POST 请求<a hidden class="anchor" aria-hidden="true" href="#get-和-post-请求">#</a></h1>
<p>get是获取数据，post是修改数</p>
<h1 id="http-和-https">HTTP 和 HTTPS<a hidden class="anchor" aria-hidden="true" href="#http-和-https">#</a></h1>
<p>HTTP（Hypertext Transfer Protocol）和 HTTPS（Hypertext Transfer Protocol Secure）都是用于在 Web 上进行数据传输的协议，它们的主要区别在于安全性：</p>
<ol>
<li>
<p>安全性：HTTP 是明文传输协议，数据在传输过程中没有加密，容易被窃听和篡改；HTTPS 利用 SSL/TLS 协议进行数据加密和身份认证，可以保证数据传输的安全性。</p>
</li>
<li>
<p>端口号：HTTP 使用的端口号为 80，而 HTTPS 使用的端口号为 443。</p>
</li>
<li>
<p>证书：HTTPS 需要使用数字证书对网站进行身份验证，证书由受信任的第三方机构颁发，可以保证网站的真实性和安全性；而 HTTP 没有身份验证机制，无法保证网站的真实性和安全性。</p>
</li>
<li>
<p>性能：HTTPS 比 HTTP 的性能要差一些，因为 HTTPS 需要进行加密和解密操作，会增加服务器和客户端的处理负担，导致响应速度变慢。</p>
</li>
</ol>
<h1 id="http-加密过程">http 加密过程<a hidden class="anchor" aria-hidden="true" href="#http-加密过程">#</a></h1>
<p>HTTPS（Hypertext Transfer Protocol Secure）是一个用于安全传输数据的协议，它使用 SSL（Secure Sockets Layer）或 TLS（Transport Layer Security）协议来加密 Web 通信。以下是 HTTPS 的加密过程：</p>
<ol>
<li>
<p>客户端发起 HTTPS 请求，请求连接到服务器。</p>
</li>
<li>
<p>服务器向客户端发送一个证书，证书中包含了服务器的公钥、证书的有效期、证书颁发机构等信息。</p>
</li>
<li>
<p>客户端收到证书后，会验证证书的有效性，包括证书是否过期、证书颁发机构是否可信等。如果证书有效，客户端会生成一个随机数，用于后续的加密通信。</p>
</li>
<li>
<p>客户端使用服务器的公钥加密随机数，并将加密后的随机数发送给服务器。</p>
</li>
<li>
<p>服务器使用自己的私钥解密客户端发来的随机数，并使用该随机数作为对称加密算法的密钥，用于后续的数据加密。</p>
</li>
<li>
<p>服务器使用对称加密算法对数据进行加密，并将加密后的数据发送给客户端。</p>
</li>
<li>
<p>客户端使用之前生成的随机数作为对称加密算法的密钥，解密服务器发来的数据，从而得到原始数据。</p>
</li>
</ol>
<p>以上就是 HTTPS 的加密过程，通过使用 SSL 或 TLS 协议，可以确保数据在传输过程中的机密性、完整性和真实性。</p>
<h1 id="输入网址到出现网页的全过程">输入网址到出现网页的全过程<a hidden class="anchor" aria-hidden="true" href="#输入网址到出现网页的全过程">#</a></h1>
<p>输入网址到浏览器中，到收到网页的整个过程大致可以分为以下步骤：</p>
<ol>
<li>
<p>DNS 解析：浏览器首先会解析输入的网址中的域名，将其转换为对应的 IP 地址。浏览器会先查找本地 DNS 缓存，如果没有找到匹配的 IP 地址，则会向 DNS 服务器发送请求，获取对应域名的 IP 地址。</p>
</li>
<li>
<p>建立 TCP 连接：浏览器向服务器发送 TCP 连接请求，建立 TCP 连接。在这个过程中，浏览器和服务器会通过三次握手协议建立连接。</p>
</li>
<li>
<p>发送 HTTP 请求：浏览器向服务器发送 HTTP 请求，请求获取特定资源，比如 HTML、CSS、JavaScript、图片等。</p>
</li>
<li>
<p>服务器响应：服务器接收到浏览器的 HTTP 请求后，会返回相应的资源内容以及 HTTP 状态码。</p>
</li>
<li>
<p>浏览器渲染：当浏览器接收到服务器返回的资源内容后，会根据 HTML、CSS 和 JavaScript 等文件进行解析，生成 DOM 和 CSSOM 树，并将其合并成渲染树。然后浏览器会根据渲染树进行布局和绘制，最终将网页内容显示在用户界面上。</p>
</li>
</ol>
<p>在这个过程中，涉及到的协议主要有：</p>
<ol>
<li>
<p>DNS 协议：用于域名解析，将域名转换为对应的 IP 地址。</p>
</li>
<li>
<p>TCP 协议：用于在浏览器和服务器之间建立可靠的连接，确保数据的可靠传输。</p>
</li>
<li>
<p>HTTP 协议：用于在浏览器和服务器之间传输资源内容，包括 HTML、CSS、JavaScript、图片等。</p>
</li>
<li>
<p>HTTPS 协议：用于在 HTTP 协议的基础上添加 SSL/TLS 协议进行加密通信，提高数据传输的安全性。</p>
</li>
</ol>
<h1 id="tcp-拥塞控制">TCP 拥塞控制<a hidden class="anchor" aria-hidden="true" href="#tcp-拥塞控制">#</a></h1>
<p><a href="https://www.bilibili.com/video/BV1L4411a7RN/?spm_id_from=333.337.search-card.all.click&amp;vd_source=88a9ec90f0dcb5eb62f1a86d6d8d0ad4">b 站视频</a></p>
<p><a href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">小林 coding</a></p>
<p>拥塞控制是一种网络流量控制机制，它通过限制数据流的速度来防止网络拥塞和保持网络的稳定性。拥塞控制的几个常见机制包括：</p>
<ol>
<li>
<p>慢启动：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。相当于 2 的指数倍增长 。</p>
</li>
<li>
<p>拥塞避免：每当收到一个 ACK 时，cwnd 增加 1/cwnd，变成了线性增长。</p>
</li>
<li>
<p>快速重传：当发送方发现某个数据包没有收到确认时，它会重传该数据包。然而，如果发送方连续发送了多个数据包而没有收到确认，它会认为网络出现了拥塞，并立即减慢发送速率。幸运的是，由于 TCP 采用的是累计确认机制，即当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余 ACK（duplicate ACK）。</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>如图所示，报文段1成功接收并被确认ACK 2，接收端的期待序号为2，当报文段2丢失，报文段3失序到来，与接收端的期望不匹配，接收端重复发送冗余ACK 2。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>这样，如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK（其实是收到4个同样的ACK，第一个是正常的，后三个才是冗余的），发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出，大大提高了效率。这便是快速重传机制。
</span></span></code></pre></div><p><img loading="lazy" src="kuaichongchuan.png" alt="快速重传"  />
 4. 快速恢复：当发送方减慢发送速率时，接收方会通知发送方可以增加发送速率。这种机制称为快速恢复，它可以帮助发送方更快地恢复正常的发送速率，而不是像慢启动一样重新开始。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>正如前面所说，进入快速恢复之前，cwnd 和 ssthresh 已被更新了：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cwnd = cwnd/2 ，也就是设置为原来的一半;
</span></span><span style="display:flex;"><span>ssthresh = cwnd;
</span></span><span style="display:flex;"><span>然后，进入快速恢复算法如下：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；
</span></span><span style="display:flex;"><span>重传丢失的数据包；
</span></span><span style="display:flex;"><span>如果再收到重复的 ACK，那么 cwnd 增加 1；
</span></span><span style="display:flex;"><span>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；
</span></span></code></pre></div><p><img loading="lazy" src="yongse.png" alt="拥塞控制"  />
</p>
<h1 id="流量控制和拥塞控制分别解决了什么问题">流量控制和拥塞控制分别解决了什么问题<a hidden class="anchor" aria-hidden="true" href="#流量控制和拥塞控制分别解决了什么问题">#</a></h1>
<p>流量控制是防止接收端被发送端的数据包淹没，确保接收端处理得过来。</p>
<p>拥塞控制是避免网络中的数据包太多，导致网络资源如路由器、链路等过载</p>
<h1 id="http-长连接和短连接区别">http 长连接和短连接区别<a hidden class="anchor" aria-hidden="true" href="#http-长连接和短连接区别">#</a></h1>
<p>长连接（Long Connection）</p>
<ul>
<li>
<p>长连接在数据的传输结束后，仍然保持连接状态，可重复使用，直到客户端或服务器主动关闭。</p>
</li>
<li>
<p>场景：实时应用（如在线聊天、即时通讯）、数据库连接、HTTP/2 中的服务。
短连接（Short Connection）</p>
</li>
<li>
<p>短连接发送请求后，得到服务器响应就立刻断开。</p>
</li>
<li>
<p>场景：HTTP/1.0 协议、邮件发送/接收、FTP 文件传输。</p>
</li>
</ul>
<h1 id="哪些用-udp-哪些用-tcp">哪些用 UDP 哪些用 TCP<a hidden class="anchor" aria-hidden="true" href="#哪些用-udp-哪些用-tcp">#</a></h1>
<p>应用层协议可以使用 TCP 或 UDP 进行数据传输，具体使用哪种传输协议，需要根据协议的特性和应用场景进行选择。下面是一些常见的应用层协议及其使用的传输协议：</p>
<p>使用 TCP 传输的应用层协议：</p>
<ol>
<li>
<p>HTTP 协议：用于 Web 应用程序的数据传输。</p>
</li>
<li>
<p>FTP 协议：用于文件传输，支持文件上传和下载等操作。</p>
</li>
<li>
<p>SMTP 协议：用于电子邮件的传输。</p>
</li>
<li>
<p>SSH 协议：用于安全远程登录和文件传输。</p>
</li>
<li>
<p>Telnet 协议：用于远程登录主机进行命令行操作。</p>
</li>
</ol>
<p>使用 UDP 传输的应用层协议：</p>
<ol>
<li>
<p>DNS 协议：用于域名解析，将域名转换为 IP 地址。</p>
</li>
<li>
<p>DHCP 协议：用于动态 IP 地址分配，自动分配和管理 IP 地址。</p>
</li>
<li>
<p>TFTP 协议：用于简单文件传输，支持无连接传输方式。</p>
</li>
<li>
<p>SNMP 协议：用于网络管理和监控，实现对网络设备的远程管理。</p>
</li>
<li>
<p>RTP 协议：用于音视频数据的传输，支持实时传输和流媒体播放。</p>
</li>
</ol>
<p>需要注意的是，有些应用层协议同时支持 TCP 和 UDP 传输，如 DNS 协议和 FTP 协议等，可以根据实际情况进行选择。</p>
<h1 id="https-ssl-连接的过程">https ssl 连接的过程<a hidden class="anchor" aria-hidden="true" href="#https-ssl-连接的过程">#</a></h1>
<p>HTTPS 加密过程简略如下：</p>
<ol>
<li>
<p>客户端发送 HTTPS 请求，请求头中的<code>https</code>字段设置为<code>on</code>。</p>
</li>
<li>
<p>服务器返回数字证书，包含服务器的公钥、证书颁发机构的信息、证书有效期等。</p>
</li>
<li>
<p>客户端验证证书合法性，确认无误后生成随机的会话密钥，并使用服务器的公钥将其加密后发送给服务器。</p>
</li>
<li>
<p>服务器使用自己的私钥解密会话密钥，得到原始的会话密钥。</p>
</li>
<li>
<p>双方使用会话密钥进行对称加密，保证通信过程中的数据安全性，并进行数字签名和身份认证，确保通信的可信性和完整性。</p>
</li>
</ol>
<h1 id="http10-和-http11-和-http20-的差别分别做了哪几点优化">http1.0 和 http1.1 和 http2.0 的差别，分别做了哪几点优化<a hidden class="anchor" aria-hidden="true" href="#http10-和-http11-和-http20-的差别分别做了哪几点优化">#</a></h1>
<p>HTTP 1.0 是一种无状态，无连接的应用层协议。浏览器每次请求都需要与服务器建立一个TCP 连接，服务器处理完成以后立即断开 TCP 连接(无连接),服务器不跟踪也每个客户单，也不记录过去的请求(无状态) 。</p>
<p>HTTP 1.1 支持长连接和请求的流水线处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了网络延迟 。</p>
<p>HTTP 2.0 是基于二进制流的，可以分解为独立的帧，交错发送，从而提高了网络传输效率。</p>
<p>HTTP/3 是最新的版本，它使用了 QUIC 协议来提高网络传输效率。</p>
<p>HTTP 是一种应用层协议，常用于 Web 应用中，目前主要有 HTTP/1.0、HTTP/1.1 和 HTTP/2.0 三个版本。它们之间的主要差别及优化如下：</p>
<ol>
<li>HTTP/1.0 和 HTTP/1.1 的主要差别</li>
</ol>
<p>HTTP 1.0</p>
<p>单一请求响应模型，每个请求/响应都会断开连接。
HTTP 1.1</p>
<ul>
<li>
<p>持久连接：默认情况下，所有的连接都被认为是持久的，除非有明确的关闭。</p>
</li>
<li>
<p>管道化技术：在同一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了网络延迟。(复用 tcp 连接)</p>
</li>
<li>
<p>增加更多的缓存控制策略。</p>
</li>
</ul>
<p>HTTP 2.0</p>
<ul>
<li>
<p>多路复用：单一 TCP 连接中可<strong>并行</strong>交换多个 HTTP 请求/响应。</p>
</li>
<li>
<p>首部压缩：对头信息进行压缩，减少数据传输量。</p>
</li>
<li>
<p>服务器推送：允许服务器未经客户端明确请求就发送数据到客户端，提高性能。</p>
</li>
</ul>
<p>HTTP 3.0</p>
<p>QUIC 协议来提高网络传输效率。</p>
<h1 id="http-请求和报文有哪些字段">http 请求和报文有哪些字段<a hidden class="anchor" aria-hidden="true" href="#http-请求和报文有哪些字段">#</a></h1>
<ol>
<li>请求</li>
</ol>
<ul>
<li>请求行：Request Line</li>
<li>请求头：Request Headers</li>
<li>请求体：Request Body</li>
</ul>
<ol start="2">
<li>相应</li>
</ol>
<ul>
<li>状态行：Status Line</li>
<li>响应头：Response Headers</li>
<li>响应体：Response Body</li>
</ul>
<h1 id="tcp-粘包现象">tcp 粘包现象<a hidden class="anchor" aria-hidden="true" href="#tcp-粘包现象">#</a></h1>
<h2 id="为什么会有粘包现象">为什么会有粘包现象<a hidden class="anchor" aria-hidden="true" href="#为什么会有粘包现象">#</a></h2>
<p>TCP粘包问题是指发送方发送的若干个包数据到达接收方时，被接收方读取为一个数据包。</p>
<p>TCP 粘包是因为 TCP 基于字节流，不保证消息边界</p>
<ol>
<li>因为TCP默认会使用Nagle算法，此算法会导致粘包问题。</li>
</ol>
<ul>
<li>只有上一个分组得到确认，才会发送下一个分组；</li>
<li>收集多个小分组，在一个确认到来时一起发送。</li>
</ul>
<ol start="2">
<li>TCP连接复用：在高并发环境下，同一个TCP连接可能会被多个请求复用，从而可能导致不同请求的数据包混杂在一起。</li>
<li>数据包过大：如果发送的数据包大于TCP的最大报文段长度（MSS - Maximum Segment Size），就需要对数据包进行分片。这个过程可能造成接收方处理来自同一数据包的分片时出现粘包</li>
<li>接收方不及时接收缓冲区的包：如果接收方不能及时处理其接收缓冲区的数据，新到达的数据包可能会与已存在的数据包混合，形成一个大的数据块，从而产生粘包。</li>
</ol>
<h2 id="解决-tcp-粘包现象的方法主要有以下几种">解决 TCP 粘包现象的方法主要有以下几种：<a hidden class="anchor" aria-hidden="true" href="#解决-tcp-粘包现象的方法主要有以下几种">#</a></h2>
<ol>
<li>
<p>增加消息边界：在消息头部添加消息长度字段，接收方根据消息长度进行数据的切割。</p>
</li>
<li>
<p>使用固定长度的消息：发送方将消息按照固定长度进行分割，接收方根据固定长度进行数据的切割。</p>
</li>
<li>
<p>使用特殊字符作为消息分隔符：发送方在消息尾部添加特殊字符作为消息分隔符，接收方根据特殊字符进行数据的切割。</p>
</li>
<li>
<p>使用应用层协议：在应用层协议中规定消息的格式和边界，从而避免粘包现象的发生。</p>
</li>
<li>
<p>Nagle算法问题导致的，需要结合应用场景适当关闭该算法</p>
</li>
</ol>
<h1 id="post-和-get-请求">POST 和 GET 请求<a hidden class="anchor" aria-hidden="true" href="#post-和-get-请求">#</a></h1>
<ol>
<li>
<p>get是获取数据，post是修改数据</p>
</li>
<li>
<p>get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以&amp;相连，所以get不太安全。而post把数据放在HTTP的包体内（request body 相对安全）</p>
</li>
<li>
<p>get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。</p>
</li>
<li>
<p>GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</p>
</li>
<li>
<p>GET请求会被浏览器主动缓存，而POST不会，除非手动设置。</p>
</li>
<li>
<p>本质区别：GET是幂等的，而POST不是幂等的</p>
<blockquote>
<p>这里的幂等性：幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。</p>
</blockquote>
</li>
</ol>
<p>正因为它们有这样的区别，所以不应该且<strong>不能用get请求做数据的增删改这些有副作用的操作</strong>。因为get请求是幂等的，<strong>在网络不好的隧道中会尝试重试</strong>。如果用get请求增数据，会有<strong>重复操作</strong>的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）</p>
<h1 id="tcp-如何保证可靠">tcp 如何保证可靠<a hidden class="anchor" aria-hidden="true" href="#tcp-如何保证可靠">#</a></h1>
<p>TCP（Transmission Control Protocol）是一种面向连接的、可靠的传输协议，它通过以下机制来保证数据传输的可靠性：</p>
<ol>
<li>
<p>序列号与确认应答机制：每个 TCP 报文段都有一个唯一的序列号和确认应答号，用于保证数据的顺序性和完整性。发送端将数据分成若干个报文段发送，每个报文段都有一个序列号，接收端收到报文段后需向发送端发送确认应答，确认应答号为接收到的数据的下一个期望的序列号。如果发送端接收到确认应答，就认为该报文段已经成功传输，可以将该报文段从发送缓冲区中删除。</p>
</li>
<li>
<p>超时重传机制：发送端在发送数据时会启动一个定时器，如果在指定时间内没有收到接收端的确认应答，发送端会判断该报文段丢失了，需要重新发送。接收端收到重复的报文段时，会丢弃该报文段，同时向发送端发送确认应答。</p>
</li>
<li>
<p>滑动窗口机制：TCP 使用滑动窗口机制来实现流量控制和拥塞控制。发送端和接收端都有一个窗口大小，用于限制发送和接收数据的速率。发送端发送数据时，需要等待接收端发送的确认应答，确认应答中包含接收端当前窗口的大小，发送端根据窗口大小来调整发送数据的速率。</p>
</li>
<li>
<p>拥塞控制</p>
</li>
<li>
<p>校验和：校验和（checksum）是一种用于检测数据传输过程中是否发生错误的技术。在数据传输过程中，可能会出现各种各样的错误，比如说数据损坏、数据重复、数据丢失等，这些错误都可能导致数据传输失败或者数据被篡改。校验和技术可以通过计算数据的校验和值来检测这些错误，从而保证数据传输的可靠性。</p>
</li>
</ol>
<p>通过以上机制，TCP 可以保证数据传输的可靠性，并且在网络出现拥塞时可以进行拥塞控制，避免网络拥塞导致数据丢失或传输延迟增加。</p>
<h1 id="滑动窗口">滑动窗口<a hidden class="anchor" aria-hidden="true" href="#滑动窗口">#</a></h1>
<p><a href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">小林 coding</a></p>
<h1 id="ping-的过程">ping 的过程<a hidden class="anchor" aria-hidden="true" href="#ping-的过程">#</a></h1>
<p>主要是 icmp
Ping 是一种常用的网络诊断工具，用于测试主机之间的连通性。当我们使用 Ping 命令时，Ping 程序会执行以下步骤：</p>
<ol>
<li>
<p>发送 ICMP Echo Request 消息：Ping 程序向目标主机发送一个 ICMP Echo Request 消息，该消息包含一个随机的标识符和序列号。</p>
</li>
<li>
<p>接收 ICMP Echo Reply 消息：目标主机收到 ICMP Echo Request 消息后，会向发送方返回一个 ICMP Echo Reply 消息，该消息包含与 Echo Request 消息相同的标识符和序列号。</p>
</li>
<li>
<p>计算往返时间（RTT）：Ping 程序在接收到 Echo Reply 消息后，会计算从发送 Echo Request 消息到接收 Echo Reply 消息所需的时间，即往返时间（RTT）。</p>
</li>
<li>
<p>显示结果：Ping 程序将计算得到的 RTT 值和其他一些统计信息显示在屏幕上。如果目标主机无法到达，Ping 程序会返回一个错误消息。</p>
</li>
</ol>
<p>需要注意的是，Ping 命令使用的是 ICMP 协议，而不是 TCP 或 UDP 协议。因此，Ping 命令可以用于测试主机之间的连通性，但不能用于测试 TCP 或 UDP 服务的可用性。此外，由于 ICMP 消息可以被防火墙和路由器过滤，因此在某些情况下，Ping 命令可能无法正常工作。</p>
<h1 id="mac-寻址和-ip-寻址的差异">mac 寻址和 ip 寻址的差异<a hidden class="anchor" aria-hidden="true" href="#mac-寻址和-ip-寻址的差异">#</a></h1>
<p>mac 寻址在数据链路层，ip 寻址在网络层</p>
<h1 id="数据链路层的作用">数据链路层的作用<a hidden class="anchor" aria-hidden="true" href="#数据链路层的作用">#</a></h1>
<p>1、封装成帧
2、流量控制
3、差错控制
4、mac 寻址
5、透明传输</p>
<h1 id="网络层的作用">网络层的作用<a hidden class="anchor" aria-hidden="true" href="#网络层的作用">#</a></h1>
<p><strong>管理数据包的传输和路由选择</strong>，将数据包从源节点传输到目的节点。
实现<strong>IP（Internet Protocol）协议，负责数据包的分组、传输和路由选择</strong>。</p>
<p>提供差错控制和流量控制功能，确保数据包传输的可靠性和效率。</p>
<p>实现路由选择算法，根据网络拓扑结构和路由策略选择最佳的路径将数据包传输到目的节点。</p>
<p>实现地址转换（NAT，Network Address Translation）等功能，将内部私有地址转换为公网可用的地址，以实现网络连接与安全性的需求。</p>
<h1 id="子网掩码">子网掩码<a hidden class="anchor" aria-hidden="true" href="#子网掩码">#</a></h1>
<p>子网掩码（subnet mask）是用于划分<strong>网络地址和主机地址</strong>的一个 32 位数值，用于告诉网络设备哪些位是网络地址，哪些位是主机地址。子网掩码通常与 IP 地址配合使用，用于指示网络中哪些位是网络地址，哪些位是主机地址。</p>
<p>子网掩码的作用是将一个 IP 地址分成两部分：网络地址和主机地址。网络地址用于标识网络，而主机地址用于标识特定的主机。</p>
<p>子网掩码的格式通常是四个 8 位二进制数，例如 255.255.255.0。这个子网掩码表示前 24 位是网络地址，后 8 位是主机地址。这意味着，对于该子网掩码的网络，可以有 256 个主机地址（2 的 8 次方），因为最后 8 位可以有 256 种不同的组合。</p>
<p>在计算机网络中，子网掩码有助于划分网络和管理 IP 地址。通过使用子网掩码，网络管理员可以将一个大的 IP 地址空间分成多个子网，以便更有效地管理网络。例如，一个大的 IP 地址空间可以划分为多个小的子网，每个子网可以被分配给不同的部门或办公室，以便更好地管理网络流量和安全。</p>
<h1 id="udp-和-tcp-的区别适用场景">UDP 和 TCP 的区别，适用场景<a hidden class="anchor" aria-hidden="true" href="#udp-和-tcp-的区别适用场景">#</a></h1>
<p>1.TCP 是面向连接的协议，建立和释放连接需要进行三次握手和四次挥手。UDP 是面向无连接的协议，无需进行三次握手和四次挥手。说明 udp 比 TCP 实时性更强。</p>
<p>2.TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</p>
<p>3.TCP 连接的可靠性强，UDP 的可靠性不强。</p>
<p>4.TCP 只能一对一，UDP 支持一对多和多对多。</p>
<p>5.TCP 的头部开销比 UDP 大。TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</p>
<p>TCP 适用于对数据传输的可靠性要求较高的场景，如文件传输（ftp）、电子邮件（stmp）、网页浏览（http）等；UDP 适用于对数据传输的可靠性要求较低、数据传输速度要求较高的场景，如在线游戏、实时音视频、DNS 等。</p>
<h1 id="为什么会出现大量的-close_wait-状态如何解决">为什么会出现大量的 close_wait 状态，如何解决<a hidden class="anchor" aria-hidden="true" href="#为什么会出现大量的-close_wait-状态如何解决">#</a></h1>
<p>TIME_WAIT 状态是因为频繁地建立和关闭连接，或者连接关闭不规范等。</p>
<p>解决办法：</p>
<ol>
<li>调整 TCP 参数如 TIME_WAIT 时间。</li>
<li>优化程序设计，比如使用连接池。</li>
<li>使用 SO_REUSEADDR 共用端口。</li>
<li>使用负载均衡器分摊连接负载。少 time_wait 状态的出现。</li>
</ol>
<h1 id="交换机位于哪一层">交换机位于哪一层<a hidden class="anchor" aria-hidden="true" href="#交换机位于哪一层">#</a></h1>
<p>交换机位于数据链层，负责在同一网络下中转发数据帧。它能够根据目标 MAC 地址来决定数据帧的转发路径，以实现同一网络内的通信。
路由器是一种网络设备，主要用于在不同的网络之间转发数据包。</p>
<h1 id="五层网络中的各层协议有啥">五层网络中的各层协议有啥<a hidden class="anchor" aria-hidden="true" href="#五层网络中的各层协议有啥">#</a></h1>
<p><img loading="lazy" src="protocols.png" alt="协议"  />
</p>
<h1 id="dns-过程">DNS 过程<a hidden class="anchor" aria-hidden="true" href="#dns-过程">#</a></h1>
<p>以下是 DNS 解析 www.example 的过程：</p>
<ol>
<li>
<p>当用户在浏览器中输入 www.example 时，浏览器会向本地 DNS 服务器发送 DNS 解析请求。</p>
</li>
<li>
<p>如果本地 DNS 服务器缓存了该域名的解析信息，它将直接返回该域名的 IP 地址。否则，它将向根域名服务器发送请求。</p>
</li>
<li>
<p>根域名服务器将返回.com 顶级域名服务器的地址。</p>
</li>
<li>
<p>本地 DNS 服务器随后向.com 顶级域名服务器发送请求，并返回该域名的权威域名服务器地址。</p>
</li>
<li>
<p>本地 DNS 服务器向该权威域名服务器发送请求，并返回该域名的 IP 地址。</p>
</li>
<li>
<p>本地 DNS 服务器将该 IP 地址缓存起来，并将其返回给用户的计算机或设备。</p>
</li>
<li>
<p>用户的计算机或设备使用该 IP 地址与该域名的服务器进行通信，以获取网站的内容。</p>
</li>
</ol>
<h1 id="为什么三次握手两次不行吗">为什么三次握手，两次不行吗<a hidden class="anchor" aria-hidden="true" href="#为什么三次握手两次不行吗">#</a></h1>
<p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p>
<ul>
<li>第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li>
<li>第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li>
<li>第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。
因此，需要三次握手才能确认双方的接收与发送能力是否正常。</li>
</ul>
<p>试想如果是用两次握手，则会出现下面这种情况：</p>
<p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>
<h1 id="https-加密是对称的还是不对称的">https 加密是对称的还是不对称的<a hidden class="anchor" aria-hidden="true" href="#https-加密是对称的还是不对称的">#</a></h1>
<p>HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。</p>
<h1 id="流量控制如何实现的">流量控制如何实现的<a hidden class="anchor" aria-hidden="true" href="#流量控制如何实现的">#</a></h1>
<p>流量控制是使用滑动窗口来实现的。接收方确认报文中的窗口字段可以用来控制发送方窗口的大小。</p>
<p>如果窗户的值为 0，则发送方停止发送数据，但是发送方会定期的向接收方发送窗口探测报文以得到窗口的大小。</p>
<p>补充</p>
<p>TCP 传输协议中，流量控制是使用滑动窗口（Sliding Window）来实现的。滑动窗口是一种基于数据流的、动态调整的、可变大小的窗口，它通过协商双方的接收窗口和发送窗口大小，控制数据的传输速率。</p>
<p>在 TCP 协议中，每个数据包都有一个序号，接收方通过序号来确认是否收到了正确的数据包。发送方将数据分成若干个数据段(数据段&quot;是指传输的基本单位。当应用程序向 TCP 层发送大量数据时，TCP 会将这些数据分割为适合网络传输的大小，每一部分被称为一个&quot;数据段&quot;。)，每个数据段的大小不超过发送窗口的大小，然后将这些数据段发送给接收方。接收方会确认已经收到的数据，同时告诉发送方自己的接收窗口大小。发送方根据接收方的窗口大小，动态调整自己的发送窗口大小，从而控制数据的传输速率。</p>
<p>滑动窗口的大小是可以动态调整的，它可以根据网络状况和双方的能力来自适应地调整，从而实现流量控制的功能。如果接收方的接收窗口变小，发送方会相应地减小自己的发送窗口，以避免过多的数据堆积在网络中导致拥塞。如果接收方的接收窗口变大，发送方会相应地增加自己的发送窗口，以提高数据传输速率。</p>
<h1 id="close_wait-time_wait-fin_wait2">close_wait time_wait fin_wait2<a hidden class="anchor" aria-hidden="true" href="#close_wait-time_wait-fin_wait2">#</a></h1>
<ul>
<li>fin_wait2 还有数据接收能力，但是没有数据发送能力</li>
<li>close_wait 还有数据要发送就进入这状态</li>
<li>time_wait 又叫 2MSL 等待状态。防止最后一次 ack 没有接收到，在这个阶段中，同一个 socket 不能再被使用</li>
</ul>
<h1 id="流量控制">流量控制<a hidden class="anchor" aria-hidden="true" href="#流量控制">#</a></h1>
<ul>
<li>
<p>目的是接收方通过 TCP 头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。</p>
</li>
<li>
<p>TCP 是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。</p>
<ul>
<li>发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的 TCP 报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。</li>
<li>接收窗：用来标记可以接收的数据大小。</li>
</ul>
</li>
<li>
<p>TCP 是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收部分。</p>
</li>
<li>
<p>发送窗内数据只有当接收到接收端某段发送数据的 ACK 响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。\</p>
</li>
</ul>
<h1 id="session和cookie应该如何去选择">Session和cookie应该如何去选择<a hidden class="anchor" aria-hidden="true" href="#session和cookie应该如何去选择">#</a></h1>
<p><code>Session</code>和<code>Cookie</code>都是用来跟踪浏览器用户身份的会话技术，但它们之间有一些关键的区别：</p>
<ol>
<li>
<p><strong>存储位置</strong>：</p>
<ul>
<li><code>Cookie</code>数据存放在客户端（浏览器）。</li>
<li><code>Session</code>数据存放在服务器。</li>
</ul>
</li>
<li>
<p><strong>生命周期</strong>：</p>
<ul>
<li><code>Cookie</code>只在设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭。</li>
<li><code>Session</code>默认情况下，仅在浏览器运行期间存在，关闭浏览器则<code>Session</code>结束。开发者也可以设置Session的失效时间。</li>
</ul>
</li>
<li>
<p><strong>存储大小</strong>：</p>
<ul>
<li><code>Cookie</code>的大小受限制。它依赖于浏览器的不同可能有所不同，一般为4KB左右。</li>
<li><code>Session</code>没有大小限制，可以存储较大量的数据。</li>
</ul>
</li>
<li>
<p><strong>安全性</strong>：</p>
<ul>
<li><code>Cookie</code>存储在客户端，相对容易被篡改，比较不安全。</li>
<li><code>Session</code>存储在服务器端，相对较安全。</li>
</ul>
</li>
<li>
<p><strong>跨域问题</strong>：</p>
<ul>
<li><code>Cookie</code>只能在同源的情况下共享。</li>
<li><code>Session</code>由于存储在服务器上，可以在多个不同域名的页面间共享。</li>
</ul>
</li>
<li>
<p>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</p>
</li>
<li>
<p>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</p>
</li>
<li>
<p>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</p>
</li>
</ol>
<h1 id="jwt-token是什么">JWT token是什么？<a hidden class="anchor" aria-hidden="true" href="#jwt-token是什么">#</a></h1>
<p>JWT Token是一种用于身份验证和授权的安全令牌，包含了用户的信息和数字签名，可以在多个系统间共享。</p>
<p>JWT由三部分组成：头部(Header)、载荷(Payload)和签名(Signature)。其中:</p>
<ul>
<li>头部包含令牌类型、算法、发行者、受众和有效期等信息；</li>
<li>载荷包含用户信息；</li>
<li>签名则是对整个JWT进行加密签名，以保证其安全性。</li>
</ul>
<p>Token是一个用于访问资源的凭证，它包含了身份验证信息和关联的元数据。</p>
<h1 id="udp如何实现可靠传输">udp如何实现可靠传输<a hidden class="anchor" aria-hidden="true" href="#udp如何实现可靠传输">#</a></h1>
<p>最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。</p>
<p>1、添加seq/ack机制，确保数据发送到对端</p>
<p>2、添加发送和接收缓冲区，主要是用户超时重传。</p>
<p>3、添加超时重传机制。
详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p>
<p>#TCP一次可以发一个数据包还是几个数据包</p>
<p>流式服务，每次发生一个数据，他会底层进行切分</p>


        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://chx9.github.io/posts/cs/leetcode/">
    <span class="title">« 上一页</span>
    <br>
    <span>leetcode</span>
  </a>
  <a class="next" href="https://chx9.github.io/posts/read/read/">
    <span class="title">下一页 »</span>
    <br>
    <span>My Book List</span>
  </a>
</nav>

        </footer>
    </div>

<style>
    .comments_details summary::marker {
        font-size: 20px;
        content: '👉展开评论';
        color: var(--content);
    }
    .comments_details[open] summary::marker{
        font-size: 20px;
        content: '👇关闭评论';
        color: var(--content);
    }
</style>


<div>
    <details class="comments_details">
        <summary style="cursor: pointer; margin: 50px 0 20px 0;width: 130px;">
            <span style="font-size: 20px;color: var(--content);">...</span>
        </summary>
        <div id="tcomment"></div>
    </details>
    <script src="https://cdn.staticfile.org/twikoo//twikoo.all.min.js">
    </script>
    <script>
        twikoo.init({
            envId:  null ,
        el: "#tcomment",
            lang: 'zh-CN',
            region:  null ,
        path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
        })
    </script>
</div>
</article>
</main>

<footer class="footer">
    <span>
        Copyright
        &copy;
        -2023
        <a href="https://chx9.github.io/" style="color:#939393;">chx9</a>
        All Rights Reserved
    </span>
    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;"></a>&nbsp;
    <span>
        <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null"
           style="display:inline-block;text-decoration:none;height:20px;color:#939393;">
            <img src="" style="float:left;margin: 0px 5px 0px 0px;"/>
            
        </a>
    </span>
    <span id="busuanzi_container">
        <span class="fa fa-user"></span> <span id="busuanzi_value_site_uv"></span>
        <span class="fa fa-eye"></span> <span id="busuanzi_value_site_pv"></span>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
</script>
<script>
    let mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        (function() {
            document.cookie = "change-themes" + "="+ escape ("false");
        })()

        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    });
</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() 
                let textData = window.getSelection().toString() 
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
                
                
                
                
                
                
                
                
                
                
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;
        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '📄复制';

        function copyingDone() {
            copybutton.innerText = '👌🏻已复制!';
            setTimeout(() => {
                copybutton.innerText = '📄复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent 
                
                
                
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {}
            selection.removeRange(range);
        });

        let language = codeblock.className.replaceAll("language-", "")
        let macTool = document.createElement("div")
        let macTool1 = document.createElement("div")
        let macTool2 = document.createElement("div")
        let macTool3 = document.createElement("div")
        let languageType = document.createElement("div")
        languageType.innerText = language
        
        
        
        
        languageType.setAttribute('class', 'language-type')
        macTool.appendChild(macTool1)
        macTool.appendChild(macTool2)
        macTool.appendChild(macTool3)
        macTool.appendChild(languageType)

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
            container.appendChild(macTool)
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        }
    });
</script>
</body>

</html>
