---
title: "Mysql"
date: 2023-07-29T11:06:20+08:00
lastmod: 2023-07-29T11:06:20+08:00
author: ["chx9"]
keywords:
  -
categories: # 没有分类界面可以不填写
  -
tags: # 标签
  -
description: ""
weight:
slug: ""
draft: false # 是否为草稿
comments: true # 本页面是否显示评论
reward: false # 打赏
mermaid: true #是否开启mermaid
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示路径
cover:
  image: "" #图片路径例如：posts/tech/123/123.png
  zoom: # 图片大小，例如填写 50% 表示原图像的一半大小
  caption: "" #图片底部描述
  alt: ""
  relative: false
---

# 脏读，幻读，不可重复读解决了什么问题

脏读、幻读、可重复读是数据库中常见的隔离级别问题，它们分别解决了以下问题：

1. 脏读（Dirty Read）：当一个事务读取到另一个事务未提交的数据时，就产生了脏读。脏读可能导致数据的不一致性，因为读取到的数据可能会随时被其他事务修改或回滚。解决脏读的问题需要使用隔离级别为 Read Committed 或以上的级别，保证读取到的数据都是已经提交的数据。

2. 幻读（Phantom Read）：当一个事务读取到其他事务插入的新数据时，就产生了幻读。幻读可能导致数据的不一致性，因为读取到的数据可能会随时被其他事务修改或删除。解决幻读的问题需要使用隔离级别为 Serializable 级别，保证读取的数据都是一致的。

3. 可重复读（Repeatable Read）：当一个事务读取到其他事务修改的数据时，就产生了可重复读。可重复读可能导致数据的不一致性，因为读取到的数据可能会随时被其他事务修改或删除。解决可重复读的问题需要使用隔离级别为 Repeatable Read 或以上的级别，保证读取到的数据在事务提交之前不会被其他事务修改或删除。

需要注意的是，提高隔离级别可以降低并发性能，因此需要根据实际情况来选择合适的隔离级别，同时需要注意数据库的锁机制和优化策略，以提高系统的性能和可用性。

# mysql 索引失效的几种方式

1. 联合索引不满足最左匹配原则
2. 使用了 select \*
3. 索引列参与运算
4. 索引列参使用了函数示例
5. like 出现在开头 %abcd
6. 使用 OR 操作

# 索引使用假设有一个联合索引(a,b,c)，分析以下查询情况：

1. b = 2 and a=1

此查询条件可以很好地利用索引，因为索引的第二个字段是 b，第一个字段是 a，可以直接定位到满足条件的行。

2. b = 2 or a = 1

这个查询条件不能很好地利用索引，因为这是一个或条件，需要同时扫描索引中 a=1 和 b=2 的记录，然后再将结果合并。因此，在这种情况下，数据库可能会选择使用全表扫描而不是索引扫描。

3. a = 1 and b > 2

此查询条件可以利用索引的前两个字段（a,b），可以直接定位到满足条件的行。

4. a > 1 and b =2

这个查询条件不能很好地利用索引，因为索引是按(a,b,c)的顺序排列的，而查询条件中第一个字段是 a，第二个字段是 b，第三个字段是 c，所以在 b=2 的情况下，需要扫描所有 a>1 的记录，直到找到满足条件的记录。因此，在这种情况下，数据库可能会选择使用全表扫描而不是索引扫描。

# 索引使用

总之，联合索引(a,b,c)在不同的查询条件下，可以有不同的索引扫描效果。在实际应用中，建立联合索引的时候，需要根据实际情况和查询需求，选择合适的索引列顺序和索引列组合方式，以获得更好的索引扫描效果。

# mysql 优化

MySQL 查询优化是提高 MySQL 数据库性能的重要手段之一，它可以优化查询语句、数据表结构、索引等方面，以提高查询效率和性能。具体来说，MySQL 查询优化可以从以下几个方面入手：

1. 优化查询语句：优化查询语句是提高 MySQL 查询性能的第一步，可以通过使用合适的查询语句、避免使用子查询、避免使用%通配符、缩小查询范围等方式来减少查询时间和资源消耗。

2. 优化数据表结构：优化数据表结构可以提高 MySQL 数据库的查询性能和效率，可以通过合理设计数据表、避免使用过多的列、避免使用 TEXT 和 BLOB 类型等方式来提升 MySQL 数据库的性能。

3. 优化索引：索引是提高 MySQL 查询性能的重要手段之一，可以通过创建合适的索引、避免过多的索引、避免使用过多的组合索引、避免使用不必要的索引等方式来提高 MySQL 查询性能。

4. 避免全表扫描：全表扫描是 MySQL 查询性能低下的主要原因之一，可以通过使用索引、分区表、分页等方式来避免全表扫描，提高查询效率和性能。

5. 调整服务器参数：调整服务器参数可以提高 MySQL 数据库的性能和效率，可以通过调整缓存大小、调整线程池、调整查询缓存等方式来提高 MySQL 数据库的性能和效率。

总之，MySQL 查询优化是提高 MySQL 数据库性能和效率的重要手段之一，需要根据实际情况采取合适的优化方法和手段来提高 MySQL 数据库的性能和效率。

# 索引的类型

在数据库中，索引是一种特殊的数据结构，可以加快查询操作的速度。常见的索引类型包括以下几种：

1. B-Tree 索引：B-Tree 索引是一种最常见的索引类型，适用于范围查找、等值查找等操作。B-Tree 索引可以快速定位到指定的记录，同时支持多列索引和前缀索引。

2. Hash 索引：Hash 索引是一种基于哈希表的索引类型，适用于只有等值查找操作的场景。Hash 索引可以快速定位到指定的记录，但不支持范围查找和排序操作。

3. Full-Text 索引：Full-Text 索引是一种用于全文搜索的索引类型，适用于文本字段的搜索。Full-Text 索引可以在搜索中使用自然语言查询、通配符、布尔运算等操作，提供更加灵活的搜索功能。

4. R-Tree 索引：R-Tree 索引是一种用于空间数据的索引类型，适用于地理信息、图像、音频等空间数据的查询。R-Tree 索引可以快速定位到指定的空间数据，同时支持范围查找和空间关系查询。

5. Bitmap 索引：Bitmap 索引是一种基于位图的索引类型，适用于低基数列的查询。Bitmap 索引可以将每个唯一值映射为一个位图，可以快速定位到指定的记录，同时支持多列索引和位图合并等操作。

总之，不同类型的索引适用于不同的场景和查询操作，需要根据实际情况选择合适的索引类型来提高查询效率和性能。

# 红黑树

红黑树是一种自平衡二叉查找树，每个节点有一个颜色属性：红或黑。红黑树满足以下特性：

每个节点要么是黑色，要么是红色。
根节点是黑色。
所有叶子节点（NIL 节点，空节点）是黑色。
如果一个节点是红色的，则它的两个子节点都是黑色的。
从任意节点到其每个叶子节点的所有路径包含相同数量的黑色节点。

# 红黑树比 AVL 树的优点

红黑树与 AVL 树都是自平衡二叉搜索树，但红黑树在实际应用中的优点如下：

- 调整次数少：AVL 树每次插入或删除可能需要进行多次调整，而红黑树最多只需 3 次。
- 结构稳定：红黑树对于相同集合的数据，形成的结构是唯一的，而 AVL 树则可能有多种。
- 适用于读操作多的情况：AVL 树由于严格的平衡性，查找效率较高，适合读操作多的情况，而红黑树虽然平衡性较差，但是其维护平衡的代价小，更适合写操作多的场景。

# 数据库三大范式

数据库的三大范式是为了消除数据冗余和提高数据完整性而制定的规则：

第一范式（1NF）：表的每一列都是不可分割的基本数据项，同一列中的值必须是相同类型，且唯一。

第二范式（2NF）：在 1NF 的基础上，所有非主属性（非码属性）完全依赖于主键（码）。即一个表只描述一件事情。

第三范式（3NF）：在 2NF 的基础上，消除传递依赖，非主属性之间不能存在依赖关系。

**第一范式（1NF）**

违反 1NF 的例子：
表格有一个“客户”字段，该字段中存储了客户的名字和地址。

| 客户       |
| ---------- |
| 张三, 北京 |
| 李四, 上海 |

遵循 1NF 后：
将“客户”字段分割为“客户名字”和“客户地址”。

| 客户名字 | 客户地址 |
| -------- | -------- |
| 张三     | 北京     |
| 李四     | 上海     |

**第二范式（2NF）**

违反 2NF 的例子：

| 学号 | 课程 | 教室 | 老师 |
| ---- | ---- | ---- | ---- |
| 1001 | 数学 | A101 | 张三 |
| 1002 | 英语 | B201 | 李四 |

此表的主键是(学号, 课程)，但"教室"只依赖"课程"，"老师"也只依赖"课程"，不满足 2NF。

遵循 2NF 后：
拆成两个表，每个表都满足所有非主属性完全依赖于全部候选键。

学生选课表：

| 学号 | 课程 |
| ---- | ---- |
| 1001 | 数学 |
| 1002 | 英语 |

课程表：

| 课程 | 教室 | 老师 |
| ---- | ---- | ---- |
| 数学 | A101 | 张三 |
| 英语 | B201 | 李四 |

**第三范式（3NF）**

违反 3NF 的例子：

| 订单编号 | 商品编号 | 商品价格 |
| -------- | -------- | -------- |
| O001     | G001     | 50       |
| O002     | G002     | 100      |

此表中，“商品价格”直接依赖于“商品编号”，而不是“订单编号”。

遵循 3NF 后：
拆分为两张表，消除传递依赖。

订单表：

| 订单编号 | 商品编号 |
| -------- | -------- |
| O001     | G001     |
| O002     | G002     |

商品表：

| 商品编号 | 商品价格 |
| -------- | -------- |
| G001     | 50       |
| G002     | 100      |

# mysql page cache 技术

MySQL 的 Page Cache 技术是一种基于内存的缓存技术，它可以将磁盘上的数据缓存在内存中，以加速数据库的读取操作。Page Cache 的实现原理是将磁盘上的数据分割成固定大小的页面（通常是 16KB），然后将这些页面缓存到内存中。

当 MySQL 需要读取数据时，它首先检查 Page Cache 中是否已经缓存了所需的页面。如果页面已经在 Page Cache 中，则 MySQL 可以直接从内存中读取数据，从而避免了从磁盘上读取数据的开销。如果页面不在 Page Cache 中，则 MySQL 会从磁盘上读取数据并将其存储到 Page Cache 中，以便以后的读取操作可以更快地完成。

Page Cache 技术可以显著提高 MySQL 的读取性能，特别是对于那些需要频繁读取的数据。然而，它也有一些限制，例如缓存的数据量受限于可用内存的大小，而且 Page Cache 中的数据不会随着数据库的更新而自动更新，需要手动调用 MySQL 的刷新函数才能更新。因此，在使用 Page Cache 技术时需要仔细评估内存使用和缓存更新的策略，以确保系统的性能和稳定性。

# mysql 如何实现 MVCC 的

主要是两个
版本号：每个数据行都有一个版本号，用于表示该数据行的版本信息。在 MySQL 中，每个事务都有一个唯一的事务 ID，每次对数据行进行修改时，都会创建一个新的版本，并将该版本与当前事务 ID 绑定。

快照：每个事务都会创建一个独立的快照，用于保存该事务开始时数据库中所有数据行的版本信息。在 MySQL 中，快照是通过事务开始时的系统版本号来实现的。
